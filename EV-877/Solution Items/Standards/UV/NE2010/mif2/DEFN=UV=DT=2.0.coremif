<?xml version="1.0" encoding="UTF-8"?>
<!--
/*******************************************************************************
 * Copyright (c) 2010 Health Level Seven, Inc.
 * All rights reserved. This file and the model designs it contains 
 * are made available under terms of a proprietary license implicitly 
 * established by the terms expressed in the Bylaws of Health 
 * Level Seven, Inc. (HL7), in combination with the agreements under 
 * which individual and organizational memberships are established with HL7.
 * Links to the HL7 Bylaws may be found at http://www.hl7.org 
 *******************************************************************************/ 
				--><mif:datatypeModelLibrary xmlns:mif="urn:hl7-org:v3/mif2" packageKind="version" name="2.0"
                          title="Data Types - Abstract Specification"
                          schemaVersion="2.1.6">
   <mif:packageLocation combinedId="DEFN=UV=DT=2.0" root="DEFN" artifact="DT" realmNamespace="UV"
                        version="2.0"/>
   <mif:header>
      <mif:contributor>
         <mif:role>Primary Contributer &amp; Co-Chair of Modelling &amp; Methodology</mif:role>
         <mif:name name="Grahame Grieve"/>
         <mif:affiliation>Kestral Computing Pty. Ltd.</mif:affiliation>
         <mif:email>mailto://grahame@kestral.com.au</mif:email>
      </mif:contributor>
      <mif:contributor>
         <mif:role>Primary Contributer</mif:role>
         <mif:name name="Gunther Schadow"/>
         <mif:affiliation>Indiana School of Medicine</mif:affiliation>
         <mif:email>mailto://gschadow@regenstrief.org</mif:email>
      </mif:contributor>
      <mif:contributor>
         <mif:role>Primary Contributer (R1)</mif:role>
         <mif:name name="Paul Biron"/>
         <mif:affiliation>Sparrow Hawk Photography</mif:affiliation>
         <mif:email>mailto://paul@sparrow-hawk.org</mif:email>
      </mif:contributor>
      <mif:contributor>
         <mif:role>Primary Contributer &amp; Co-Chair of Modelling &amp; Methodology</mif:role>
         <mif:name name="Lloyd McKenzie"/>
         <mif:affiliation>Lloyd Mackenzie and Associates</mif:affiliation>
         <mif:email>mailto://lloyd@lmckenzie.com</mif:email>
      </mif:contributor>
      <mif:contributor>
         <mif:role>Co-Chair of Modelling &amp; Methodology</mif:role>
         <mif:name name="George (Woody) Beeler"/>
         <mif:affiliation>Beeler Consulting LLC</mif:affiliation>
         <mif:email>mailto://woody@beelers.com</mif:email>
      </mif:contributor>
      <mif:contributor>
         <mif:role>Co-Chair of Modelling &amp; Methodology</mif:role>
         <mif:name name="Dale Nelson"/>
         <mif:affiliation>II4SM</mif:affiliation>
         <mif:email>mailto://dale@zed-logic.com</mif:email>
      </mif:contributor>
      <mif:contributor>
         <mif:role>Co-Chair of Modelling &amp; Methodology</mif:role>
         <mif:name name="Craig Parker"/>
         <mif:affiliation>Arizona State University</mif:affiliation>
         <mif:email>mailto://craigparkermd@gmail.com</mif:email>
      </mif:contributor>
      <mif:contributor>
         <mif:role>Co-Chair of Modelling &amp; Methodology</mif:role>
         <mif:name name="Ioana Singureanu"/>
         <mif:affiliation>Eversolve, LLC</mif:affiliation>
         <mif:email>mailto://ioana.singureanu@gmail.com</mif:email>
      </mif:contributor>
      <mif:approvalInfo approvalStatus="Membership Ballot - Normative" ballotOccurrence="4"/>
   </mif:header>
   <mif:importedVocabularyModelPackage combinedId="DEFN=UV=VO" root="DEFN" realmNamespace="UV" artifact="VO"/>
   <mif:datatype name="ANY" title="DataValue" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An abstract type that defines the basic properties common to all data values defined in this specification. 
					Data Value is an abstract type, meaning that no proper value
					can be just a data value without belonging to any concrete type. Every concrete
					type is a specialization of this general abstract DataValue type.
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
abstract type DataValue alias ANY {
   TYPE  dataType;
   CS    nullFlavor;
   BN    nonNull;
   BN    isNull;
   BL    notApplicable;
   BL    unknown;
   BL    other;
   BL    equal(ANY x);
   protected  BN    identical(ANY x);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="dataType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Data Type"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The data type of the value. 
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Every proper data value implicitly carries
						information about its own data type.
					</mif:p>
                     <mif:p>
					Note that the type of a flavor is always the underlying type. For instance, the type of a 
					<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ED.IMAGE"/>
                        </mif:object> is always <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ED"/>
                        </mif:object>. The kind of flavor will be 
					identified in the flavorId property. See <mif:a href="#RepresentationalProperties"/> for
					further information.					
				</mif:p>
                     <mif:p>	
					An exceptional value may not have a type specified by its context of use, either in the applicable models or the instance itself. 
					In these cases, the datatype will default to <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>. Data values with a nullFlavor that
					implies INV SHALL have a known type that is not <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>.
				</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x) where x.nonNull {
   x.dataType.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x) 
  where x.nullFlavor.implies("INV") {
   x.dataType.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="nullFlavor" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Exceptional Value Detail"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						  An indicator of a data value's exceptional status, sometimes also denoting the manner and rationale for that status. 
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						A data type MAY have an exceptional value (NULL-value) rather than
						a proper value as described by this specification, either because
						the information does not exist, is not known or available, or
						cannot be expressed in the allowed value domain. In this case, 
						the nullFlavor expresses in what way and why proper information
						is missing. 
					</mif:p>
                     <mif:p>
						Null values are improper values that do not conform to the proper 
						or expected value domain as described by this specification. This
						specification makes many rules concerning the relationship between
						the nullFlavor property and other properties, and these rules SHALL
						always be true. Both nonNull and null values SHALL always be valid 
						according to the rules expressed in this specification.
					</mif:p>
                     <mif:p>
						Null values are also known as exceptional values. This is to denote that the
						information contained in the value is an exception to the expected value 
						domain that applies to the type. The information may either be missing or partially 
						present, or even completely present but not valid with respect to the constraints
						imposed by the Constraining Model (see <mif:a href="#dt2confmodel"/>).
					</mif:p>
                     <mif:p>
						The null concept provides a general framework for handling incomplete data which is often 
						encountered in healthcare information collection, use and analysis.
						The <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> property plays a special role in the conformance framework. See 
						"Conformance" in Core Principles of V3 Models [<mif:a href="../coreprinciples/coreprinciples.htm#coreP_V3_Conformance"/>] for further information.
					</mif:p>
                     <mif:p>
						The null flavors are a general domain extension of all normal data
						type domains ("domain" in this sense means the set of all possible values 
						for the data type, not "domain" in the more restricted sense used for 
						coded data types). So this is true not only for coded data types with specified
						vocabulary domains, but for non-coded value domains as well, e.g. integers,
						temporal intervals, infectious disease cases, etc.
					</mif:p>
                     <mif:p>
						Note that while all these nullFlavors are considered to be exceptional values - a proper 
						value is not known, under some circumstances the nullFlavor itself may 
						be semantically useful. For instance, while the value PINF may represent an actual unknown value, it can be used as the upper limit of an 
						interval. Similarly, the value QS represents an unknown amount but may be converted to
						a real amount during the actual dispensing of a formulation.  
					</mif:p>
                     <mif:p>
						As a general domain extension of all normal data types, the null flavors
						also extend the literal form of those data types that have a literal 
						form. In any literal form, the literal NullFlavor.X signals that the 
						data type has the assigned nullFlavor, where X is the code, such as NA.
					</mif:p>
                     <mif:p>
						Note that the nullFlavor property isNull is reverse to that of the data type 
						itself. If the data type is not null, then the nullFlavor property itself will be null.
						If the data type is null, then the nullFlavor is not null - it will
						specify an actual nullFlavor that provides more detail as to in what
						way or why no proper value is supplied.
					</mif:p>
                     <mif:p>
						The general implication of this is that in a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> or descendant 
						(usually <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CS"/>
                        </mif:object>), when the code for a nullFlavor is carried in the 
						code/codeSystem (code = "NI" and codeSystem = "2.16.840.1.113883.5.1008"),
						the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> itself is not null. The <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> is only
						null when its nullFlavor carries this code.     
					</mif:p>
                     <mif:p>	
						When performing operations upon null values, the semantic meaning
						of the nullFlavor SHALL be considered. This is particularly important
						for equality. The only case where non-proper (NULL) values may be equal
			           is where both values have a nullFlavor of NA. In most other 
			           cases, the outcome of comparing NULL values is also null. However, there
			           are exceptions based on the semantic meaning of nullFlavor. 
								For instance, although direct comparison of two values with 
								nullFlavor PINF is always null (NI), two intervals
								with the equal low bounds and high bounds of PINF will return true,
								since they specify the same set. Similarly, comparison of NINF
								and PINF is always False. 
					</mif:p>
                     <mif:p>
						The "actual value" refers to the value of the 
						information itself, rather than the information as represented in 
						the type itself. These two may diverge when the information provided
						is incomplete, such as when an expression is provided.					
						The null flavor "other" is used whenever the actual value is not in
						the required value domain: this may occur, for example, when the value
						exceeds some constraints that are defined in too restrictive a manner
					</mif:p>
                     <mif:p> 
						For example, if the value for age is 100 yrs, but the constraining 
						model specifies that the age must be less than 100 years, the age 
						may still be specified, provided that the model does not make the 
						attribute mandatory. 
					</mif:p>
                     <mif:p>
						Some of the null flavors are not generally applicable to all data types.
						
						The nullFlavors NINF and PINF SHALL only be associated with <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="QTY"/>
                        </mif:object> types
						other than <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="MO"/>
                        </mif:object> and <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="RTO"/>
                        </mif:object>. The nullFlavors QS, and TRC 
						SHALL only be used with <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object>. The nullFlavor UNC SHALL only be used with 
						any type that has an originalText, and when UNC is used the originalText
						property SHALL be populated. The nullFlavor DER SHALL only be used with the 
						<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="EXPR"/>
                        </mif:object> type, and an expression SHALL be provided.
					</mif:p>
                     <mif:p>
						Note: the two nullFlavors INV and OTH draw a distinction between the actual
						value and the vlalue as represented in the instance. Some of the datatypes
						may be used to provide a representation of the value which requires subsequent
						transformation to generate the real value. For instance, an expression may be
						provided which will generate an actual value that is in the required value
						domain of the instance.
					</mif:p>
                     <mif:p>
						Some of these null flavors are associated with named properties that can be
						used as simple predicates for all data values. This does not change the semantics of the property; it is done to
						simplify the formulation of invariants in the remainder of this
						specification.
					</mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="ITS-Note">
                  <mif:text>
                     <mif:p>
							NULL-flavors are applicable to any property of a data value or a
							higher-level object attribute. Where the null flavor is
							determited to be not significant by the core HL7 infrastrcture committees, ITS are not required to represent them. If nothing
							else is noted in this specification, ITS need not represent general
							NULL-flavors for data-value properties. In addition, there is a difference
							between semantic properties and representational "components" of data values.
							An ITS SHOULD only represent those components that are needed to <mif:b>infer</mif:b> the
							semantic properties. The null-flavor predicates <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="nonNull"/>
                           <mif:param name="datatypeName" value="ANY"/>
                        </mif:object>,
							<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="isNull"/>
                           <mif:param name="datatypeName" value="ANY"/>
                        </mif:object>, <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="notApplicable"/>
                           <mif:param name="datatypeName" value="ANY"/>
                        </mif:object>,
							<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="unknown"/>
                           <mif:param name="datatypeName" value="ANY"/>
                        </mif:object>, and <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="other"/>
                           <mif:param name="datatypeName" value="ANY"/>
                        </mif:object> can
							all be inferred from the <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> property.
						</mif:p>
                  </mif:text>
               </mif:otherAnnotation>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x) {
   x.nullFlavor.isNull.equal(x.nonNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x) {
  x.nullFlavor.implies(NullFlavor.PINF).implies(x.dataType.implies(QTY));
  x.nullFlavor.implies(NullFlavor.NINF).implies(x.dataType.implies(QTY));
  x.nullFlavor.implies(NullFlavor.QS).implies(x.dataType.implies(QTY));
  x.nullFlavor.implies(NullFlavor.TRC).implies(x.dataType.implies(QTY));

  /* if whatever type x is doesn't have an originalText property, 
     the invariant will be null (not true) */
  x.nullFlavor.equals(UNC).implies(((x.dataType)x).originalText.nonNull);

  x.nullFlavor.equals(DER).implies(x.dataType.implies(EXPR&lt;QTY&gt;)
    .and((EXPR&lt;QTY&gt;) x).expression.nonNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:staticExample itsName="XML">
                  <mif:data>
                     <example>
&lt;value nullFlavor="OTH" value="120" unit="yr"/&gt;</example>
                  </mif:data>
               </mif:staticExample>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="NullFlavor"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="nonNull" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Proper Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
					    A predicate indicating that that a property has a value, i.e.  is a non-null ("non-exceptional") value of the data type.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						When a property (i.e. RIM attribute, or message field) is labeled
						<mif:b>mandatory</mif:b>, and the container is not null itself,
						then any value assigned to the property SHALL be nonNull.
			        </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x) {
   x.nonNull.equal(x.isNull.not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BN"/>
      </mif:property>
      <mif:property name="isNull" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Exceptional Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A predicate indicating that that a value is an exceptional value, or a null-value. 
						A null value means that the information does not exist, is not available, or cannot
						be expressed in the data type's normal value set.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Every data element has either a proper value or it is
						considered NULL. If (and only if) it is NULL, the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="nullFlavor"/>
                           <mif:param name="datatypeName" value="ANY"/>
                        </mif:object> provides
						more detail as to in what way or why no proper value is supplied.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x) {
   x.isNull.equal(x.nullFlavor.implies(NullFlavor.NI));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BN"/>
      </mif:property>
      <mif:property name="notApplicable" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Inapplicable Proper Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A predicate indicating that this exceptional value is of
						<mif:object name="propertyRef">
                        <mif:param name="propertyName" value="nullFlavor"/>
                        <mif:param name="datatypeName" value="ANY"/>
                     </mif:object> not-applicable (NA), i.e., that a proper
						value is not meaningful in the given context.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x) {
   x.notApplicable.equal(x.nullFlavor.implies(NullFlavor.NA));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="unknown" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="unknown"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A predicate indicating that this exceptional value is of
						<mif:object name="propertyRef">
                        <mif:param name="propertyName" value="nullFlavor"/>
                        <mif:param name="datatypeName" value="ANY"/>
                     </mif:object> unknown (UNK).
        			</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x) {
   x.unknown.equal(x.nullFlavor.implies(NullFlavor.UNK));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="other" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value Domain Exception"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A predicate indicating that this exceptional value is of
						<mif:object name="propertyRef">
                        <mif:param name="propertyName" value="nullFlavor"/>
                        <mif:param name="datatypeName" value="ANY"/>
                     </mif:object> other (OTH), i.e., that the required
						value domain does not contain the appropriate value.
			        </mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x) {
   x.other.equal(x.nullFlavor.implies(NullFlavor.OTH));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="equal" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A reflexive, symmetric, and transitive relation between
						any two data values indicating that the two values are the same.
			        </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						How equality is determined must be defined for each data type, and 
						care must be taken when implementing equals in a polymorphic environment.
						There is a tension between what is logical and desired, and the
						requirement for symmetry and transitivity.
						<mif:object name="footnote">
						  	A typical case is where a type A has a property a, and type B extends A by
						  	adding property b. Many implementers will say A.equals(A other) is true if 
						  	this.a = other.a, and that B.equals(B other) if this.b = other.b. However
						  	in this case, given a1 of type A and b1 of type B, a.equals(b) is true, and 
						  	b.equals(a) is false. 
						  </mif:object>
						These data types and the 
						definitions of equals have been carefully constructed so that their definitions
						of equals are both symmetric and transitive. 
					</mif:p>
                     <mif:p>
						Some of the definitions of equality exclude some of the properties of
						a data type from the equality test, where those properties are not essential to the 
						meaning of the value. In addition, some interpretation of the 
						semantics of the values may be required to determine the equality of 
						two values. For example physical quantity (<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value=""/>
                        </mif:object>) has the two semantic
						properties (1) a real number and (2) a coded unit of measure. The equality
						test, however, must account for the fact that, e.g., 1 meter equals 100
						centimeters; independent equality of the two semantic properties is
						too strong a criterion for the equality test. Therefore, physical
						quantity must override the equality definition.
					</mif:p>
                     <mif:p>
						The requirement for understanding the meaning of the data applies to nullFlavors
						as well. Under certain circumstances the test for equality between two different
						values with different flavors of null may not be null. Consult <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="nullFlavor"/>
                           <mif:param name="datatypeName" value="ANY"/>
                        </mif:object> 
						for more information. 	
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   x.equal(x);                                         /* reflexivity */
   x.equal(y).equal(y.equal(x));                       /* symmetry */
   x.equal(y).and(y.equal(z)).implies(x.equal(z));      /* transitivity */
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="identical" sortKey="09" propertyKind="variableProperty"
                    visibility="protected"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Identity Comparison"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Identity comparison is a reflexive, symmetric, and transitive relation between
						any two data values. Any values can be identical, whether or not
						they are null or contain property with null values. The identity comparison
						always returns true or false. The result is never null.
			        </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The identity relationship is defined to assist in the definition of uniqueness
						constraints on <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="DSET"/>
                        </mif:object>s. The identity relationship SHOULD NOT
						otherwise be used as it has no other use, and is therefore given a protected
						status to indicate that it should not be used outside this specification.
					</mif:p>
                     <mif:p>
						How identity is determined is the same for every data type except <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="BL"/>
                        </mif:object>.
						If all the properties of two values are identical, the values are identical. For
						<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="BL"/>
                        </mif:object>, the two values are identical if they have the same nullFlavor
						or if they are both true or both false.<mif:object name="footnote">
								This formal definition is satisfactory to determine identity, but not 
								particularly practical in this form. Implementations of the data types
								may specify alternate methods for how identical is determined. Since the 
								primary intent of this property is to assist with uniqueness constraints 
								on sets, comparison of pointers to objects may suffice in platforms where
								this makes sense (i.e. Java = instead of equal()).
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x, y, z) {
   x.identical(x);                                              /* reflexivity */
   x.identical(y).equal(y.identical(x));                        /* symmetry */
   x.identical(y).and(y.identical(z)).implies(x.identical(z));  /* transitivity */
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BN"/>
      </mif:property>
      <mif:property name="updateMode" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Update Mode"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						This property allows a sending system to identify the role that the attribute plays in
						processing the instance that is being represented.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
					Update Mode is fully defined and discussed in the "Core Principles of V3 Models" specification under "Update Mode"
					([<mif:a href="../coreprinciples/coreprinciples.htm#coreP_Update_Mode"/>]).
				</mif:p>
                     <mif:p>
					  UpdateMode SHALL only be applied to data type values when the value is an attribute of
					  a RIM class or an item in a collection that that is an attribute of a RIM Class. 
					  Because data values have neither identity nor state nor changing of state, 
					  update modes do not apply for the properties of data values; data values 
					  and their properties are never updated. 
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
   CS  updateMode; 
</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="HL7UpdateMode"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="flavorId" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Flavor Id"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						This property specifies the data type flavors that apply to this value.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
					  The full details concerning the use of data type flavors are discussed in the
					  Refinement, Constraint and Localization Specification. This property is used
					  to support instance validation. No other semantic or computational use SHALL
					  depend on the value of this property. If this value is populated, the data type
					  flavor(s) SHALL be a valid constraint on the type of the value.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
   SET&lt;ST.SIMPLE&gt;  flavorId;
</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="SET">
            <mif:argumentDatatype name="ST.SIMPLE"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TYPE" title="DataType" datatypeKind="Definition" visibility="private">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					The data type of a data element or property.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>					
					This property is a meta-type declared in order to allow the formal definitions to make
					invariants about the data type of a value. Any data type defined in this
					specification is a value of the type DataType.
				</mif:p>
                  <mif:p>
					Note that the type of a flavor is always the underlying type. For instance, the type of a 
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ED.IMAGE"/>
                     </mif:object> is always <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ED"/>
                     </mif:object>. The kind of flavor will be 
					identified in the flavorId property. See <mif:a href="#RepresentationalProperties"/> for
					further information.					
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
private type DataType alias TYPE specializes ANY {
   ST  shortName;
   ST  longName;
   BL  implies(TYPE that);
   BL  isComparableTo(TYPE that);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="shortName" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Short Name"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						 The alias of the data type.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(DataType x)
      where x.nonNull {
   x.shortName.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="longName" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Long Name"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						 The full name of the data type.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="equal" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two nonNull data types are equal if they are the same type.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(DataType x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.shortName.equal(y.shortName));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="TYPE"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="implies" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Implies"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A relation that indicates that a data type has the same type or is a specialization of the argument type.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="that" sortKey="1">
            <mif:type name="TYPE"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="isComparableTo" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Comparable To"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A relation that indicates whether two types have the same equality criteria
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						A data type is comparable to another data type if they both have the same equality 
						criteria. For instance, <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value=""/>
                        </mif:object> has the same equality criteria as
						<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value=""/>
                        </mif:object>, so <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value=""/>
                        </mif:object> is comparable to <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value=""/>
                        </mif:object>. Note that
						the fact that two data types can be compared does not mean that all instances 
						of the data types may be compared - for instance, it is not possible to compare
						the PQ values 3yr and 5m.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="that" sortKey="1">
            <mif:type name="TYPE"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="BL" title="Boolean" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A binary value for use in boolean logic. A <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object>
					value can be either <mif:b>true</mif:b> or <mif:b>false</mif:b>, or, as
					any other value, MAY be NULL.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					With any data value potentially being NULL, the two-valued logic is
					effectively extended to a three-valued logic as shown in the following
					truth tables:
				</mif:p>
                  <mif:div title="Truth tables for Boolean logic with NULL values">Truth Table: NOTNOTÂ truefalsefalsetrueNULLNULLTruth Table: ANDANDtruefalseNULLtruetruefalseNULLfalsefalsefalsefalseNULLNULLfalseNULLTruth Table: ORORtruefalseNULLtruetruetruetruefalsetruefalseNULLNULLtrueNULLNULL</mif:div>
                  <mif:p>
					Where a boolean operation is performed upon 2 data types with different
					nullFlavors, the nullFlavor of the result SHALL be any common ancestor
					of the 2 different nullFlavors. The result SHOULD be the first common ancestor.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type Boolean alias BL specializes ANY
   values(true, false) {
            BL  not;
            BL  and(BL x);
            BL  or(BL x);
            BL  xor(BL x);
            BL  implies(BL x);
   literal  ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:enumerationValue>true</mif:enumerationValue>
      <mif:enumerationValue>false</mif:enumerationValue>
      <mif:property name="not" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Negation"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The opposite value. Negation of a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> turns <mif:b>true</mif:b> into <mif:b>false</mif:b>
						and <mif:b>false</mif:b> into <mif:b>true</mif:b> and is NULL for NULL
						values.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BL x) {
   true.not.equal(false);
   false.not.equal(true);
   x.isNull.equal(x.not.isNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="and" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Conjunction"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Conjunction between a value and another value indicates that both values are true. Conjunction is associative and commutative, with
						<mif:b>true</mif:b> as a neutral element. <mif:b>False</mif:b> AND any
						Boolean value is <mif:b>false</mif:b>. These rules hold even if one or
						both of the operands are NULL. If both operands for AND are NULL,
						the result is NULL.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BL x, y) {
   x.and(true).equal(x);
   x.and(false).equal(false);
   x.isNull.implies(x.and(y).isNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="or" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Disjunction"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
	                    A parametric property indicating that the value or the argument is true, or both are true.				
						The disjunction <mif:b>x</mif:b> OR <mif:b>y</mif:b> is <mif:b>false</mif:b>
						if and only if <mif:b>x</mif:b> is <mif:b>false</mif:b> and <mif:b>y</mif:b>
						is <mif:b>false</mif:b>.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BL x, y) {
   x.or(y).equal(x.not.and(y.not).not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="xor" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Exclusive Disjunction"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A parametric property indicating that either the value or the argument is true, but not both. 
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BL x, y) {
   x.xor(y).equal(x.or(y).and(x.and(y).not));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="equal" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two non null <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> are equal if the have the same value.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BL x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.equal(true).and(y.equal(true).or(x.equal(false).and(y.equal(false)))));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="implies" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Implication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
					    A parametric property indicating that the argument is true when the value is true, supporting rules of the form IF condition THEN conclusion
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>					
						Logically, the implication is defined as the
						disjunction of the negated condition and the conclusion, meaning that
						when the condition is <mif:b>true</mif:b> the conclusion must be
						<mif:b>true</mif:b> to make the overall statement <mif:b>true</mif:b>.
						The logical implication is important to make invariant statements. 
					</mif:p>
                     <mif:p>
						The implication is not reversible and does not specify whether the condition is
						<mif:b>true</mif:b> when the condition is <mif:b>false</mif:b> (<mif:b>ex
						falso quodlibet</mif:b> lat. âfrom false follows anythingâ).
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BL condition, conclusion) {
   condition.implies(conclusion).equal(
      condition.not.or(conclusion));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="literal" sortKey="07" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The literal form of the Boolean is determined by the named values
						specified in the values clause, i.e., <mif:b>true</mif:b> and
						<mif:b>false</mif:b>.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="COLL" title="Collection" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A collection of values which can be enumerated using an iterator.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is introduced to represent the concept of an enumerable collection.
					Collections that are enumerable are inherently countable, though some collections
					may have an infinite number of items in the collection.
				</mif:p>
                  <mif:p>
					RIM attributes with a collection type MAY be assigned a cardinality by the constraining
					model. In these cases, the cardinality is understood to refer to the number of items 
					in the collection. To require that a collection have at least one item, the minimum 
					multiplicity of the attribute must be constrained to 1 or more
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
abstract type Collection&lt;T&gt; alias COLL&lt;T&gt; specializes ANY {
  BL      isEmpty;
  BL      notEmpty;
  INT     count;
  BL      contains(T item);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="isEmpty" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="The Empty Collection"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>          
						 An indicator that the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> has no elements. The value may be null (when the collection itself is null, whether the collection is empty is not known).
						</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="notEmpty" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Not-Empty"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text> 
							An indicator that the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> contains at least one item. The value may be null (when the collection itself is null, whether the collection is empty is not known).
						</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="count" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Count"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The number of elements in the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>. The value MAY be null (when the collection itself is null, the number of items in the collection is not known).
						</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="contains" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Contains Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>  
							An indicator that the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> contains an item with the given item value using the equals property. The value may be null.
						</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="item" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="BAG" title="Bag" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="COLL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An unordered collection of values, where any value can occur
					more than once.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					A bag MAY contain NULL values as items.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type Bag&lt;T&gt; alias BAG&lt;T&gt; specializes COLL&lt;T&gt; {
              INT     count(T item);
              BAG&lt;T&gt;  plus(BAG&lt;T&gt; x);
              BAG&lt;T&gt;  minus(BAG&lt;T&gt; x);
   literal    ST.SIMPLE;
   promotion  BAG&lt;T&gt;  (T x);
   promotion  BAG&lt;T&gt;  (DSET&lt;T&gt; x);
};</mif:data>
            </mif:otherAnnotation>
            <mif:otherAnnotation type="ITS-Note">
               <mif:text>
                  <mif:p>
						A <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> can be represented in two ways: either as a simple enumeration
						of elements, including repeated elements, or as a "compressed bag"
						whereby the content of the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is listed in pairs of element value and
						count. A histogram showing absolute frequencies is a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> represented
						in compressed form. <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is therefore useful to communicate raw
						statistical data samples.
						</mif:p>
               </mif:text>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="count" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Count"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The number of elements in the bag. NULL elements are counted as
							bag elements.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BAG&lt;T&gt; bag, INT zero)
      where bag.nonNull.and(zero.isZero) {
   bag.isEmpty.equal(bag.count.isZero);
   bag.notEmpty.equal(bag.count.greaterThan(zero));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="COLL"/>
         </mif:derivedFrom>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="count" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Count Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The number of items in this bag with the given item value.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							This is the primitive property of a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>, on which all
							other properties are defined.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BAG&lt;T&gt; bag, T item)
      where bag.nonNull {
   bag.count(item).nonNegative;
   bag.isEmpty.implies(bag.count(item).isZero);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="item" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="contains" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Contains Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							True if the bag contains an item with the given item value.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BAG&lt;T&gt; bag, T item)
      where bag.nonNull {
   bag.contains(item).equal(bag.count(item).isNegative.not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="COLL"/>
         </mif:derivedFrom>
         <mif:parameter name="item" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="isEmpty" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="The Empty Collection"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A predicate indicating that this <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> has no elements (negation of the
							<mif:object name="propertyRef">
                        <mif:param name="propertyName" value="notEmpty"/>
                        <mif:param name="datatypeName" value="BAG"/>
                     </mif:object> predicate. The empty <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is a
							proper value, <mif:b>not</mif:b> an exceptional (NULL) value.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BAG&lt;T&gt; bag)
      where bag.nonNull {
   bag.isEmpty.equal(notEmpty.not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="COLL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="notEmpty" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Not-Empty"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A predicate indicating that this <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> contains at least one item. The item MAY be null.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BAG&lt;T&gt; bag)
      where bag.nonNull {
   bag.notEmpty.equal(exists(T item) {
      bag.contains(item);
      });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="COLL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="plus" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Addition"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> that contains all items of the operand <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BAG&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.plus(y).equal(z).equal(
      forall(T e)
            where e.nonNull {
         z.contains(e).equal(x.contains(e)
                      .or(y.contains(e)));
         });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BAG">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BAG">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="minus" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Subtraction"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> that contains all items of this <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> (minuend) diminished by the
							items in the other <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> (subtrahend). <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s cannot carry deficits: When
							the subtrahend contains more items of one value than the minuend, the
							difference contains zero items of that value.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BAG&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.minus(y).equal(z).equal(
      forall(T e)
            where e.nonNull {
               exists(INT n)
                  where n.equal(x.count(e).minus(y.count(e))) {
         n.nonNegative.equal(z.count(e));
         n.isNegative.equal(z.count(e).isZero);
         };
      });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BAG">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BAG">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="literal" sortKey="08" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							When the element type T has a literal form, the bag of T elements has
							a literal form, wherein the elements of the set are enumerated within
							curly braces and separated by semicolon characters.
						</mif:p>
                     <mif:table width="90%" hl7Id="table-BAG.literal.example">
                        <mif:caption>Example</mif:caption>
                        <mif:thead>
                           <mif:tr>
                              <mif:th>literal</mif:th>
                              <mif:th>meaning</mif:th>
                           </mif:tr>
                        </mif:thead>
                        <mif:tbody>
                           <mif:tr>
                              <mif:td>{1; 3; 3; 5; 7; 19}</mif:td>
                              <mif:td>a bag of integer numbers or real numbers</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>{3; 1; 5; 19; 3, 7}</mif:td>
                              <mif:td>the same bag of integer numbers or real numbers</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>{1.2 m; 2.67 m; 17.8 m}</mif:td>
                              <mif:td>a bag of discrete physical quantities</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>{"apple"; "orange"; "banana"; "strawberry"; "apple"}</mif:td>
                              <mif:td>a bag of character strings (for strings, use quoted form to prevent problems with ";")</mif:td>
                           </mif:tr>
                        </mif:tbody>
                     </mif:table>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="ITS-Note">
                  <mif:text>
                     <mif:p>
								A character-based ITS SHOULD choose a different literal
								form for bags if the Implementation Technology has a more native
								literal form for such collections.
							</mif:p>
                  </mif:text>
               </mif:otherAnnotation>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
BAG&lt;T&gt;.literal ST.SIMPLE {
   BAG&lt;T&gt;          : "{" elements "}"   { $.equal($2); };
   BAG&lt;T&gt; elements : elements ";" T     { $.except($2).equal($1); }
                  | T                   { $.contains($1);
                                          $.except($1).isEmpty; };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="promotion" sortKey="09" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Promotion of Item Values to Bags"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							A data value of type T can be promoted into a trivial <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> of type T
							with that data value as its only item.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(T x) {
   ((BAG&lt;T&gt;)x).count.equal(1);
}

invariant(T x) where x.isNull {
   ((BAG&lt;T&gt;)x).count(x).isNull;
}

invariant(T x) where x.nonNull {
   ((BAG&lt;T&gt;)x).count(x).equal(1);
   
   forall(T y) where y.nonNull {
      ((BAG&lt;T&gt;)x).count(y).isZero.not
                 .implies(x.equal(y)) };
}

invariant(T x) where x.isNull {
   ((BAG&lt;T&gt;)x).count(x).unknown;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BAG">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="promotion" sortKey="10" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Promotion of Sets to Bags"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							A discrete set of items can be promoted into a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> that contains the same items.
							No items are lost during the promotion.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(DSET&lt;T&gt; x) where x.nonNull {
   ((BAG&lt;T&gt;)x).count.equal(x.count);
};

invariant(DSET&lt;T&gt; x, T y) where x.nonNull.and(y.nonNull) {
   ((BAG&lt;T&gt;)x).contains(y).equal(x.contains(y));
};
</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="DSET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BAG">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="11" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							Two bags are equal if and only if they are both empty, or if they both contain the same items.
						</mif:p>
                     <mif:p>
						It is not necessary that the two <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>s have the same type for parameter
						T; as long as the two bags have parameter types that are comparable (for instance,
						<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> and <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CV"/>
                        </mif:object>), the bags can be equal.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BAG&lt;T&gt; x, BAG&lt;U&gt; y)
      where x.nonNull.and(y.nonNull).and(T.datatype.compares(U.datatype)) {
   x.equal(y).equal((forall(T e) {
      x.count(e).equal(y.count(e));
    }).and(forall(U e) {
      x.count(e).equal(y.count(e));
    }));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="LIST" title="Sequence" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="COLL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An ordered collection of discrete (but not necessarily distinct) values.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					A sequence MAY contain NULL values as items.
				</mif:p>
                  <mif:p>
					The sequence is an ordered collection of values, but no particular
					order is associated with the sequence in the definition of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>.
					The meaning of the order of the items SHALL be defined where a 
					<mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is used. Note that in some cases, the order is fixed ( 
					e.g. <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="HIST"/>
                     </mif:object>), but in other cases, the order
					is not fixed: only the meaning associated with the order in the instance
					is defined (e.g. <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="EN"/>
                     </mif:object>, <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="AD"/>
                     </mif:object>).
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type Sequence&lt;T&gt; alias LIST&lt;T&gt; specializes COLL&lt;T&gt; {
             T        head;
             LIST&lt;T&gt;  tail;
             T        item(INT index);
             INT      length;
             LIST&lt;T&gt;  subList(INT start, INT end);
             LIST&lt;T&gt;  subList(INT start);
  literal    ST.SIMPLE;
  promotion  LIST&lt;T&gt;  (T x);
  demotion   BAG&lt;T&gt;;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="head" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Head Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The first item in this sequence.  
						</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="tail" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Tail Sequence"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The sequence following the first item in this sequence. 
						</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="LIST">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="isEmpty" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="The Empty Collection"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A predicate that is <mif:b>true</mif:b> if this sequence contains no items.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							An empty sequence is a proper sequence, not an exceptional (null) value.
						</mif:p>
                     <mif:p>
							In an empty sequence, the length is zero, the tail is empty, and the 
							head is null. Note that both head and tail being NULL does not mean 
							that the sequence is empty; while this is a necessary condition of 
							an empty sequence, it is not sufficient for determining an empty list, since a sequence may
							contain NULL-values as items. Therefore this condition can mean that the sequence
							has only a head item that happens to be NULL.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; x)
      where x.isEmpty {
   x.length.isZero;
   x.head.isNull;
   x.tail.isEmpty;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="COLL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="notEmpty" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Not-Empty"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A predicate that is <mif:b>true</mif:b> if this sequence
							contains at least one element. Negation of <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="isEmpty"/>
                        <mif:param name="datatypeName" value="LIST"/>
                     </mif:object>.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; x)
      where x.nonNull {
   x.notEmpty.equal(x.isEmpty.not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="COLL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="item" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Item by Index"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The item at the given sequential position (index) in the sequence. The
							index zero refers to the first element (head) of the sequence.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; list; INT index)
      where list.nonNull.and(index.nonNegative) {
   list.isEmpty.implies(list.item(index).isNull);
   list.notEmpty.and(index.isZero)
       .implies(list.item(index).equal(list.head));
   list.notEmpty.and(index.nonZero)
       .implies(list.item(index).equal(
          list.tail.item(index.predecessor)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="index" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="contains" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Contains Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A predicate that is <mif:b>true</mif:b> if this sequence contains the
							given item value.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; list; T item)
      where list.nonNull {
   list.isEmpty.implies(list.contains(item).not);
   
   list.nonEmpty.and(item.nonNull).implies(list.contains(item).equal(
        list.head.equal(item).or(list.tail.contains(item))));
		
   list.notEmpty.and(item.isNull).implies(list.contains(item).equal(
        list.head.isNull.or(list.tail.contains(item))));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="COLL"/>
         </mif:derivedFrom>
         <mif:parameter name="item" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="length" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Length"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The number of elements in the sequence. NULL elements are counted as
							sequence elements.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; list)
      where list.nonNull {
   list.isEmpty.equal(list.length.isZero);
   list.notEmpty.equal(list.length.equal(list.tail.length.successor));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="count" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Count"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The number of elements in the list.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							This property is defined for consistency of definitions of collection types. The
							count of the number of elements in a discrete set always matches the length
							of the list.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; list) where list.nonNull {
   list.count.equal(list.length);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="COLL"/>
         </mif:derivedFrom>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="subList" sortKey="09" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="SubList"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A contiguous subset of the list containing the items found in the list from index start to end, inclusively.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							The list starts at item 0. If the bounds are less than 0 or greater than or equal to
							the length of the list, or if end is less than start, then the result of the operation
							is undefined (i.e. null).
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; x, INT start, end)
   where 
     x.nonNull.and(
	 start.greaterOrEqual(0)).and(
	 start.lessThan(x.length)).and(
	 end.greaterOrEqual(0)).and(
	 end.lessThan(x.length)).and(
	 start.lessOrEqual(end)) {
   x.subList(start, end).length.equal(end.minus(start).sucessor);
   forall(INT i) where i.greaterOrEqual(0).and(i.lessThen(end.minus(start))) {
     x.subList(start, end).item(i).equal(x.item(start.plus(i)));
   }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="start" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:parameter name="end" sortKey="2">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="LIST">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="subList" sortKey="10" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="SubList"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A contiguous subset of the list containing the items found in the list from index start to the end of the list, inclusively.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							The list starts at item 0. If the bounds are less than 0 or greater than or equal to
							the length of the list, then the result of the operation is undefined.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; x, INT start)
   where 
     x.nonNull.and(
	 start.greaterOrEqual(0)).and(
	 start.lessThan(x.length)).and(
	 end.greaterOrEqual(0)) {
   x.subList(start).length.equal(x.length.minus(start));
   forall(INT i) where i.greaterOrEqual(0) {
     x.subList(start).item(i).equal(x.item(start.plus(i)));
   }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="start" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="LIST">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="11" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							Two lists are equal if and only if they are both empty, or if both
							their head and their tail are equal.
						</mif:p>
                     <mif:p>
						It is not necessary that the two <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>s have the same type for parameter
						T; as long as the two lists have parameter types that are comparable (for instance,
						<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> and <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CV"/>
                        </mif:object>), the lists can be equal.
					</mif:p>
                     <mif:p>
						Note that when lists contain null items, it is usually not possible to determine whether
						the lists are equal, though it may be possible to determine that they are different. For
						example, a list containing an unknown value is not equal to a list containing another 
						unknown value, nor are two lists holding values of PINF. However a list containing a 
						value of NINF is not equal to a list holding a value of PINF.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; x, LIST&lt;U&gt; y)
      where x.nonNull.and(y.nonNull).and(T.datatype.compares(U.datatype)) {
   x.isEmpty.and(y.isEmpty).implies(x.equal(y));
   
   (x.notEmpty.and(y.isEmpty)).or(x.isEmpty.and(y.notEmpty)).implies(x.equal(y).not);
   
   x.notEmpty.and(y.notEmpty).and(x.head.nonNull).implies(
      x.equal(y).equal(x.head.equal(y.head).and(x.tail.equal(y.tail))));
	  
   x.notEmpty.and(y.notEmpty).and(x.head.isNull).implies(
      x.equal(y).equal(y.head.isNull.and(x.tail.equal(y.tail))));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="literal" sortKey="12" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							When the element type T has a literal form, the sequence <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
							has a literal form. List elements
							are enumerated, separated by semicolon, and enclosed in parentheses.
						</mif:p>
                     <mif:table width="90%" hl7Id="table-LIST.literal.example">
                        <mif:caption>Examples</mif:caption>
                        <mif:thead>
                           <mif:tr>
                              <mif:th>literal</mif:th>
                              <mif:th>meaning</mif:th>
                           </mif:tr>
                        </mif:thead>
                        <mif:tbody>
                           <mif:tr>
                              <mif:td>(1; 3; 5; 7; 19)</mif:td>
                              <mif:td>a sequence of integer numbers or real numbers</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>(3; 1; 5; 19; 7)</mif:td>
                              <mif:td>a different sequence of integer numbers or real numbers</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>(1.2 m; 17.8 m; 2.67 m)</mif:td>
                              <mif:td>a sequence of discrete physical quantities</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>(apple; orange; banana)</mif:td>
                              <mif:td>a sequence of character strings</mif:td>
                           </mif:tr>
                        </mif:tbody>
                     </mif:table>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="ITS-Note">
                  <mif:text>
                     <mif:p>
								a character-based ITS SHOULD choose a different literal
								form for sequences if the Implementation Technology has a more native
								literal form for such collections.
							</mif:p>
                  </mif:text>
               </mif:otherAnnotation>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
LIST&lt;T&gt;.literal ST.SIMPLE {
   LIST&lt;T&gt; : "(" elements ")"        { $.equal($2); }
           | "(" ")"                 { $.isEmpty; };
   LIST&lt;T&gt; elements
           : T ";" elements          { $.head.equal($1);
                                       $.tail.equal($3); }
           | T                       { $.head.equal($1);
                                       $.tail.isEmpty; };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="promotion" sortKey="13" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Promotion of Item Values to Sequences"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							A data value of type T can be promoted into a trivial sequence of T with
							that data value as its only item.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(T x) {
   ((LIST&lt;T&gt;)x).head.equal(x);
   ((LIST&lt;T&gt;)x).tail.isEmpty;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="LIST">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="demotion" sortKey="14" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Demotion of Sequences to Bags"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							A sequence (an ordered collection of items) can be demoted to a bag of items (no order). All items
							are preserved in the demotion.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; x) where x.nonNull {
   ((BAG&lt;T&gt;)x).count.equal(x.count);
};

invariant(LIST&lt;T&gt; x, T y) where x.nonNull.and(y.nonNull) {
   ((BAG&lt;T&gt;)x).contains(y).equal(x.contains(y));
};
</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BAG">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="SET" title="Set" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A value that contains distinct values in no particular order.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					A set SHALL NOT contain items that the comparator does not differentiate. When the default 
					equals based comparator applies, a set SHALL NOT contain NULL values as items.
				</mif:p>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is an abstract type. There are two specializations of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> that are actually used 
					in models and instances, <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="DSET"/>
                     </mif:object> (Discrete Sets) and 
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object> (Quantity Sets). <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="DSET"/>
                     </mif:object>
					is for collection based sets that are composed of a series of discrete elements, and corresponds
					to general computationally friendly list found in most implementation environments. <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object>
					is for quantity based sets where it makes sense to build complex sets using expressions and ranges of values. <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object>s
					correspond to the mathematical notion of a set. Both types of sets support the common operations defined
					in <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> that relate to the notion of set membership and related operations. <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="DSET"/>
                     </mif:object>
					extends this notion to include some collection specific operations. <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object> extends the
					notion to support a number of different methods for specifying set ranges and building complex sets
					based on set operations which are not possible for non-quantity based sets.
				</mif:p>
                  <mif:p>
					There are some complex relationships between <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="DSET"/>
                     </mif:object> and <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object>. For example, 
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object>&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="INT"/>
                     </mif:object>&gt;
					is a type that conforms to the semantics expressed in both a <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="DSET"/>
                     </mif:object> and a <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object>, though for
					purposes of definition, this specification defines an <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object> as a specialization of <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object>
					and not <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="DSET"/>
                     </mif:object>, since all types of <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object>s are also <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object>s. 
					The situation for <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object> is a little more complicated. <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object>&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object>&gt;
					is not a <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="DSET"/>
                     </mif:object>&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object>&gt;, but a <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="DSET"/>
                     </mif:object>&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object>&gt; may make sense in 
					some circumstances, and if a <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="DSET"/>
                     </mif:object>&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object>&gt; is defined, it also conforms to
					the semantics expressed in <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object>&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object>&gt;. 
					A <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="DSET"/>
                     </mif:object>&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PQ"/>
                     </mif:object>&gt; may also be a <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object>&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PQ"/>
                     </mif:object>&gt; but
					only if all the values are comparable (this relationship is true for all
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="DSET"/>
                     </mif:object>&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QTY"/>
                     </mif:object>&gt;). 
				</mif:p>
                  <mif:p>	
					Generally, if T is a specialization of <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QTY"/>
                     </mif:object>, then a <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object>
					would be the appropriate type of <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="SET"/>
                     </mif:object> to specify in a model or use in an instance. 
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T, COMP C = CEQ&gt;
abstract type Set&lt;T, C&lt;T&gt;&gt; alias SET&lt;T, C&lt;T&gt;&gt; specializes ANY {
   C&lt;T&gt;    comparator;
   BL      contains(T element);
   BL      contains(SET&lt;T&gt; subset);
   BL      isEmpty;
   BL      notEmpty;
   INT     cardinality;
   SET&lt;T&gt;  union(SET&lt;T&gt; otherset);
   SET&lt;T&gt;  union(T element);
   SET&lt;T&gt;  except(SET&lt;T&gt; otherset);
   SET&lt;T&gt;  except(T element);
   SET&lt;T&gt;  intersection(SET&lt;T&gt; otherset);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:parameter name="C" sortKey="2">
         <mif:type name="COMP"/>
         <mif:defaultValue name="CEQ"/>
      </mif:parameter>
      <mif:property name="comparator" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Comparator"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The comparator used to define uniqueness and membership in the set.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The uniqueness in the set is a function of the comparator.
					</mif:p>
                     <mif:p>
						Because of these constraints, considerable care must be taken in 
						defining the comparator. In particular, the equals-based comparator 
						SHALL always be used for types that are specializations of <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="QTY"/>
                        </mif:object>. 
						Note also that where a comparator could be defined that specifies
						nonNull outcomes for null values of T, sets MAY contain null values.
					</mif:p>
                     <mif:p>
						Implementable Static Models SHALL always fix the comparator - it must not be left to be decided at run-time.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; x)
      where x.nonNull {
 forall(T a) where a.nonNull {
   forall(T b) where b.nonNull {
     /* if the comparator cannot compare a or b,
	    both cannot be in the Set */ 
	 x.contains(a).and(x.contains(b)).implies.
	    x.comparator.compare(a, b).nonNull;  
	   
     /* if both a and b are in the set, they must be different 
       (unless they are the are the same instance)*/ 
	 x.contains(a).and(x.contains(b)).implies(
	   a.identical(b).or(x.comparator.compare(a, b).not));
	 }
   }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="C">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="contains" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Contains Element"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A relation of the set with a value, true if the given value is an
							element of the set.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							This is the primitive semantic property of a set, based on which all
							other properties are defined. Contains is ascertained using the comparator
							for the SET, which MAY specify some different comparison than the equals property.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text>
								A set SHALL only contain distinct elements.
								Values for which the comparator is unable to differentiate cannot be
								elements of a set. For normal sets, based on <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="CEQ"/>
                     </mif:object>,
								exceptional values (NULL-values) cannot be elements of a set.
							</mif:text>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage"/>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="element" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="contains" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Contains Subset"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The relation between a set and its subsets, where each element in the
							subset is also an element of the superset.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							This implies that the empty set is a subset of every set including
							itself.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; superset, subset) 
      where superset.nonNull.and(subset.nonNull) {
         superset.contains(subset).equal(
      forall(T element) where subset.contains(element) {
         superset.contains(element);      
	     });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="subset" sortKey="1">
            <mif:type name="SET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="isEmpty" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="The Empty Set"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A predicate indicating that this set has no elements; the negation of
							<mif:object name="propertyRef">
                        <mif:param name="propertyName" value="notEmpty"/>
                        <mif:param name="datatypeName" value="SET"/>
                     </mif:object>. The
							empty set is a proper set value, <mif:b>not</mif:b> an exceptional
							(NULL) value.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; set)
      where set.nonNull {
   set.isEmpty.equal(notEmpty.not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="notEmpty" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Not-Empty"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A predicate indicating that this set contains elements.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; set)
      where set.nonNull {
   set.notEmpty.equal(exists(T element) {
      set.contains(element);
      });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="cardinality" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Cardinality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The number of distinct elements in the set.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							The cardinality definition works for finite sets in this specification, but is not sufficient since it doesn't converge
							for uncountably infinite sets (<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object>, <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object>, 
							etc.) and it doesn't terminate for infinite sets. The cardinality value is an example where it would
							be necessary to distinguish the cardinality âµ<mif:sub>0</mif:sub> 
							(<mif:b>aleph</mif:b>
                        <mif:sub>0</mif:sub>) of countably infinite sets
							(e.g., <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="INT"/>
                        </mif:object>) from âµ<mif:sub>1</mif:sub>
							(<mif:b>aleph</mif:b>
                        <mif:sub>1</mif:sub>), the cardinality of uncountable sets 
							(e.g., <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object>, <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object>).
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; set)
      where set.nonNull {
   exists(T element) where set.contains(element) {
      set.cardinality.equal(set.except(element)
                     .cardinality.successor);
         };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="union" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Union"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							 A set for which each element is an element of at least one component set.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   x.union(y).equal(z).equal(forall(T e) {
      z.contains(e).equal(x.contains(e).or(y.contains(e)));
      });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="otherset" sortKey="1">
            <mif:type name="SET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="union" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Include Element"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A union of a set and an element.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; set, singletonset; T element)
      where set.nonNull.and(element.nonNull)
               .and(singletonset.cardinality.isOne)
               .and(singletonset.contains(element)) {
   set.union(element).equal(set.union(singleton));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="element" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="except" sortKey="09" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Set Difference"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							 The set containing all elements of the subtracted set that are not elements of the subtracting set.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   x.except(y).equal(z).equal(forall(T e) {
      z.contains(e).equal(x.contains(e).and(y.contains(e).not));
      });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="otherset" sortKey="1">
            <mif:type name="SET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="except" sortKey="10" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Exclude Element"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The set that contains all elements of this set except for the subtracting element value. 
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; x, z; T d)
      where x.nonNull.and(z.nonNull).and(d.nonNull) {
   x.except(d).equal(z).equal(forall(T e) {
      z.contains(e).equal(x.contains(e).and(d.equal(e).not));
      });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="element" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="intersection" sortKey="11" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Intersection"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							 The set containing all and only those elements that are contained in both of the operand sets.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   x.intersection(y).equal(z).equal(forall(T e) {
      z.contains(e).equal(x.contains(e).and(y.contains(e)));
      });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="otherset" sortKey="1">
            <mif:type name="SET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="12" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two nonNull <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>s are equal if they have the same elements.
						It is not necessary that the two <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>s have the same type for parameter
						T; as long as the two sets have parameter types that are comparable (for instance,
						<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> and <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CV"/>
                        </mif:object>), the sets can be equal.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; x, SET&lt;U&gt; y)
      where x.nonNull.and(y.nonNull).and(T.datatype.compares(U.datatype)) {
   x.equal(y).equal((forall(T e) {
      x.contains(e).equal(y.contains(e));
    }).and(forall(U e) {
      x.contains(e).equal(y.contains(e));
    }));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="SET"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="COMP" title="Comparator" isAbstract="true" datatypeKind="Definition"
                 visibility="protected">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An abstract type that defines a comparison between two values of the same type.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					Although every type has a clear definition of the meaning of semantic equality, this
					definition does not always fit a particular use: in these cases, a specialization of
					<mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> that expresses the criteria for the comparison relationship may be used.
					The comparator type is defined to allow custom definitions of the meaning of equality
					between types. This is most useful in defining the criteria for uniqueness in a
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="SET"/>
                     </mif:object> but may find other applications in implementation environments.
				</mif:p>
                  <mif:p>
				  COMP is an abstract type, and no actual comparator is defined.
				</mif:p>
                  <mif:p>
					Because <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> never appears in the instance, new specializations of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>
					MAY be defined outside of this specification. All new specializations SHALL
					be approved at harmonisation prior to being included in a normative specification.
				</mif:p>
                  <mif:p>
					An example of a custom comparator might be to specify that a particular <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="SET"/>
                     </mif:object>
					of <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TEL"/>
                     </mif:object> is allowed to contain the same telecommunication address more than once if
					it has different useablePeriod properties. In this case, compare should return false if only
					one of the two <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TEL"/>
                     </mif:object>s has a useablePeriod, or if they both do and they are
					different. Here is how to define such a comparator:
				</mif:p>
                  <mif:p>
					A set that used this comparator would be defined as 
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="DSET"/>
                     </mif:object>&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TEL"/>
                     </mif:object>, MYTELCOMP&gt;.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
abstract protected type Comparator&lt;T&gt; alias COMP&lt;T&gt; {
   TYPE  dataType;
    BL      compare(T element1, T element2);
};</mif:data>
            </mif:otherAnnotation>
            <mif:otherAnnotation type="ITS-Note">
               <mif:text>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> and its descendants never appear in an instance, and an ITS should not
						create a representation for them.
					</mif:p>
               </mif:text>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
type MyTelephoneComparator alias MYTELCOMP specializes COMP&lt;TEL&gt;{
    BL      compare(T element1, T element2);
};

invariant(MYTELCOMP c, TEL x, y)
      where x.equal(y).nonNull {
   c.compare(x, y).equal(
     x.equal(y)
      .and(x.useablePeriod.isNull.xor(y.useablePeriod.isNull)).not
	  .or(x.useablePeriod.nonNull.implies(
	     x.useablePeriod.equals(y.useablePeriod))));
};
</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="dataType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Data Type"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The data type of the comparator. 
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Every comparator implicitly carries
						information about its own data type.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(COMP x) {
   x.dataType.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="compare" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Comparison"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The result of comparing the two elements.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Like the equality relationship, comparison is a reflexive, symmetric, and transitive
						relationship between any two data values.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(COMP&lt;T&gt; c, T x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   c.compare(x, x);                                                 /* reflexivity */
   c.compare(x, y).equal(c.compare(y, x));                          /* symmetry */
   c.compare(x, y).and(c.compare(y, z)).implies(c.compare(x, z));   /* transitivity */
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="element1" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:parameter name="element2" sortKey="2">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CEQ" title="EqualComparator" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="COMP"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A comparator based on the equality relationship defined for all types.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					This is the default concrete comparator that compares the two values based on the 
					equality relationship defined for all types.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type EqualComparator&lt;T&gt; alias CEQ&lt;T&gt; specializes COMP&lt;T&gt; {
    BL      compare(T element1, T element2);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="compare" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Comparison"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The value of the equality relationship between the two values.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CEQ&lt;T&gt; c, T x, y)
      where x.equal(y).nonNull {
   c.compare(x, y).equal(x.equal(y));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="element1" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:parameter name="element2" sortKey="2">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="DSET" title="DiscreteSet" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SET"/>
      </mif:derivedFrom>
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="COLL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An unordered collection of values that contains discrete distinct values.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					A <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> differs from the general <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="SET"/>
                     </mif:object> because it is constrained to
					contain only discrete items. The practical consequence of this is that a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> can
					be iterated, like bag, but unlike <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object>.  
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T, COMP C = CEQ&gt;
type DiscreteSet&lt;T, C&lt;T&gt;&gt; alias DSET&lt;T, C&lt;T&gt;&gt; specializes SET&lt;T, C&lt;T&gt;&gt;, COLL&lt;T&gt; {
   literal    ST.SIMPLE;
   promotion  DSET&lt;T&gt;  (T x);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:parameter name="C" sortKey="2">
         <mif:type name="COMP"/>
      </mif:parameter>
      <mif:property name="count" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Count"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The number of elements in the set.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							This property is defined for consistency of definitions of collection types. The
							count of the number of elements in a discrete set always matches the cardinality
							of the set.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(DSET&lt;T&gt; set) where set.nonNull {
   set.count.equal(set.cardinality);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="COLL"/>
         </mif:derivedFrom>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="literal" sortKey="02" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							When the element type T has a literal form, the discrete set of T elements has
							a literal form, wherein the elements of the set are enumerated within
							curly braces and separated by semicolon characters.
						</mif:p>
                     <mif:table width="90%" hl7Id="table-SET.literal.example">
                        <mif:caption>Example</mif:caption>
                        <mif:thead>
                           <mif:tr>
                              <mif:th>literal</mif:th>
                              <mif:th>meaning</mif:th>
                           </mif:tr>
                        </mif:thead>
                        <mif:tbody>
                           <mif:tr>
                              <mif:td>{1; 3; 5; 7; 19}</mif:td>
                              <mif:td>a set of integer numbers or real numbers</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>{3; 1; 5; 19; 7}</mif:td>
                              <mif:td>the same set of integer numbers or real numbers</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>{1.2 m; 2.67 m; 17.8 m}</mif:td>
                              <mif:td>a set of discrete physical quantities</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>{apple; orange; banana}</mif:td>
                              <mif:td>a set of character strings</mif:td>
                           </mif:tr>
                        </mif:tbody>
                     </mif:table>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="ITS-Note">
                  <mif:text>
                     <mif:p>
								A character-based ITS SHOULD choose a different literal
								form for discrete sets if the Implementation Technology has a more native
								literal form for such collections.
							</mif:p>
                  </mif:text>
               </mif:otherAnnotation>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
DSET&lt;T&gt;.literal ST.SIMPLE {
   DSET&lt;T&gt;          : "{" elements "}"   { $.equal($2); };
   DSET&lt;T&gt; elements : elements ";" T     { $.except($2).equal($1); }
                  | T                   { $.contains($1);
                                          $.except($1).isEmpty; };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="promotion" sortKey="03" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Promotion of Element Values to Sets"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							A data value of type T can be promoted into a trivial discrete set of T with
							that data value as its only element.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(T x) where x.nonNull {
   ((DSET&lt;T&gt;)x).contains(x);
   ((DSET&lt;T&gt;)x).except(x).isEmpty;
};

invariant(T x) where x.isNull {
   ((DSET&lt;T&gt;)x).isNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="DSET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is taken from
						the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="SET"/>
                        </mif:object> data type: Two nonNull <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="SET"/>
                        </mif:object>s are
						equal if they have the same elements.
					</mif:p>
                     <mif:p>
								This means that values of the type <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> and any other kind of SET MAY be equal.
							</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="SET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="HXIT" title="HistoryItem" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="T" qualifier="parameter"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A generic data type extension that adds a time range and/or link to the ControlAct 
					associated with the creation of the data on any data value whatever its data type. 
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
                     <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="HXIT"/>
                     </mif:object> adds the controlActIdRef property to the the base type T.
					In addition, if the base type T does not possess a validTime property, the
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="HXIT"/>
                     </mif:object> adds that property to the base type. If, however,
					the base type T does have a valid time property (currently only <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="EN"/>
                     </mif:object>),
					that property is mapped to the valid time property of the
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="HXIT"/>
                     </mif:object> and the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> constraints on validTime apply.<mif:object name="footnote">.
							Note that data types are specifications of abstract properties of
							values. This specification does not mandate how these values are
							represented in an ITS or implemented in an application. Specifically,
							it does not mandate how the represented components are named or
							positioned. In addition, the semantic generalization hierarchy may be
							different from a class hierarchy chosen for implementation (if the
							implementation technology has inheritance).  Keep the distinction
							between a type (interface) and an implementation (concrete data
							structure, class) in mind. The ITS SHALL contain a mapping of ITS
							defined features of any data type to the semantic properties defined
							here.
						</mif:object>
                  </mif:p>
                  <mif:p>
					The time range is the time in which the information	represented by the value is (or was) valid.
					The ControlAct id reference indicates the event responsible for the value of the data type.
					The time range is not the time during which any particular system considered this 
					information valid (as in, an audit trail), though the link to the control act may
					provide some information of relevance in this regard.				  
				  </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type HistoryItem&lt;T&gt; alias HXIT&lt;T&gt; specializes T {
   IVL&lt;TS&gt; validTime;
   BL comesBefore(HXIT&lt;T&gt;);
   II controlActIdRef;  
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="validTime" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Valid Time"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The time interval during which the given information was, is, or is
						expected to be valid. The interval can be closed-- i.e. finite and
						definedâor openâi.e. infinite or undefined âon either side. The interval
						cannot be just a width, nor can the width be zero
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(HXIT&lt;T&gt; x) where x.nonNull {
  x.validTime.nonNull.implies(x.validTime.low.nonNull.or(x.validTime.high.nonNull));
  x.validTime.nonNull.implies(x.validTime.width.isZero.not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="IVL">
            <mif:argumentDatatype name="TS"/>
         </mif:type>
      </mif:property>
      <mif:property name="comesBefore" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Comes Before"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A predicate expressing a chronological order relation that is asymmetric and
						transitive, between this <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> and another <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>. 
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						A <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> comes before another in a sequence of history items (<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="HIST"/>
                        </mif:object>) if 
						the high boundary of the validTime is less or equal to the low boundary of the other interval.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(HXIT&lt;T&gt; x, y) where x.validTime.nonNull.and(y.validTime.nonNull) {
  x.comesBefore(y).implies(x.validTime.high.nonNull);
  x.comesBefore(y).implies(y.validTime.low.nonNull);
  x.comesBefore(y).implies(x.validTime.high.lessOrEqual(y.validTime.low));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="controlActIdRef" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="ControlAct Id Reference"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
					The identifier of the ControlAct associated with setting the data type to its specified value. 
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
					By referencing
					a particular ControlAct, the property links to all of the information surrounding that ControlAct, such as who
					made the change, when it was made, why it was made, what system originated the change, etc.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="II"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="HIST" title="History" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="HXIT">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:argumentDatatype>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A list of data values that have a valid-time property.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					The intent of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is to capture the true historical
					(and future) values of an item, rather than the audit trail of
					values any given system has held for the item.
					The history information is not limited to the past; expected future
					values MAY also appear.
				</mif:p>
                  <mif:p>
					All items in the list SHALL have a non-null validTime property. 
					The validTime periods on the list SHALL NOT overlap.
					The contents of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> SHALL be ordered in ascending chronological order.
				</mif:p>
                  <mif:p>
						If a list of historical items should allow multiple items and/or overlapping
						ranges, then the type of the attribute should be <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="BAG"/>
                     </mif:object>&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="HXIT"/>
                     </mif:object>&lt;T&gt;&gt;.
						The type <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="HIST"/>
                     </mif:object>&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="SET"/>
                     </mif:object>&lt;T&gt;&gt; actually denotes a history of the set
						values themselves. The semantics of <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="SET"/>
                     </mif:object>&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="HXIT"/>
                     </mif:object>&lt;T&gt;&gt; become
						very complicated; given that validTime is usually excluded from the equality test, this type should not be used. 
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type History&lt;T&gt; alias HIST&lt;T&gt; specializes LIST&lt;HXIT&lt;T&gt;&gt; {
            HXIT&lt;T&gt;  current;
            HXIT&lt;T&gt;  earliest;
            HIST&lt;T&gt;  exceptEarliest;
            HXIT&lt;T&gt;  latest;
            HIST&lt;T&gt;  exceptLatest;
  demotion  HXIT&lt;T&gt;;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(HIST x; HXIT&lt;T&gt; e)
      where x.nonNull {
  x.contains(e).implies(e.validTime.nonNull);

  forall(INT.POSITIVE i) where i.lessThan(x.length) {
      x.item(i.predecessor).comesBefore(x.item(i));
  };
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="current" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Current Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The item in the list whose validTime interval includes the current time.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							Note that the current time is not necessarily the same time as the instant
							at which an instance is being processed. The relevant current time will be 
							dictated by the context of operation.
						</mif:p>
                     <mif:p>
							There may be no current value, in which case the value of this operation is NULL.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="HXIT">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="earliest" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Earliest Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The item in the list whose <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="LOW"/>
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object> boundary
							(validity start	time) is less than (i.e. before) or equal to
							that of any other history item in the list.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(HIST x; HXIT&lt;T&gt; e)
      where x.contains(e) {
   x.earliest.validTime.low.lessOrEqual(e.validTime.low);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="HXIT">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="exceptEarliest" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Except Earliest Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The derived history that has the earliest item excluded.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(HIST x)
      where x.nonNull {
   x.exceptEarliest.equal(x.except(x.earliest));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="HIST">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="latest" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Latest Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The item in the list whose <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="HIGH"/>
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object> boundary (validity end
							time) is greater than (i.e. after) or equal to that of any other history item
							in the list.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(HIST x; HXIT&lt;T&gt; e)
      where x.contains(e) {
   x.latest.validTime.high.greaterOrEqual(e.validTime.high);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="HXIT">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="exceptLatest" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Except Latest Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The derived history that has the latest item excluded.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(HIST x)
      where x.nonNull {
   x.exceptLatest.equal(x.except(x.latest));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="HIST">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="demotion" sortKey="06" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Demotion of a History to a Single History Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							A type conversion between an entire history <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="HIST"/>
                        </mif:object>
							and a single history item <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="HXIT"/>
                        </mif:object>. This conversion
							takes the current data from the history, if a current value exists.
						</mif:p>
                     <mif:p>
							The purpose of this conversion is to allow an information producer to
							produce a history of any value instead of sending just one value.<mif:object name="footnote">
									Note, from the definition of , that
									 semantically specializes T. This means, that the
									information-consumer expecting a T but given an 
									need not recognize any difference (substitutability of
									specializations).
								</mif:object>
							An information-consumer, who does not expect a history but a simple
							value, will convert the history to the current value. Note that the
							source system may only send a history of a value if the constraining
							models permits this.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(HIST x)
      where x.nonNull {
   x.notEmpty;
   ((T)x).equal(x.current);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="HXIT">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="LIST"/>
                        </mif:object> data type. 
								This means that values of the type HIST and LIST may be equal.
							</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="BIN" title="BinaryData" datatypeKind="Definition" visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="BN"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A raw block of bits. 
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is a protected type that SHALL NOT be assigned to any property outside the data type specification.
				</mif:p>
                  <mif:p>
					A bit is semantically identical with a non-null <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="BL"/>
                     </mif:object> value. Thus,
					all binary data is â semantically â a sequence of non-null
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="BL"/>
                     </mif:object> values.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type BinaryData alias BIN specializes LIST&lt;BN&gt;;</mif:data>
            </mif:otherAnnotation>
            <mif:otherAnnotation type="ITS-Note">
               <mif:text>
                  <mif:p>
						The representation of arbitrary binary data is the responsibility of
						an ITS. How the ITS accomplishes this depends on the underlying
						Implementation Technology (whether it is character-based or binary)
						and on the represented data. Character data MAY be
						represented as binary data; however, a character-based ITS SHOULD NOT
						convert character data into arbitrary binary data and then represent
						binary data in a character encoding.  E.g., the letter "J" might be 
						encoded as ASCII "74" (or hexadecimal "4A"): these character 
						representations of numerical data should not be represented in 
						lieu of the original "J."
					</mif:p>
               </mif:text>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text>
						An empty sequence is not considered binary data but counts as a
						NULL-value. In other words, non-NULL binary data contains at least one
						bit. All bits in a non-NULL binary data value SHALL NOT be NULL.
					</mif:text>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BIN x)
      where x.nonNull {
   x.notEmpty;
   x.length.greaterThan(0);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="equal" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="LIST"/>
                        </mif:object> data type.
					</mif:p>
                     <mif:p>
								This means that values of the type BIN and LIST&lt;BL&gt; may be equal.
							</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ED" title="EncapsulatedData" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					Data that is primarily intended for human interpretation or for
					further machine processing outside the scope of HL7. 
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					This includes unformatted or formatted written language, multimedia data, or
					structured information as defined by a different standard (e.g.,
					XML-signatures).  Instead of the data, an <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>
					may contain only a reference (see <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TEL"/>
                     </mif:object>). Note that
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ST"/>
                     </mif:object> is a specialization of 
					<mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> where the <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="mediaType"/>
                        <mif:param name="datatypeName" value="ED"/>
                     </mif:object> is fixed to text/plain 
					and several other properties are constrained to null.
				</mif:p>
                  <mif:p>   
					Encapsulated data can be present in two forms, inline or by
					reference. Inline data is communicated or moved as part of the
					encapsulated data value, whereas by-reference data may reside at a
					different (remote) location. The data is the same whether it is
					located inline or remote.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type EncapsulatedData alias ED specializes ANY {
   BIN     data;
   CS      mediaType;
   CS      charset;
   CS      language;
   CS      compression;
   TEL.URL reference;
   BIN     integrityCheck;
   CS      integrityCheckAlgorithm;
   ST      description;
   ED      thumbnail;
   DSET&lt;ED&gt; translation;

   INT     length;
   ED      subPart(INT start, INT end);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="data" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Binary Data"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The binary content of the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>
                  </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> acts as a wrapper of binary content. Operations performed against the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
						directly are mediated by the mediatype and, if so indicated by the mediatype, the
						character set. For example, two <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="BIN"/>
                        </mif:object> values are equal if they have
						the same sequence of bits in their content. However the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> are only equal if
						they have the same sequence of logical items. For instance, if the media type is a kind of
						text, then the sequence of characters indicated by the character set and the binary
						content must be equal. Similarly, the length of an ED is the number of component
						parts as indicated by the mediatype. For application and image media types, the
						length of <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as the length of the <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object>. Note that operations may also be performed directly upon
						the binary content by using <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object>. 
					</mif:p>
                     <mif:p>
						Although data SHALL be nonNull if the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is not null, it need not be 
						contained in-line in the instance; instead, the binary content, along with some 
						other properties, MAY be defined by the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="reference"/>
                           <mif:param name="datatypeName" value="ED"/>
                        </mif:object>
						property. 
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ED x)
      where x.nonNull {
   x.data.nonNull;			
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BIN"/>
      </mif:property>
      <mif:property name="mediaType" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="text/plain"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Media Type"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						 The type of the encapsulated data. 
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The default mediaType is text/plain.
						The type of the encapsulated data may help identify a
						method to interpret or render the data. 
					</mif:p>
                     <mif:p>
						The IANA defined domain of media types is established by the Internet
						standard RFC 2045 [<mif:a href="http://www.ietf.org/rfc/rfc2045.txt"/>]
						and 2046 [<mif:a href="http://www.ietf.org/rfc/rfc2046.txt"/>].
						RFC 2046 defines the media type to consist of two parts:
					</mif:p>
                     <mif:ol>
                        <mif:li/>
                        <mif:li/>
                     </mif:ol>
                     <mif:p>
						However, this specification treats the entire media type as one atomic
						code symbol in the form defined by IANA, i.e., top level type followed
						by a slash "/" followed by media subtype. Currently defined media
						types are registered in a database
						[<mif:a href="http://www.iana.org/assignments/media-types/index.html"/>]
						maintained by IANA. Currently several hundred different MIME media types are
						defined, with the list growing rapidly. In general, all those types
						defined by the IANA MAY be used.
					</mif:p>
                     <mif:p>
						To promote interoperability, this specification prefers certain media
						types to others. This is to define a greatest common denominator on
						which interoperability is not only possible, but that is powerful
						enough to support even advanced multimedia communication needs.
					</mif:p>
                     <mif:p>
                        <mif:object name="conceptDomainRef">
                           <mif:param name="domain" value="mediaType"/>
                        </mif:object> below assigns a status to
						certain MIME media types, where the status means one of the following:
					</mif:p>
                     <mif:ul>
                        <mif:li>
                           <mif:strong>required</mif:strong>
                        </mif:li>
                        <mif:li>
                           <mif:strong>recommended</mif:strong>
                        </mif:li>
                        <mif:li>
                           <mif:strong>indifferent</mif:strong>
                           <mif:object name="conceptDomainRef">
                              <mif:param name="domain" value="mediaType"/>
                           </mif:object>
                        </mif:li>
                        <mif:li>
                           <mif:strong>deprecated</mif:strong>
                        </mif:li>
                     </mif:ul>
                     <mif:p>
						The set of required media types is very small so that no undue
						requirements are forced on HL7 applications, especially legacy
						systems. In general, no HL7 application is forced to support any given
						kind of media other than written text. For example, many systems just
						do not want to receive audio data, because those systems can only show
						written text to their users. It is a matter of application conformance
						statements to say: "I will not handle audio". Only if a system claims
						to handle audio media, then it must support the required media type for
						audio.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text>
                     <mif:object name="itemName">
                        <mif:param name="item" value="property"/>
                     </mif:object> is a mandatory property, i.e., every non-NULL instance of
							<mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> SHALL have a non-NULL <mif:object name="itemName">
                        <mif:param name="item" value="property"/>
                     </mif:object> property.
						</mif:text>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage"/>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="MediaType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="charset" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Charset"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						An Internet Assigned Numbers Authority (IANA) Charset Registered character set 
						and character encoding for character-based media types.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The charset SHALL be
						identified by an Internet Assigned Numbers Authority (IANA) 
						Charset Registration [<mif:a href="http://www.iana.org/assignments/character-sets"/>] 
						in accordance with RFC 2978 [<mif:a href="http://www.ietf.org/rfc/rfc2978.txt"/>].
						The IANA source specifies names and multiple aliases for most character
						sets. For HL7's purposes, use of multiple alias names is not
						allowed. The standard name for HL7 is the one marked by IANA as
						"preferred for MIME."  If IANA has not marked one of the aliases as
						"preferred for MIME" the main name SHALL be the one used for HL7.
					</mif:p>
                     <mif:p>
                        <mif:object name="conceptDomainRef">
                           <mif:param name="domain" value="Charset"/>
                        </mif:object> lists a few of the IANA defined
						character sets that are of interest to current HL7 members.

					</mif:p>
                     <mif:p>
						The charset property needs to be known where the data of <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is character type
						data in any form. If the data is provided in-line, then the charset SHALL be 
						clearly conveyed. If the data is provided as a reference, and the access method does not provide
						the charset for the data, typically as a mime header, then the charset SHALL be 
						conveyed as part of the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>. 
					</mif:p>
                     <mif:p>
						Interested readers may also want to consult the "Character Model for
						the World Wide Web" [<mif:a href="http://www.w3.org/TR/charmod"/>] for a more complete
						discussion of character set and related issues.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="Charset"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="language" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Language"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						  The human language of the content.
					</mif:text>
               </mif:definition>
               <mif:rationale>
                  <mif:text>
						The need for a language code for text data values is documented in RFC
						2277, IETF Policy on Character Sets and Languages
						[<mif:a href="http://www.ietf.org/rfc/rfc2277.txt"/>]. Further background
						information can be found in Using International Characters in Internet
						Mail [<mif:a href="http://www.imc.org/mail-i18n.html"/>], a memo by the
						Internet Mail Consortium.
					</mif:text>
               </mif:rationale>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The principles of the code domain of this attribute are specified by
						the Internet standard RFC 3066 [<mif:a href="http://www.ietf.org/rfc/rfc3066.txt"/>].
						The RFC 3066 coding scheme is principally constructed from a primary subtag component 
						encoded using the language codes of ISO 639, with an optional second subtag component
						encoded using the two letter country codes of ISO 3166. Where this scheme does not 
						provide a suitable code, RFC 3066 allows for other codes, mostly as defined by ISO or 
						the Internet Assigned Names Authority [<mif:a href="http://www.iana.org/assignments/language-tags"/>].<mif:object name="footnote">
								RFC 3066 [] is
								the HL7-approved coding system for all reference to human languages,
								in data types and elsewhere.
							</mif:object>
						This code domain is assigned the OID 2.16.840.1.113883.6.121.
					</mif:p>
                     <mif:p>
						While Language tags usually alter the meaning of the text, the language does
						not alter the meaning of the characters in the text.<mif:object name="footnote">
								For this reason, a system or site that does not deal with multilingual
								text or names in the real world MAY safely ignore the language
								property.
							</mif:object>
                     </mif:p>
                     <mif:p>
						The language tag SHOULD NOT be mandatory if it is not mandatory in the
						implementation technology. Semantically, language tagging of strings
						follows a default-logic. In circumstances where a realm may support
						multiple langauges, it is up to the realm to define rules to handle
						language where none is specified when no language is specified. If no
						other rule is specified, the local language of the reader is assumed.
						If a language is set for an entire message or document, that language
						is the default. If any information element or value that is superior in
						the syntax hierarchy specifies a language, that language is the default
						for all subordinate text values.
					</mif:p>
                     <mif:p>
						If language tags are present in the beginning of the encoded binary
						text (e.g., through Unicode's plane-14 tags) this is the source of the
						language property of the encapsulated data value.
					</mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="ITS-Note">
                  <mif:text>
                     <mif:p>
							Representation of language tags to text is highly dependent on the
							ITS. An ITS MAY use the native way of language tagging provided by
							its target implementation technology. Some may have language
							information in a separate component, e.g., XML has the xml:lang tag
							for strings. Others may rely on language tags as part of the binary
							character string representation, e.g., ISO 10646 (Unicode) and its
							"plane-14" language tags.
						</mif:p>
                  </mif:text>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="HumanLanguage"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="compression" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Compression"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						 The compression algorithm, if any, used on the raw byte data.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:ul>
                        <mif:li>
                           <mif:strong>required</mif:strong>
                        </mif:li>
                        <mif:li>
                           <mif:strong>indifferent</mif:strong>
                        </mif:li>
                        <mif:li>
                           <mif:strong>deprecated</mif:strong>
                        </mif:li>
                     </mif:ul>
                     <mif:p>
						The compression applies to the data applied in line, not to data provided by reference,
						even if there is no data provided in line. 
						Note that some compression formats allow multiple archive files to be embedded within
						a single compressed volume. Applications SHALL ensure that the decompressed form of
						the data conforms to the stated media type. The stated media type applies to the uncompressed data.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CompressionAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="reference" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Reference"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A URL the target of which is taken as the binary content of the ED.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						A telecommunication address (<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TEL"/>
                        </mif:object>) is a URL (i.e. for HTTP or FTP)
						which will resolve to precisely the same binary data that could as
						well have been provided as inline data.
						The semantic value of an encapsulated data value is the same,
						regardless whether the data is present inline data or just
						by-reference. However, an encapsulated data value without inline data
						behaves differently, since any attempt to examine the data requires
						the data to be downloaded from the reference. An encapsulated data
						value MAY have both inline data and a reference.
					</mif:p>
                     <mif:p>
						If both reference and inline data are provided, the reference SHALL 
						point to data identical to that provided inline. It is an error if 
						the data resolved through the reference does not match either the 
						integrity check or the in-line data.
					</mif:p>
                     <mif:p>
						The reference may contain a usablePeriod to indicate that the
						data may only be available for a limited period of time. Whether
						the reference is limited by a usablePeriod or not, the content of
						the reference SHALL be fixed for all time. Any application using the
						reference SHALL always receive the same data, or an error. The reference cannot
						be reused to send a different version of the same data, or different
						data.
					</mif:p>
                     <mif:p>
						By-reference encapsulated data may not be allowed depending on the
						attribute or component that is declared encapsulated data.
						Values of type <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ST"/>
                        </mif:object> SHALL always be inline.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="TEL.URL"/>
      </mif:property>
      <mif:property name="integrityCheck" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Integrity Check"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A checksum calculated over the binary data. 
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The integrity check is a short binary value representing a
						cryptographically strong checksum that is calculated over the binary
						data. The purpose of this property, when communicated with a reference
						is for anyone to validate later whether the reference still resolved
						to the same data that the reference resolved to when the encapsulated
						data value with reference was created. 
						It is an error if the data resolved through the reference does not match
						the integrity check.
					</mif:p>
                     <mif:p>
						The integrity check is calculated according to the
						<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="integrityCheckAlgorithm"/>
                           <mif:param name="datatypeName" value="ED"/>
                        </mif:object>. By default,
						the <mif:b>Secure Hash Algorithm-1</mif:b> (SHA-1) shall be used.
						The integrity check is binary encoded according to the rules of
						the integrity check algorithm.
					</mif:p>
                     <mif:p>
						The integrity check is calculated over the raw binary data that is
						contained in the data component, or that is accessible through the
						reference. No transformations are made before the integrity check is
						calculated. If the data is compressed, the Integrity Check is
						calculated over the compressed data.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BIN"/>
      </mif:property>
      <mif:property name="integrityCheckAlgorithm" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="SHA-1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Integrity Check Algorithm"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The algorithm used to compute the integrityCheck value. 
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The default	value is SHA-1.<mif:object name="footnote">
								The cryptographically strong checksum algorithm Secure Hash
								Algorithm-1 (SHA-1) is currently the industry standard. It has
								superseded the MD5 algorithm only a couple of years ago, when certain
								flaws in the security of MD5 were discovered. Currently the SHA-1 hash
								algorithm is the default choice for the integrity check algorithm.
								Note that SHA-256 is also entering widespread usage.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="IntegrityCheckAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="description" sortKey="09" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Description"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
 					    An alternative description of the media where the context is not suitable for rendering the media.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
					    E.g. Short text description of an image or sound clip, etc.  
					    This attribute is not intended to be a complete substitute for the original.  
					    For complete substitutes, use the "translation" property.
						The intent of this property is allow compliance with disability requirements
						such as those expressed in American's with Disability Act (also known as "Section 508"),
						where there is a requirement to provide a short text description of included media in
						some form that can be read by a screen reader. This is similar to a very short thumbnail with mediaType = text/plain.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="thumbnail" sortKey="10" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Thumbnail"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						An abbreviated rendition of the full data.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						 A thumbnail requires
						significantly fewer resources than the full data, while still
						maintaining some distinctive similarity with the full data. A
						thumbnail is typically used with by-reference encapsulated data. It
						allows a user to select data more efficiently before actually
						downloading through the reference.
						Originally, the term thumbnail refers to an image in a lower
						resolution (or smaller size) than another image. However, the
						thumbnail concept can be metaphorically used for media types other
						than images. For example, a movie may be represented by a shorter
						clip; an audio-clip may be represented by another audio-clip that is
						shorter, has a lower sampling rate, or a lossy compression; or an abstract
						provided for a long document.
					</mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="ITS-Note">
                  <mif:text>
                     <mif:p>
							ITS's SHOULD consider the case where the thumbnail and the original
							both have the same properties of type, charset and compression. In
							this case, these properties need not be represented explicitly for the
							thumbnail but might be "inherited" from the main encapsulated data
							value to its thumbnail.
						</mif:p>
                  </mif:text>
               </mif:otherAnnotation>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text>
							Thumbnails may not be allowed depending on the attribute or component
							that is declared encapsulated data. Values of type <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ST"/>
                     </mif:object>
							SHALL NOT have thumbnails, and a thumbnail itself SHALL NOT
							contain a thumbnail.
						</mif:text>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage"/>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="translation" sortKey="11" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Translation"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Alternate renditions of the same content translated into a different language or a different
						mediaType. The translation property is a set of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> that each translate the first rendition
						into a different language or use a different mediaType. Each element of the translation set SHALL
						be a translation of the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value. Translations SHALL NOT contain translations.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The translations SHALL convey the same information, but in a different language or mediaType.
						The translations do not take part in the test for equality, so SHALL NOT introduce any new semantics
						to the value.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ED x)
      where x.nonNull {
   forall(ED t) where x.translation.contains(t) {
     t.description.isNull;
	 t.language.equals(x.language).not.or(t.mediaType.equals(x.mediaType).not);
	 t.translation.isEmpty;
   }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="DSET">
            <mif:argumentDatatype name="ED"/>
         </mif:type>
      </mif:property>
      <mif:property name="length" sortKey="12" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Length"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The length of the content in the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							  The length of the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> may not be the same as the length of the binary
							  content of the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> in the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="data"/>
                           <mif:param name="datatypeName" value=""/>
                        </mif:object> property. The
							  length is the number of items in the content where the kind of item is determined
							  by the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="mediaType"/>
                           <mif:param name="datatypeName" value=""/>
                        </mif:object>. For instance, if the mediatype is a type
							  of text, then the length of the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the number of characters found in
							  the binary content, as specified by the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="charset"/>
                           <mif:param name="datatypeName" value=""/>
                        </mif:object>. For
							  application, video, audio and image mediatypes, the length is the same as the length of the
							  binary content.
						</mif:p>
                     <mif:p>
							nonNull <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> SHALL always have some content, and <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is greater than 0. 
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ED x, INT y)
      where x.nonNull.and(y.isZero) {
   x.length.greaterThan(y);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="subPart" sortKey="13" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="SubPart"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A contiguous sublist of the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> containing the content found from index start to end, inclusively.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							As with length, the subPart of an ED may be different to a subList of the 
							<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="data"/>
                           <mif:param name="datatypeName" value=""/>
                        </mif:object>. The offsets are determined based on the logical
							contents as determined by the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="mediaType"/>
                           <mif:param name="datatypeName" value=""/>
                        </mif:object>. For 
							application, video, audio and image mediatypes, the offsets are the same 
							as the offsets in the binary content. The content 
							must then the re-rendered into some binary representation.
						</mif:p>
                     <mif:p>
							The <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="mediaType"/>
                           <mif:param name="datatypeName" value=""/>
                        </mif:object> and the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="charset"/>
                           <mif:param name="datatypeName" value=""/>
                        </mif:object> of 
							the return value are usually of the same type as the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>, but this may not
							always be the case.  
						</mif:p>
                     <mif:p>
							If the internal content has some structure which makes the specified range inappropriate,
							the return value MAY be NULL.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="start" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:parameter name="end" sortKey="2">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="equal" sortKey="14" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two nonNull values of type <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> are equal if and only if their mediaType
						and data are equal. For those <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values
						with compressed data or referenced data, only the de-referenced and
 						uncompressed data counts for the equality test. The compression, thumbnail, translation
						and reference property themselves are excluded from the equality test.
						In addition the language property is excluded from the test, due to the
						problems this would introduce values of type <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> where the language is not
						specified. If the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="mediaType"/>
                           <mif:param name="datatypeName" value="ED"/>
                        </mif:object> is character based and the charset property
						is not equal, the charset property must be resolved through mapping of the
						data between the different character sets.<mif:object name="footnote">
								This means that values of the type ED and BIN may never be equal. ED, may, however,
								be equal with ST, SC, UID, OID, UUID, and RUID values.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ST" title="CharacterString" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					Text data, primarily
					intended for machine processing (e.g., sorting, querying, indexing, presentation,
					etc.). 
				</mif:text>
            </mif:definition>
            <mif:requirements>
               <mif:text>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is a specialization of <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ED"/>
                     </mif:object> so that any RIM attribute which has the type
						<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ED"/>
                     </mif:object> can be constrained to a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>. The most important case is Act.text, which is
						an <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ED"/>
                     </mif:object> to cater for the use of references and multimedia data, but is often
						constrained to plain text.
					</mif:p>
               </mif:text>
            </mif:requirements>
            <mif:designComments>
               <mif:text>
                  <mif:p>
                     <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ST"/>
                     </mif:object> is primarily used for names, symbols, and formal expressions.
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ST"/>
                     </mif:object> is a restricted <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ED"/>
                     </mif:object>,
					whose <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="mediaType"/>
                        <mif:param name="datatypeName" value="ED"/>
                     </mif:object> property is fixed to <mif:b>text/plain</mif:b>,
					and whose data SHALL be inlined and not compressed. Thus, the properties compression, reference,
					integrity check, algorithm, and thumbnail are not applicable. The character
					string data type is used when the visual presentation of text does not affect its meaning,
					which is true for formalized text and all kinds of names.
				</mif:p>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> data type interprets the encapsulated data
					as character data (as opposed to bits), depending on the charset
					property of the encapsulated data type.
				</mif:p>
                  <mif:p>
					The headCharacter and tailString properties define <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> as a sequence
					of entities each of which uniquely identifies one character from the
					joint set of all characters known by any language of the world.<mif:object name="footnote">
							ISO/IEC 10646-1: 1993 defines a character as "A member of a set of
							elements used for the organization, control, or representation of
							data."  ISO/IEC TR 15285 - An operational model for characters and
							glyphs. Discusses the problems involved in defining
							characters. Notably, characters are abstract entities of information,
							independent of type font or language. The ISO 10646 (UNICODE
							[http://www.unicode.org]) - or in Japan, JIS X0221 - is a globally
							applicable character set that uniquely identifies all characters of
							any language in the world.
						
							In this specification, ISO 10646 serves as a semantic model for
							character strings. The important point is that for semantic purposes,
							there is no notion of separate character sets and switching between
							character sets. Character set and character encoding are ITS layer
							considerations. The formal definition gives indication to this effect
							because each character is by itself an  value that
							has a charset property. Thus, the binary encoding of each character is
							always understood in the context of a certain character set. This does
							not mean that the ITS should represent a character string as a
							sequence of full blown  values. What it means is that
							on the application layer the notion of character encoding is
							irrelevant when we deal with character strings.
						</mif:object>
                  </mif:p>
                  <mif:p>
					The length of an <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is the number of characters, not the number of
					encoded bytes, in the string. Byte encoding is an ITS issue and is not relevant on
					the application layer.
				</mif:p>
                  <mif:p>
					The following rules apply to whitespace contained within values of type <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>:
				</mif:p>
                  <mif:ul>
                     <mif:li/>
                     <mif:li/>
                     <mif:li/>
                     <mif:li>
                        <mif:a href="http://www.w3.org/TR/2000/REC-xml-20001006#sec-line-ends"/>
                     </mif:li>
                     <mif:li/>
                  </mif:ul>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type CharacterString alias ST specializes ED {
   ST.NT     headCharacter;
   ST.NT     tailString;
   DSET&lt;ST.NT&gt; translation;
   literal  ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
            <mif:otherAnnotation type="ITS-Note">
               <mif:text>
                  <mif:p>
						Because many of the properties of the encapsulated data are bound to a
						default value, an ITS need not represent these properties at all. In
						fact, if the character encoding is also fixed, the ITS only represents
						the encoded character data and language.
					</mif:p>
               </mif:text>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text>
					The head of an <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> is a string of only one character. An <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object>
					SHALL have at least one character or else be NULL. A
					zero-length <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> is an exceptional value (NULL), not a proper
					value.
				</mif:text>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.headCharacter.notEmpty;
   x.headCharacter.length.equal(1);
   x.headCharacter.tailString.isEmpty;
   x.tailString.isEmpty.implies(x.length.equal(1));
   x.tailString.notEmpty.implies(x.length.equal(x.tailString.length.successor));
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="data" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Binary Data"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The sequence of characters that make up the content of the string.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The data is constrained to be a valid sequence of characters represented in the chosen character set.
						It SHALL be contained in-line - the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="reference"/>
                           <mif:param name="datatypeName" value="ED"/>
                        </mif:object> property cannot be used. 
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="BIN"/>
      </mif:property>
      <mif:property name="mediaType" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="text/plain"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Media Type"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Identifies the type of the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> and identifies a
						method to interpret or render the data. The fixed mediaType
						is text/plain.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Fixed to be "text/plain".
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.mediaType.code.equal("text/plain");
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="MediaType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="charset" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Charset"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Values of type <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> SHALL have a known charset. 
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.charset.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="Charset"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="language" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Language"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="HumanLanguage"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="compression" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Compression"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Values of type <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> SHALL NOT be compressed.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.compression.notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CompressionAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="reference" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Reference"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Values of type <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> SHALL NOT reference content from some other location.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.reference.notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="TEL.URL"/>
      </mif:property>
      <mif:property name="integrityCheck" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Integrity Check"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Integrity check code SHALL NOT be used with values of type <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.integrityCheck.notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="BIN"/>
      </mif:property>
      <mif:property name="integrityCheckAlgorithm" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Integrity Check Algorithm"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Integrity check algorithm SHALL NOT be used with values of type <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.integrityCheckAlgorithm.notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="IntegrityCheckAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="thumbnail" sortKey="09" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Thumbnail"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Values of type <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> SHALL NOT have thumbnails.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.thumbnail.notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="headCharacter" sortKey="10" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="HeadCharacter"/>
         <mif:type name="ST.NT"/>
      </mif:property>
      <mif:property name="tailString" sortKey="11" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="TailString"/>
         <mif:type name="ST.NT"/>
      </mif:property>
      <mif:property name="translation" sortKey="12" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Translation"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Alternate renditions of the same content translated into a different
						language. The translation property is a set of ST.NT that each translate
						the first rendition into a different language. Each element of the
						translation set SHALL be a translation of the ST value. Translations
						SHALL NOT contain translations.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						All translations SHALL also be <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>. Since the translations 
						are not allowed to have translations, they are also <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ST.NT"/>
                        </mif:object>.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.translation.dataType.implies(DSET&lt;ST&gt;);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="ST.NT"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="13" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ED"/>
                        </mif:object> data type.<mif:object name="footnote">
								This means that values of the type ED and ST may be equal.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ED"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="literal" sortKey="14" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two variations of <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> literals are defined, a token form
						and a quoted string.<mif:object name="footnote">
								An  literal is a conversion from a character string to
								another data type. Obviously,  literals for character
								strings is a cyclical if not redundant feature. This literal form,
								therefore, mainly specifies how character strings are parsed in the
								data type specification language.
							</mif:object>
						The token form consists only of the lower case and upper case Latin
						alphabet, the ten decimal digits and the underscore. The quoted string
						can contain any character between double-quotes. The double quotes
						prevent a character string from being interpreted as some other
						literal. The token form allows keywords and names to be parsed from
						the data type specification language.
					</mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="ITS-Note">
                  <mif:text>
                     <mif:p>
							Since <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> literals are so fundamental to implementation
							technology, most ITS will specify some modified character string
							literal form. However, ITS designers must be aware of the interaction
							between the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> literal form and the literal forms
							defined for other data types. This is particularly critical if the
							other data type's literal form is structured with major components
							separated by break-characters (e.g., real number, physical quantity,
							set, and list literals, etc.).
						</mif:p>
                  </mif:text>
               </mif:otherAnnotation>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
ST.literal ST.SIMPLE {
   ST : /"[^]+"/         { $.equal($1); }  /* quoted string */
      | /[a-zA-Z0-9_]+/  { $.equal($1); }; /* token form */
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="SC" title="CharacterStringWithCode" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ST"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A character string that optionally may have a code attached.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					The text SHALL always be present if a code is present.  The code is often a
					local code.
				</mif:p>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is used in cases where coding is exceptional (e.g.,
					user text messages are essentially text messages, and a printable
					message is the important content. Yet sometimes messages come from a
					catalog of canned messages, which <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> allows to reference.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type CharacterStringWithCode alias SC specializes ST {
   CV code;
   
  promotion  SC (ST x);
   
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text>
						Any non-null <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> value MAY have a code, however, a code SHALL NOT be
						given without the text.
					</mif:text>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SC x)
      where x.nonNull {
   x.code.nonNull.implies(x.notEmpty);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
            <mif:formalConstraint>
               <mif:text>
						The original text of the code, if provided, is the content of the string.<mif:object name="footnote">Implementations will generally not have duplication between the content of the SC and the originalText of the code property.</mif:object>
               </mif:text>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SC x)
      where x.nonNull {
   x.code.nonNull.implies(x.code.originalText.equals(x));
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="code" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A code representing the string data. For example, the string data may
						be a user-message out of a message-catalog where the code represents
						the identifier of the message in the message catalog.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CV"/>
      </mif:property>
      <mif:property name="equal" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ED"/>
                        </mif:object> data type.
						The code property is not included in the equality test.<mif:object name="footnote">
								This means that values of the type SC, ED and ST may be equal.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ED"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="translation" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:businessName name="Translation"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="ED"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CD" title="ConceptDescriptor" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A reference to a concept defined in a code system
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					A <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> may contain a simple code - that is, a reference to a
					concept defined directly by the referenced code system, or it may
					contain an expression in some syntax defined by the referenced
					code system that can be meaningfully evaluated. e.g., the
					concept of a "left foot" as a postcoordinated term built from the
					primary code "FOOT" and the qualifier "LEFT".
				</mif:p>
                  <mif:p>
					A <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> may also contain an original text or phrase that
					served as the basis of the coding. This is preserved to allow for validation of the representation
					of the concept in various fashions. 
				</mif:p>
                  <mif:p>
					A <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> can contain one or more translations into multiple coding systems.
					The translations are all representations of the same concept in various
					code systems (note that there may be more than on representation in a single 
					code system where code systems allow multiple representations, such as Snomed-CT). 
					There is only one concept, and only the first <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> may
					contain an original text. It is possible to represent the translation
					chain - which <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> was translated from which - if desired, using 
					the source attribute. Each <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> may also carry a rationale to indicate why it is represented.
				</mif:p>
                  <mif:p>
					Attributes with type <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> are generally bound to a domain that is used to constrain
					the coded concepts to which a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> may refer. Domains are bound to value sets that 
					define the codes and code systems that may be used in the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>. The binding process is discussed
					in depth in the "Core Principles of V3 Models" specification under "Vocabulary Binding" 
					([<mif:a href="../coreprinciples/coreprinciples.htm#coreP_V3_Conformance-Vocabulary-Binding"/>]). 
					Domains are bound with a qualifier that specifies with the
					domains are extensible or not. If a domain is not extensible (CNE), then 
					a non-exceptional root <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> SHALL contain a code that exists in the domain with
					which the attribute is associated<mif:object name="footnote">
					 	There is no formal definition for this extra constraint as there is no machinery
					 	for the formal language to refer to externally specified constraints.
					</mif:object>. If a domain is extensible (CWE) then 
					a non-exceptional <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> SHALL contain a code that exists in the domain with
					which the attribute is associated, a code from a locally defined code system,
					or some originalText that describes the concept. If the code is taken from a 
					locally defined code system, then the <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="codeSystem"/>
                        <mif:param name="datatypeName" value="CD"/>
                     </mif:object>
					property SHALL specify the local code system.
				</mif:p>
                  <mif:p>
					For both CNE and CWE domain bindings, the translations may contain nonNull codes
					from any domain unless otherwise specified by the constraining model. 
				</mif:p>
                  <mif:div title="CD Examples">CDexamples
					    A simple example for code is the ICD-9 code for headache, which is "784.0". 
					
&lt;example code="784.0" codeSystem="2.16.840.1.113883.6.42" codeSystemName="ICD-9"&gt;
	&lt;displayName value="Headache"/&gt;
	&lt;originalText value="general headache"/&gt;
&lt;/example&gt;
					    A possible ICD-10 equivalent is "G44.1" (the ICD-10 classifications are slightly different). 
					
&lt;example code="G44.1" codeSystem="2.16.840.1.113883.6.3" codeSystemName="ICD-10"&gt;
	&lt;displayName value="Headache"/&gt;
	&lt;originalText value="general headache"/&gt;
&lt;/example&gt;Coding Failure Examples
							A common situation with  is when the actual concept cannot be 
							properly represented in a particular coding system. Usually this circumstance
							arises where the concept is expected to be represented in a particular coding
							system. For the purposes of these examples, we assume that all these example
							values are for an observation value of type  that is found in the full Snomed-CT valueset
							(Example OID for the value set = 2.16.840.1.113883.19.11.1 as published 11-June 2007, Real OID for the SNOMED-CT code system = 2.16.840.1.113883.6.96).
							Important Note: The OID root 2.16.840.1.113883.19 is used for example-only OIDs, and OIDs in 
							this space are never valid in real instances. The OIDs used in these examples that in the OID space
							2.16.840.1.113883.6, 2.16.840.1.113883.5 and 2.16.840.1.113883.11 are the correct OIDs to use in
							production instances.  
						
							The simplest case is where the  is not represented in the instance 
							at all, or simply represented as no information.
						
&lt;value nullFlavor="NI"/&gt;
							However this isn't a very useful representation - frequently the source system
							knows more information, and it is still useful to convey that information to 
							the destination system, while still labelling the coding as incomplete.
						
&lt;value nullFlavor="OTH" codeSystem="2.16.840.1.113883.6.96"/&gt;
							or it may be encoded as 
						
&lt;value nullFlavor="OTH" valueSet="2.16.840.1.113883.19.11.1" valueSetVersion="20070711"/&gt;
							Both examples say that the concept cannot be coded in SNOMED. Even more useful
							is to convey some specific information about the concept, even though it cannot
							be represented in SNOMED:
						
&lt;value nullFlavor="OTH" codeSystem="2.16.840.1.113883.6.96"&gt;
	&lt;originalText value="Burnt ear with iron. Burnt other ear calling for ambulance"/&gt;
&lt;/value&gt;
							It is also possible that the content was first encoded in some other 
							code system than SNOMED, and the source system was unable to encode 
							the value in SNOMED. In this case, there is two forms of representation.
							The first is when the binding to SNOMED is labelled as CWE: local 
							extensions are allowed: 
						
&lt;value code="burn" codeSystem="2.16.840.1.113883.19.5.2"&gt;
	&lt;originalText value="Burnt ear with iron. Burnt other ear calling for ambulance"/&gt;
&lt;/value&gt;
							In this case, because the binding is CWE, local extensions are allowed,
							and the source system can simply use it is own codeSystem (here identified
							by the OID "2.16.840.1.113883.19.5.2", which is an example OID) to extend
							the other code system. In fact, the source system can also use a code from
							another well known code system, such as ICD-9. If ICD-9 had a code "A10.1"
							which stood for this same concept, then this would be valid: 
						
&lt;value code="A10.1" codeSystem="2.16.840.1.113883.6.42"&gt;
	&lt;originalText value="Burnt ear with iron. Burnt other ear calling for ambulance"/&gt;
&lt;/value&gt;
							If, however, the binding to the SNOMED-CT valueset is labelled CNE, then the
							code must come from SNOMED. The same information as the case above 
							must be conveyed differently:
						
&lt;value nullFlavor="OTH" codeSystem="2.16.840.1.113883.6.96"&gt;
	&lt;originalText value="Burnt ear with iron. Burnt other ear calling for ambulance"/&gt;
    &lt;translation code="burn" codeSystem="2.16.840.1.113883.19.5.2"&gt;
&lt;/value&gt;
							Now the code is clearly marked as OTH: the code cannot be represented in
							SNOMED-CT, but a translation from another system is provided. Though it is
							pretty redundant in this case, the source system could indicate which translation
							comes from which using the source property: 
						
&lt;value nullFlavor="OTH" codeSystem="2.16.840.1.113883.6.96" source="s1"&gt;
	&lt;originalText value="Burnt ear with iron. Burnt other ear calling for ambulance"/&gt;
    &lt;translation id="s1" code="burn" codeSystem="2.16.840.1.113883.19.5.2"&gt;
&lt;/value&gt;
							All these examples have assumed that the attribute is bound to the 
							fictitious value set 2.16.840.1.113883.19.11.1 which is all of SNOMED-CT.
							If the value set was extended to include the LOINC codes as well, it would
							no longer be appropriate to encode a failure to code like this:
						
&lt;value nullFlavor="OTH" codeSystem="2.16.840.1.113883.6.96"/&gt;
							since it is not true that the concept could not be coded from SNOMED-CT - it 
							could not be coded in either SNOMED-CT or LOINC. For this reason, it is appropriate
							to encode the failure to code in the valueSet form:
						
&lt;value nullFlavor="OTH" valueSet="2.16.840.1.113883.19.11.1" valueSetVersion="20070711"/&gt;Expression examples
					    Expressions generally arise with complex medical terminologies such as SNOMED.
						For example, SNOMED CT defines a concept "cellulitis (disorder)"
						(128045006) an attribute "finding site" (363698007) and another
						concept "foot structure (body structure)" (56459004). SNOMED CT allows
						these codes to be combined in a code phrase:
					
128045006|cellulitis (disorder)|:{363698007|finding site|=56459004|foot structure|}
						The full CD form for this is:
					
&lt;value code="128045006:{363698007=56459004}" codeSystem="2.16.840.1.113883.6.42" codeSystemName="Snomed-CT"&gt;
	&lt;originalText value="Cellulitis of the foot"/&gt;
&lt;/value&gt;
						The SNOMED compositional expression language allows for the inclusion of the term
						in the expression, as shown in the first example. These make the expression more
						readable for humans, and so are used throughout this section in the standalone 
						expressions. However the terms are optional and do not improve readability for 
						computers; instead, their optional presence creates needless processing complexity, such as for testing equality. For this reason HL7 recommends that the 
						expressions in CD instances SHOULD NOT include the terms, and no CD examples include the terms 
						in the expressions in this specification. Value sets may make rules about the presence or absense of the
						terms in the expressions. 						
					
						The SNOMED compositional expression language is currently undergoing comment, 
						and may be found at 
						[].
						The next two examples are provided courtesy of David Markwell, and are
						based on SNOMED CT Core Edition 2007-01-31. 
					
						This first example is the SNOMED code for "fracture of left tibia". It shows 
						issues associated with grouping and nesting.
					
31978002|fracture of tibia|: 272741003|laterality|=7771000|left|
						Strictly speaking (in normal form) a "fracture of left tibia" is not
						a "left fracture" of a "tibia bone" but is a "fracture" of the "left"
						"tibia bone" (that is, the qualification of "left" applies to the bone
						not to the fracture). Also note in this example that the fracture and
						bone are grouped - this may look irrelevant but is potentially significant
						for combined fractures where different morphology may apply to different
						bones. An alternative rendering for this same concept is:
					
64572001|disease|:{116676008|associated morphology|=72704001|fracture|,
     363698007|finding site|=(12611008|bone structure of tibia|:272741003|laterality|=7771000|left|)}
						The second example shows a more complicated grouping and nesting structure. The SNOMED
						CT expression for "past history of fracture of left tibia" includes nesting even in
						its simplest form because the laterality does not apply to the past history but rather to
						the disorder.
					
417662000|past history of clinical finding|:246090004|associated finding|=
     (31978002|fracture of tibia|: 272741003|laterality|=7771000|left|)
						The alternative rendering is even more nested:
					
243796009|situation with explicit context|:246090004|associated finding|=
     (64572001|disease|:{116676008|associated morphology|=72704001|fracture|,
     363698007|finding site|=(12611008|bone structure of tibia|:
     272741003|laterality|=7771000|left|)}),408729009|finding context|=
     410515003|known present|,408731000|temporal context|=410513005|past|,
     408732007|subject relationship context|=410604004|subject of record|
     					These are provided as examples of SNOMED expression syntaxes. A full discussion the 
     					merits of the different forms, their relationship and how to work with them can be 
     					found in the SNOMED compositional expression language definition referred to above. 
     				
						It is important to note that the expression syntax and semantic rules are specified by
						the code system. For instance, in SNOMED CT, there are a defined set of
						qualifying attributes, and only Findings and Disorders can be
						qualified with the "finding site" attribute.  does not provide
						for normalization of compositional expressions, therefore it is
						possible to create ambiguous expressions.  Users should understand
						that they must provide the additional constraints necessary to assure
						unambiguous data representation, if they are planning to create
						compositional expressions using . Otherwise, they risk
						the inability to retrieve a complete set of all records corresponding
						to any given query.
					
						ICD-10 allows dual coding. Refer to Section 3.1.3 of the ICD-10 Instruction 
						Manual (2nd Edition, []).
						While ICD-10 clearly establishes the semantic basis for the dual coding, 
						it does not define an actual literal expression form suitable for use with
						CD. In such cases, HL7 defines a suitable literal expression form and assigns
						an OID to that. The OID for this ICD-10 expression is 2.16.840.1.113883.6.260, and specifies
						that the two ICD-10 codes are separated by a space.   
					
&lt;value code="J21.8 B95.6" codeSystem="2.16.840.1.113883.6.260" codeSystemName="ICD-10 Dual Code Expression"&gt;
	&lt;originalText value="Staph aureus bronchiolitis"/&gt;
&lt;/value&gt;
						The ICD-10 code J21.8 is "Acute bronchiolitis due to other specified organisms" and
						the code B95.6 is "Staphylococcus aureus as the cause of diseases classified to other chapters".
					</mif:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type ConceptDescriptor alias CD specializes ANY {
    ST.SIMPLE       code;
    UID             codeSystem;
    ST.NT           codeSystemName;
    ST.SIMPLE       codeSystemVersion;
    UID             valueSet;
    ST.SIMPLE       valueSetVersion;
    ST              displayName;
    ED.TEXT         originalText;
    SET&lt;CS&gt;         codingRationale;
    DSET&lt;CD&gt;        translation;
    CD              source;
    BL              implies(CD x);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text>
					A non-exceptional <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> value SHALL have a non-NULL <mif:object name="propertyRef">
                     <mif:param name="propertyName" value="code"/>
                     <mif:param name="datatypeName" value="CD"/>
                  </mif:object> or
					<mif:object name="propertyRef">
                     <mif:param name="propertyName" value="originalText"/>
                     <mif:param name="datatypeName" value="CD"/>
                  </mif:object> property. Conversely, a
					<mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> value without a value for both the <mif:object name="propertyRef">
                     <mif:param name="propertyName" value="code"/>
                     <mif:param name="datatypeName" value="CD"/>
                  </mif:object> and <mif:object name="propertyRef">
                     <mif:param name="propertyName" value="originalText"/>
                     <mif:param name="datatypeName" value="CD"/>
                  </mif:object> properties,
					or with a value that is not from the specified coding system is an exceptional
					value (NULL of flavor <mif:b>other</mif:b>). If the concept (the intent of the
					original text) cannot be properly represented within the set of codes to which 
					the attribute is constrained (the value set), then the nullFlavor of
					the <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> should be set to "OTH" (other) and either a reference
					to a code system or a value set (which may refer to multiple code
					systems) SHALL be provided.
				
				   Note that sending a <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> with a nullFlavor of <mif:b>other</mif:b> and a 
				   code system says that no appropriate code could be found in the entire code
				   system. If this statement can only be made about a a subset of the code system,
				   or about multiple code systems, then a value set should be used instead.     
				</mif:text>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x)
      where x.nonNull {
   x.code.nonNull.or(x.originalText.nonNull);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="code" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The plain code symbol defined by the code system, or an expression in a syntax
						defined by the code system which describes the concept.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						If the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is a proper value (non-null), then it SHALL contain either a code or an originalText.
						If the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is bound to a domain or value set with a CNE constraint, then a code from the bound
						domain or value set SHALL be used.
					</mif:p>
                     <mif:p>
					  If provided, the code SHALL be an exact match to a plain code symbol or expression defined by the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="codeSystem"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object>.
					  If the code system defines a code or expression that includes whitespace, the <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> SHALL
					  include the whitespace.
					</mif:p>
                     <mif:p>
						An expression can only be used where the codeSystem either defines an 
						expression syntax, or there is a generally accepted syntax for the codeSystem.
						A code system may be defined that only defines a syntax and binding to other 
						code Systems.
					</mif:p>
                     <mif:p>
						It is at the discretion of the interpreting system whether to check for an
						expression instead of a simple code and evaluate the expression instead of 
						treating the expression as a code. In some cases, it may be unclear whether
						the code represents a single symbol or an expression. This usually arises where
						the code system defines an expression language and then defines pre-coordinated
						concepts with symbols which match their expression, e.g. UCUM. In other cases,
						it is safe to treat the expression as a symbol. There is no guarantee that this
						is always safe: the definitions of the codeSystem should always be consulted to
						determine how to handle potential expressions. 
					</mif:p>
                     <mif:p>
						Where the requirements for handling expressions and post-coordinated concepts
						are deemed unreasonable and/or impractical for a particular application, the
						valueset and/or codeSystems assigned to the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> in the applicable design
						models should be used to prohibit them to the degree desired.<mif:object name="footnote">
							In Release 1 of the data types, expressions were handled in qualifiers, and
							there were specific data types (CE) that prohibited some use of expressions. The
							problem with this was that there were mismatches between the choice of data type
							and the value set. In particular, there are cases where a single concept may be 
							represented by a mix of valuesets both allowing and prohibiting expressions, and
							using the data type to constrain expressions was not possible.  
						</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x)
      where x.nonNull {
   x.code.nonNull.or(x.originalText.nonNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="codeSystem" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code System"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The code system that defines the code.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Code systems SHALL be referred to by a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="UID"/>
                        </mif:object>, which allows unambiguous
						reference to standard HL7 codes, other standard code systems, as well as local
						codes. Where HL7 has assigned an identifier to a code system, this identifier
						SHALL be used. Otherwise implementations SHALL use an appropriate ISO Object Identifier
						(<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="OID"/>
                        </mif:object>) or <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="UUID"/>
                        </mif:object> to construct a globally unique local coding
						system identifier.
					</mif:p>
                     <mif:p>
						A CD that has a code attribute SHALL have a codeSystem specifying the system of concepts that defines the code.
					</mif:p>
                     <mif:p>
						An exceptional <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> of NULL-flavor <mif:b>other</mif:b> indicates that
						a concept could not be coded in the coding system or value set specified. Thus, for
						these coding exceptions, the code system or value set that did not contain the
						appropriate concept SHALL be provided in <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> or <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="valueSet"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object>.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x)
      where x.code.nonNull {
   x.codeSystem.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x)
      where x.other {
   x.code.other;
   x.codeSystem.nonNull.or(x.valueSet.nonNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="UID"/>
      </mif:property>
      <mif:property name="codeSystemName" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code System Name"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The common name of the coding system.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The code system name has no computational value. The purpose of a code
						system name is to assist an unaided human interpreter of a code value to
						interpret <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="codeSystem"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object>.
						It is suggested â though
						not absolutely required â that ITS provide for <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> in
						order to annotate the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="UID"/>
                        </mif:object> for human comprehension.
					</mif:p>
                     <mif:p>
						HL7 systems SHALL NOT functionally rely on <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object>. <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> can
						never modify the meaning of <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="codeSystem"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> and
						cannot exist without <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="codeSystem"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object>. Conformant
						systems MAY choose not to implement <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> but SHALL NOT reject
						instances because <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is present.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x) {
   x.codeSystemName.nonNull.implies(x.codeSystem.nonNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.NT"/>
      </mif:property>
      <mif:property name="codeSystemVersion" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code System Version"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						If applicable, a version descriptor defined specifically for the given
						code system.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
								Note that by definition a code symbol SHALL have the same meaning throughout all
								versions of a code system. Between versions, codes may be retired but not withdrawn
								or reused. Where the definition of the meaning of a code symbol changes, it must
								still be compatible (equal) between different code system versions.
							</mif:p>
                     <mif:p>
						HL7 will specify how these version strings are formed for each
						external code system. If HL7 has not specified how version strings are
						formed for a particular coding system, version designations have no
						defined meaning for such coding system. HL7 will publish the applicable
						version when internal HL7 code systems are published.
					</mif:p>
                     <mif:p>
						Different versions of one code system must be compatible. Whenever a
						code system changes in an incompatible way, it will constitute a new
						code system, not simply a different version, regardless of how the
						vocabulary publisher calls it.
					</mif:p>
                     <mif:p>
						For example, the publisher of ICD-9 and ICD-10 calls these code
						systems, "revision 9" and "revision 10" respectively. However, ICD-10
						is a complete redesign of the ICD code, not a backward compatible
						version. Therefore, for the purpose of this data type specification,
						ICD-9 and ICD-10 are different code systems, not just different
						versions. By contrast, when LOINC updates from revision "1.0j" to
						"1.0k", HL7 would consider this to be just another version of LOINC,
						since LOINC revisions are backwards compatible.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x) {
   x.codeSystemVersion.nonNull.implies(x.codeSystem.nonNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="valueSet" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value Set"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						 The value set that applied when this <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> was created.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						In many cases, a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is created from a value set - either a code/code system 
						pair is chosen from a valueSet, or one is not chosen and the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> has the 
						exceptional value of <mif:b>NullFlavor.OTH</mif:b>. If no code is chosen, it is 
						generally inappropriate to reference the code system from which the code was 
						chosen as the value set may not match the code system (may include a subset of
						the codeSystem, or additional terms from other code systems); instead, the value 
						set should be provided. In addition, there are some known use cases where the 
						value set that a user or system was offered when choosing a code affects the 
						interpretation of the code.
					</mif:p>
                     <mif:p>
						Note that if a code is provided, the meaning of the code must come from the
						definition of the code in the code system. The meaning of the code SHALL NOT 
						depend on the value set. Applications SHALL NOT be required to interpret 
						the code in light of the valueSet. Applications SHALL NOT reject an instance 
						because of the presence or absence of any or a particular value set. 
					</mif:p>
                     <mif:p>
						Value sets SHALL be referred to by a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="UID"/>
                        </mif:object>, which allows unambiguous 
						reference to standard HL7 value sets, and other value sets. Where HL7 has assigned an 
						identifier to a value set, this identifier SHALL be used. Otherwise implementations 
						SHALL use an appropriate ISO Object Identifier (<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="OID"/>
                        </mif:object>) or 
						<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="UUID"/>
                        </mif:object> to construct a globally unique local value set identifier.
					</mif:p>
                     <mif:p>
						When ever a value set is provided, the version of the value set SHALL also be 
						provided.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="UID"/>
      </mif:property>
      <mif:property name="valueSetVersion" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value Set Version"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						 The version of the value set that applied when this <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> was created.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> SHALL be provided when a valueSet is provided, and otherwise SHALL be null. 
						The value of the <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> must properly identify a particular version of the value 
						set following the rules defined by the value set or its publisher. For HL7 defined
						value sets, the version SHALL be the date/time that the value set was published.
						For further information,
						see in the "Core Principles of V3 Models" specification under "Value Set Versioning" ([<mif:a href="../coreprinciples/coreprinciples.htm"/>])
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x)
      where x.valueSet.nonNull {
   x.valueSetVersion.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="displayName" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Display Name"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
					    A name, title, or representation for the code or expression as it exists in the code system identified by
						the value of <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="codeSystem"/>
                        <mif:param name="datatypeName" value="CD"/>
                     </mif:object>. 
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Normally, the <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> would be the human
						readable representation of the concept that the sending system shows to its users. The displayName
						is included so that an unaided human interpreter of a code value has a human readable
						description of what the concept meant within the code system at the time of data entry.
					</mif:p>
                     <mif:p>
						If populated, <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> SHALL be a valid human readable representation of the
						concept as defined by the code system at the time of data entry. The <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> SHALL conform to any rules
						defined by the codingSystem; if the codeSystem does not define a human representation for the code or
						expression, then none can be provided.
						<mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is included both as a courtesy to an unaided human
						interpreter of a code value and as a documentation of the name used to
						display the concept to the user. The display name has no functional
						meaning; it SHALL never exist without a code; and it SHALL never
						modify the meaning of <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="code"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object>. A display name may
						not be present if the code is an expression for which no
						display name has been assigned or can be derived. Conformant
						systems MAY choose not to implement <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> but SHALL NOT reject
						instances because <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is present.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x) {
   x.displayName.nonNull.implies(x.code.nonNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="originalText" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Original Text"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
					    The text as seen and/or selected by the user who entered the data which represents the intended meaning of the user. 
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Original text can be used in a structured user
						interface to capture what the user saw as a representation of the code or expression on the data input screen, or in a situation
						where the user dictates or directly enters text, it is the text entered or uttered by the user. It is a common exceptional case to use
						the CD data type to store only the text that the user entered or uttered. In this situation, original text will
						exist without a code, and the nullFlavor OTH will apply. In a situation where the code is assigned sometime after the text was entered, originalText
						is the text or phrase used as the basis for assigning the code.
					</mif:p>
                     <mif:p>
						The original text exists in a scenario where an originator of the
						information does not assign a code, but where the code is assigned
						later by a coder (post-coding).  In the production of a concept
						descriptor, original text may thus exist without a code.
					</mif:p>
                     <mif:p>
							Note that although post-coding is often performed from free text information,
							such as documents, scanned images or dictation, multi-media data is
							explicitly not permitted as original text. Also, the original text
							property is not meant to be a link into the entire source
							document. The link between different artifacts of medical information
							(e.g., document and coded result) is outside the scope of this
							specification and is maintained elsewhere in the HL7 standards. The
							original text SHALL be an excerpt of the relevant information in the
							original sources, rather than a pointer or exact reproduction. Thus
							the original text SHALL be represented in plain text form. In specific
							circumstances, as described in other HL7 specifications, the originalText
							may be a reference to some other text artefact for which the resolution
							scope is clearly described.
						</mif:p>
                     <mif:p>
						Values of type <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> MAY have a non-NULL original text
						property despite having a NULL <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="code"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object>. Any <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> value
						with <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="code"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> of NULL signifies a coding exception. In this case,
						<mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is a name or description of the concept that was
						not coded. Such exceptional <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values MAY also contain <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="translation"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object>s.
						Such translations directly encode the concept described in <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object>.
					</mif:p>
                     <mif:p>
						The originalText represents the originalText of the concept itself. Translations
						SHALL NOT have an originalText of their own.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x) {
  forall(CD translation) where x.translation.contains(translation) {
         translation.originalText.isNull;
         };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ED.TEXT"/>
      </mif:property>
      <mif:property name="codingRationale" sortKey="09" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Coding Rationale"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
					     The reason a particular <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> has been provided.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The values O and P are mutually exclusive â only one of these two values SHALL be part 
						of codingRationale at any given time.  A code is deemed to be post-coded if the user 
						does not assign a code when they first enter the data (i.e. when coding occurs 
						subsequently using the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="originalText"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object>). codingRationale is 
						not expected to act as a quality review marker on the quality of the coding or the 
						translation processes.
					</mif:p>
                     <mif:p>
						A code is required when it is present in the instance to meet some constraints imposed 
						on the instance by the context of use. Applications SHALL not be required to mark a 
						particular translation as required even though it is required by the context of use, 
						but MAY do so. Applications SHALL not reject instances because of the presence or 
						absence of any particular codingRationale flag.					
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="SET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CodingRationale"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="translation" sortKey="10" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Translation"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
					    A set of other CDs that each represent a translation of this CD into equivalent codes within
						the same code system or into corresponding concepts from other code systems.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Translations SHALL NOT contain translations. The root <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> has one set of translations
						which lists all the translations.
					</mif:p>
                     <mif:p>
						The root translation is generally the one that best meets the conformance criteria for the
						<mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>. No implication about lineage of the translations can be drawn from the selection
						of the root code. Instead the properties <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="codingRationale"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> and 
						<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="source"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> is used to trace lineage.
					</mif:p>
                     <mif:p>
						In the absence of a constraining model that makes constraints on the value domain of
						the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>, any of the translations MAY be the root <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>. If the constraining
						model makes constraints on the value domain of the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> and there is a translation
						that meets the constraints, that translation SHOULD be the root <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>. If the
						constraining model makes constraints on the value domain of the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> and there is 
						no translation that meets the constraints, then any of the translations MAY be the root,
						as long as they are assigned a nullFlavor. An alternative is to put none of the translations
						in the root, and give it a nullFlavor of choice, and put all the translations in the translation
						property of the root.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x) {
  forall(CD t) where x.translation.contains(t) {
         t.translation.isEmpty;
         };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="DSET">
            <mif:argumentDatatype name="CD"/>
         </mif:type>
      </mif:property>
      <mif:property name="source" sortKey="11" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Source"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
					    The <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> from which this <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> was translated, if it was
						translated from another <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						A <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> consists of a single root code and a set of translations, which do not
						have translations. Using the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="codingRationale"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> property, a
						sender can indicate which is the original code. There are some circumstances
						in which it is useful to know which <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> was translation from which <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>.
						The <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> allows for the translation sequence from one translation to another
						to be represented.
					</mif:p>
                     <mif:p>
						Each element of the translation set was translated from the
						original <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>. Each translation may, however, also have
						translations. Thus, when a code is translated multiple times the
						information about which code served as the input to which translation
						will be preserved.
					</mif:p>
                     <mif:p>
						The source SHALL also be contained within the same <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> cluster (a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> and its translations).
					</mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="ITS-Note">
                  <mif:text>
                     <mif:p>
							Since the source must be found independently as the root code, or in
							the list of translations, some sort of referential implementation is
							appropriate for the source property in ITSs.
							</mif:p>
                  </mif:text>
               </mif:otherAnnotation>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x) where x.nonNull.and(x.source.nonNull) {
  x.translation.contains(x.source).or(x.source.translation.contains(x));
};
</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="CD"/>
      </mif:property>
      <mif:property name="equal" sortKey="12" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The main use of concept descriptors is for the purpose of indexing,
						querying and decision-making based on a coded value. A semantically
						unambiguous specification of coded values therefore requires a clear
						definition of what equality of concept descriptor values means and how
						<mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values should be compared.<mif:object name="footnote"> (For more details on
						comparing pre- and post-coordinated SNOMED expressions, see Dolin RH,
						Spackman KA, Markwell D. Selective Retrieval of Pre- and
						Post-coordinated SNOMED Concepts. Fall AMIA 2002; 210-14, or the July
						2007 SNOMED CT Implementation Guide, or see SNOMED CT Transformations to
						Normal Forms at http://www.ihtsdo.org/our-standards/technical-documents/).
							</mif:object>
                     </mif:p>
                     <mif:p>
						The equality of two <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values is determined solely
						based upon <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="code"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> and <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="codeSystem"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object>.
						<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="codeSystemVersion"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> is
						excluded from the equality test.<mif:object name="footnote">
								 does not count in the equality test since by
								definition a code symbol must have the same meaning throughout all
								versions of a code system. Between versions, codes may be retired but
								not withdrawn or reused.
							</mif:object>
						Translations are not included in the equality test.<mif:object name="footnote">
								Translations are not included in the equality test of concept
								descriptors for safety reasons. An alternative would have been to
								consider two  values equal if any of their
								translations are equal. However, some translations may be equal
								because the coding system of that translation is very
								coarse-grained. More sophisticated comparisons between concept
								descriptors are application considerations that are not covered by
								this specification.
							</mif:object>
						Exceptional <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values are not equal even if they have
						the same NULL-flavor or the same original text.<mif:object name="footnote">
								NULL-values are exceptional values, not proper concepts. It would be unsafe to
								equate two values merely on the basis that both are exceptional (e.g., not
								codable or unknown).  Likewise there is no guarantee that original text
								represents a meaningful or unique description of the concept so that equality
								of that original text does not constitute concept equality. The reverse is
								also true: since there is more than one possible original text for a concept,
								the fact that original text differs does not constitute a difference of the
								concepts.
							</mif:object>
                     </mif:p>
                     <mif:p>
						Some code systems define certain style options to their code
						values or expression syntaxes. For example, the U.S. National Drug Code (NDC) has a dash and
						a non-dash form. An example for the dash form may be 1234-5678-90 when
						the non-dash form is 01234567890. Another example for this problem is
						when certain ISO or ANSI code tables define optional alphanumeric and
						numeric forms of two or three character lengths all in one standard.
					</mif:p>
                     <mif:p>
						In the case where code systems provide for multiple representations,
						HL7 wil make a ruling about which is the preferred form. HL7 will
						document that ruling where that respective external coding system is
						recognized. HL7 will decide upon the preferred form based on criteria
						of practicality and common use. In absence of clear criteria of
						practicality and common use, the safest, most extensible, and least
						stylized (the least decorated) form shall be given
						preference.<mif:object name="footnote">
								This ruling at design-time is necessary to prevent HL7 interfaces from
								being burdened by code literal style conversions at runtime. This is
								notwithstanding the fact that some applications may require mapping
								from one form into another if that application has settled with the
								representation option that was not chosen by HL7.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.code.equal(y.code)
             .and(x.codeSystem.equal(y.codingSystem)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="implies" sortKey="13" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Implies"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Specifies whether this <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is a specialization of
						the operand <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Naturally, concepts can be narrowed and widened to include or exclude
						other concepts. Many coding systems have an explicit notion of concept
						specialization and generalization. The HL7 vocabulary principles also
						provide for concept specialization for HL7 defined value sets.
						<mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is a predicate that compares whether one
						concept is a specialization of another concept, and therefore implies
						that other concept.
					</mif:p>
                     <mif:p>
						When writing predicates (e.g., conditional statements) that compare
						two codes, one SHOULD usually test for implication not equality of
						codes.
					</mif:p>
                     <mif:p>
						For example, in <mif:object name="conceptDomainRef">
                           <mif:param name="domain" value="TelecommunicationAddressUse"/>
                        </mif:object> the
						"telecommunication use" concepts: work (W), home (H), primary home
						(HP), and vacation home (HV) are defined, where both HP and HV imply
						H. When selecting any home phone number, one should test whether the
						given use-code <mif:b>c</mif:b>Â <mif:b>implies</mif:b> H. Testing for
						<mif:b>c</mif:b>Â <mif:b>equal</mif:b> H would only find unspecified home
						phone numbers, but not the primary home phone number.

					</mif:p>
                     <mif:p>
						Operationally, implication can be evaluated in one of two ways. The
						code system literals may be designed such that one single hierarchy is
						reflected in the code literal itself (e.g., ICD-9). Apart from such
						special cases, however, a terminological knowledge base and an
						appropriate subsumption algorithm will be required to evaluate
						implication statements. For post-coordinated coding systems, designing
						such a subsumption algorithm is a non-trivial task.<mif:object name="footnote">
								This is one reason why expressions should be used sparingly 
								and with caution. An additional problem of post-coordinated coding 
								is that a general rule for equality may not exist at all.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="CD"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CO" title="CodedOrdinal" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="CD"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					 Coded data, where the coding system from which the code comes defines a 
					 partial or complete order on some or all of the codes in the system. 
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					Codes may be assigned a numerical value, but this is not required. <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> adds semantics
					related to ordering and/or numerical values so that models that make use of such domains may
					introduce model elements that involve statements about the order of the terms in a domain.
				</mif:p>
                  <mif:p>
					The relative order of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> values need not be independently
					obvious in their literal representation. It is expected that an
					application will look up the ordering of these values from some
					table. Some of the values will have directly assigned numerical 
					value suitable for some mathemetical operations.
				</mif:p>
                  <mif:p>
				    The translations of the code, if present, SHALL not imply a different 
				    order from that implied by the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>. Translations MAY NOT imply any order.
					Translations SHALL not be considered when the ordering of the code
					system is determined. 
				</mif:p>
                  <mif:p>
					Although <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="value"/>
                        <mif:param name="datatypeName" value="CO"/>
                     </mif:object> has a type <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="REAL"/>
                     </mif:object>,
					<mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is provided to represent a series of concepts that have an 
					associated order, and sometimes a value. Likert scales are one such
					use case. <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> should not be used to model an observation or 
					physical measurement which has value along with a set of value
					interpretations, sometimes called reference ranges.  
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type CodedOrdinal alias CO specializes CD {
   REAL value;
   BL  lessOrEqual(CO o);
   BL  lessThan(CO o);
   BL  greaterThan(CO o);
   BL  greaterOrEqual(CO o);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="value" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The value assigned to this code in the code System. 
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> SHALL only be nonNull if the code system explicitly
						assigns a value to the concept.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="equal" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> data type.
						<mif:b>The value property is not included in the equality test.</mif:b>
                        <mif:object name="footnote">
								This means that values of the type CO, CS, CV and CD may be equal.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="CD"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="lessOrEqual" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Less-or-equal"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A predicate expressing an order relation that is reflexive, asymmetric
						and transitive, between this concept and another concept.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is taken as
						primitive in this specification;
						all other order relations can be derived from this one.
						Since <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is primitive, this accomodates partial orderings.
					</mif:p>
                     <mif:p>
						Order relationships typically hold only within a single coding system.
						The terminology defines the order relationship for the concepts. While
						the definition of order is not based upon the value, the value, if provided,
						SHALL be consistent with the defined order.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CO x, y)
      where x.nonNull.and(y.nonNull)
	    .and(x.value.nonNull).and(y.value.nonNull) {
   x.lessOrEqual(y).equal(x.value.lessOrEqual(y.value));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="o" sortKey="1">
            <mif:type name="CO"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="lessThan" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Less-than"/>
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CO x, y)
      where x.nonNull.and(y.nonNull) {
   x.lessThan(y).equal(y.lessOrEqual(x).and(x.equal(y).not));
};

invariant(CO x, y)
      where x.nonNull.and(y.nonNull)
	    .and(x.value.nonNull).and(y.value.nonNull) {
   x.lessThan(y).equal(x.value.lessThan(y.value));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="o" sortKey="1">
            <mif:type name="CO"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="greaterThan" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Greater-than"/>
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CO x, y)
      where x.nonNull.and(y.nonNull) {
   x.greaterThan(y).equal(y.lessThan(x));
};

invariant(CO x, y)
      where x.nonNull.and(y.nonNull)
	    .and(x.value.nonNull).and(y.value.nonNull) {
   x.greaterThan(y).equal(x.value.greaterThan(y.value));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="o" sortKey="1">
            <mif:type name="CO"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="greaterOrEqual" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Greater-or-equal"/>
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CO x, y)
      where x.nonNull.and(y.nonNull) {
   x.greaterOrEqual(y).equal(y.lessOrEqual(x));
};

invariant(CO x, y)
      where x.nonNull.and(y.nonNull)
	    .and(x.value.nonNull).and(y.value.nonNull) {
   x.greaterOrEqual(y).equal(x.value.greaterOrEqual(y.value));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="o" sortKey="1">
            <mif:type name="CO"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CS" title="CodedSimpleValue" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="CV"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					Coded data in its simplest form, where only the code is not predetermined.
					The code system and code system version are fixed by the context in which
					<mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> value occurs. <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> is used for coded attributes that have a single
					HL7-defined value set.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>
                     <mif:object name="footnote">
							CS is a data type rather than a flavor because as well as defining 
							a literal form, it also is associated with the introduction of
							default values to codeSystem and codeSystemVersion in an ITS.
						</mif:object> SHALL only be used in either of the following cases:
				</mif:p>
                  <mif:ol>
                     <mif:li>
                        <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
                     </mif:li>
                     <mif:li/>
                  </mif:ol>
                  <mif:p>
					For example, since <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ED"/>
                     </mif:object> subscribes to the MIME
					design, it trusts IETF to manage the media type. This includes that this
					specification subscribes to the extension mechanism built into the MIME media
					type code (e.g., "application/x-myapp").
				</mif:p>
                  <mif:p>
					For <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> values, the designation of the domain qualifier
					SHALL always be CNE (<mif:b>coded, non-extensible</mif:b>) and the
					context will determine which values to use.<mif:object name="footnote">
							This is not withstanding the fact that an external referenced domain,
							such as the IETF MIME media type may include an extension
							mechanism. These extended MIME type codes would not be considered
							"extensions" in the sense of violating the CNE provision. The CNE
							provision is only violated if an attempt is made in using a different
							code system (by means of ), which is not
							possible with , or to use extensions that do not conform to the 
							external codeSystem.
						</mif:object>
                  </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type CodedSimpleValue alias CS specializes CV {
   literal  ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="code" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> SHALL only contain characters that are either 
						a letter, a digit, or one of '.', '-', '_' or ':'. 
						Code systems that are used with <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> SHALL NOT define 
  					 	code symbols or expression syntaxes that contain whitespace or any
  					 	other characters not in this list.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CS x)
      where x.nonNull {
   x.code.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="codeSystem" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code System"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Every non-NULL <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> value has a defined codeSystem.  The
						ITS representation of <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> need not explicitly mention
						the code system, because the context mandates one and only one code
						system to be used. Specifying the code system explicitly would be
						redundant. However, codeSystem assumes the
						context-specific default value and is not NULL. This same logic applies
						to codeSystemName and codeSystemVersion.
					</mif:p>
                     <mif:p>
						An exceptional <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> of NULL-flavor <mif:b>other</mif:b> indicates that a
						concept could not be coded in the coding system specified. In these cases,
						<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="code"/>
                           <mif:param name="datatypeName" value="CS"/>
                        </mif:object> SHALL be Null.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CS x)
      where x.code.nonNull {
   x.codeSystem.nonNull;
   x.codeSystem.equal(CONTEXT.codeSystem);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CS x)
      where x.other {
   x.code.isNull;
   x.codeSystem.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="UID"/>
      </mif:property>
      <mif:property name="codeSystemName" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code System Name"/>
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CS x) {
   x.codeSystemName.equal(CONTEXT.codeSystemName);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST.NT"/>
      </mif:property>
      <mif:property name="codeSystemVersion" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code System Version"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						For the properties with type <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> defined in this specification that
						are associated with external codeSystems, the codeSystemVersion has the 
						nullFlavor NA.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CS x) {
   x.codeSystemVersion.equal(CONTEXT.codeSystemVersion);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="displayName" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Display Name"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is not applicable when <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is used in exchanging
						data between systems. However the recipient system may be able to 
						derive an appropriate displayName from the code and codeSystem 
						information. Note that conformant systems MAY choose not to implement <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CS x) {
   x.displayName.notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="originalText" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Original Text"/>
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CS x) {
   x.originalText.notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ED.TEXT"/>
      </mif:property>
      <mif:property name="equal" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> data type.
						The value property is not included in the equality test.<mif:object name="footnote">
								This means that values of the type CO, CS, CV, and CD may be equal.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="CD"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="literal" sortKey="08" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The string literal form of <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is primarily defined for the purposes of
						this specification. The literal form is a string representation of the code
						for the codeSystem for the context of the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>. You
						cannot determine <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="codeSystem"/>
                           <mif:param name="datatypeName" value="CS"/>
                        </mif:object> or
						<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="codeSystemVersion"/>
                           <mif:param name="datatypeName" value="CS"/>
                        </mif:object> from the literal itself,
						so the literal only has use where the context is known.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
CS.literal ST.SIMPLE {
   CS : /[a-zA-Z0-9_]+/  { $.equal($1); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="UID" title="UniqueIdentifierString" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ST.SIMPLE"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A unique identifier string is a character string which identifies an
					object in a globally unique and timeless manner. The allowable formats
					and values and procedures of this data type are strictly controlled by
					HL7. At this time, user-assigned identifiers SHALL only be certain character
					representations of ISO Object Identifiers (<mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="OID"/>
                  </mif:object>) and DCE Universally
					Unique Identifiers (<mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="UUID"/>
                  </mif:object>). In addition, HL7 reserves the right to assign other
					forms of <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object>s (<mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="RUID"/>
                  </mif:object>), such as mnemonic identifiers for code systems.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					The sole purpose of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is to be a globally and timelessly unique
					identifier. The form of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>, whether it is an <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="OID"/>
                     </mif:object>,
					a <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="UUID"/>
                     </mif:object> or a <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="RUID"/>
                     </mif:object>, is entirely irrelevant.
					As far as HL7 is concerned, the
					only thing one can do with a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is denote to the object for which it
					stands. Comparison of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s is literal, i.e. if two <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s are literally
					identical, they are assumed to denote to the same object. If two <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s
					are not literally identical they <mif:b>may</mif:b> not denote to the
					same object. Note that this comparison is case sensitive; (<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="OID"/>
                     </mif:object>)s
					do not have letters subject to case, (<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="UUID"/>
                     </mif:object>)s are fixed to
					uppercase, and (<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="RUID"/>
                     </mif:object>)s have a fixed case.
				</mif:p>
                  <mif:p>
					No difference in semantics is recognized between the different
					allowed forms of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>. The different forms are not distinguished
					by a component within or aside from the identifier string itself.
				</mif:p>
                  <mif:p>
					Even though this specification recognizes no semantic difference
					between the different forms of the unique identifier forms, there are
					differences of how these identifiers are built and managed, which is
					the sole reason to define subtypes of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> for each of the
					variants.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type UniqueIdentifierString alias UID specializes ST.SIMPLE;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="equal" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ED"/>
                        </mif:object> data type.
						The value property is not included in the equality test.<mif:object name="footnote">
								This means that values of the type UID, OID, UUID, RUID, ST, SC, and ED may be equal.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ED"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="OID" title="ObjectIdentifier" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="UID"/>
      </mif:derivedFrom>
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="INT"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A globally unique string representing an ISO Object Identifier
					(OID) in a form that consists only of numbers and dots (e.g.,
					"2.16.840.1.113883.3.1"). According to ISO, <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object>s are paths in a tree
					structure, with the left-most number representing the root and the
					right-most number representing a leaf.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p> 
					Each branch under the root corresponds to an assigning authority. Each
					of these assigning authorities may, in turn, designate its own set of
					assigning authorities that work under its auspices, and so on down the
					line. Eventually, one of these authorities assigns a unique (to it as
					an assigning authority) number that corresponds to a leaf node on the
					tree. The leaf may represent an assigning authority (in which case the
					root <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> identifies the authority), a class of particlar objects, 
					or an instance of an object. An assigning authority owns a namespace,
					consisting of its sub-tree.
				</mif:p>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s are the preferred scheme for unique identifiers. <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s SHOULD
					always be used except if one of the inclusion criteria for other
					schemes apply.
				</mif:p>
                  <mif:p>
					ISO/IEC 8824:1990(E) clause 28 defines the Object Identifier as
				</mif:p>
                  <mif:blockquote>
                     <mif:p>
                        <mif:b>28.9</mif:b> The semantics of an
						object identifier value are defined by reference to an <mif:b>
						object identifier tree</mif:b>. An object identifier tree is a tree whose root
						corresponds to [the ISO/IEC 8824 standard] and whose vertices [i.e. nodes]
						correspond to administrative authorities responsible for allocating arcs [i.e.
						branches] from that vertex. Each arc from that tree is labeled by an object
						identifier component, which is [an integer number]. Each information object to
						be identified is allocated precisely one vertex (normally a leaf) and no other
						information object (of the same or a different type) is allocated to
						that same vertex. Thus an information object is uniquely and
						unambiguously identified by the sequence of [integer numbers] (object
						identifier components) labeling the arcs in a path from the root to
						the vertex allocated to the information object.
					</mif:p>
                     <mif:p>
                        <mif:b>28.10</mif:b> An object identifier value is
						semantically an ordered list of object identifier component
						values. Starting with the root of the object identifier tree, each
						object identifier component value identifies an arc in the object
						identifier tree. The last object identifier component value identifies
						an arc leading to a vertex to which an information object has been
						assigned. It is this information object, which is identified by the
						object identifier value. [...]
					</mif:p>
                  </mif:blockquote>
                  <mif:p>
					According to ISO/IEC 8824 an object identifier is a sequence of object
					identifier component values, which are integer numbers. These
					component values are ordered such that the root of the object
					identifier tree is the head of the list followed by all the arcs down
					to the leaf representing the information object identified by the
					OID. The fact that <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> specializes <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="LIST&lt;INT&gt;"/>
                     </mif:object>
					represents this path of object identifier component
					values from the root to the leaf.
				</mif:p>
                  <mif:p>
					The <mif:b>leaf</mif:b> and "<mif:b>butLeaf</mif:b>"
					properties take the opposite view. The
					leaf is the last object identifier component value in the list, and
					the "butLeaf" property is all of the OID <mif:b>but</mif:b> the
					<mif:b>leaf</mif:b>. In a sense, the leaf is the identifier value and
					all of the OID but the leaf refers to the namespace in which the leaf
					is unique and meaningful.
				</mif:p>
                  <mif:p>
					However, what part of the OID is considered <mif:b>value</mif:b>
					and what is <mif:b>namespace</mif:b> may be viewed differently. In
					general, any OID component sequence to the left can be considered the namespace
					in which the rest of the sequence to the right is defined as a
					meaningful and unique identifier value. The value-property with a
					namespace OID as its argument represents this point of view.<mif:object name="footnote">
							The value/namespace view on ISO object identifiers has important
							semantic relevance. It represents the notion of identifier value
							versus identifier assigning authority (or "namespace"), which is common
							in healthcare information systems in general, and HL7 v2.x in
							particular.
						</mif:object>
                  </mif:p>
                  <mif:p>
					In order to support interoperability, HL7 maintains strict rules about the
					registration and use of OIDs. These rules are published in 
						the "Core Principles of V3 Models" specification under "Identification" ([<mif:a href="../coreprinciples/coreprinciples.htm#coreP_Identification-registry"/>]) and SHALL be followed.   
				</mif:p>
                  <mif:p>
						While most owners of an OID will "design" their namespace sub-tree in
						some meaningful way, there is no way to generally infer any meaning on
						the parts of an OID. HL7 does not standardize or require any namespace
						sub-structure. An OID owner, or anyone having knowledge about the
						logical structure of part of an OID, may still use that knowledge to
						infer information about the associated object; however, the techniques
						cannot be generalized.
					</mif:p>
                  <mif:img imageType="image/gif" src="datyp2fig5.gif"
                           alt="&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Example for a tree of ISO object identifiers. HL7's OID&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;is 2.16.840.1.113883.&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;"/>
                  <mif:p>
                     <mif:b>An HL7 interface SHALL NOT rely on any
						knowledge about the substructure of an OID for which it cannot control the
						assignment policies.</mif:b>
                  </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type ObjectIdentifier alias OID specializes UID, LIST&lt;INT&gt; {
           INT  leaf;
           OID  butLeaf;
           OID  value(OID namespace);
   literal ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(OID x)
      where x.nonNull {
   x.notEmpty;
   x.tail.isEmpty.implies(x.leaf.equal(x.tail));
   x.tail.notEmpty.implies(x.leaf.equal(x.tail.leaf));
   x.tail.isEmpty.implies(x.butLeaf.isNull);
   x.tail.notEmpty.implies(x.butLeaf.head.equal(x.head)
         .and(x.butLeaf.tail.equal(x.butLeaf(x.tail))));
   forall(OID v; OID n) where v.equal(x.value(n)) {
      n.isEmpty.implies(v.equal(x));
      n.notEmpty.implies(v.equal(x.value(n.tail)));
      };
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="leaf" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Leaf"/>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="butLeaf" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="All-But-The-Leaf"/>
         <mif:type name="OID"/>
      </mif:property>
      <mif:property name="value" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value"/>
         <mif:parameter name="namespace" sortKey="1">
            <mif:type name="OID"/>
         </mif:parameter>
         <mif:type name="OID"/>
      </mif:property>
      <mif:property name="literal" sortKey="04" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The structured definition of the OID is provided mostly to be faithful
						to the OID specification. Within HL7, OIDs are used as UID strings
						only, i.e., the literal string value is the only thing that is
						communicated and is the only thing that a reciever should have to
						consider when working with UIDs in the scope of the HL7 specification.
					</mif:p>
                     <mif:p>
						For compatibility with the DICOM standard, the literal form of the OID
						should not exceed 64 characters. (see DICOM part 5, section 9).
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
OID.literal ST.SIMPLE {
   OID : INT "." OID { $.head.equal($1);
                       $.tail.equal($3); }
       | INT         { $.head.equal($1);
                       $.tail.isEmpty; }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="equal" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ED"/>
                        </mif:object> data type.
						The value property is not included in the equality test.<mif:object name="footnote">
								This means that values of the type OID, UID, UUID, RUID, ST, SC, and ED may be equal.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ED"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="UUID" title="UniversalUniqueIdentifier" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="UID"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A globally unique string representing a DCE Universal Unique
					Identifier (UUID) in the common UUID format that consists of 5
					hyphen-separated groups of hexadecimal digits having 8, 4, 4, 4,
					and 12 places respectively.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					Both the UUID and its string representation are defined by the Open
					Group, CDE 1.1 Remote Procedure Call specification, Appendix A.
				</mif:p>
                  <mif:p>
					UUIDs are assigned based on Ethernet MAC addresses, the point in time
					of creation and some random component. This mix is believed to
					generate sufficiently unique identifiers without any organizational
					policy for identifier assignment (in fact this piggy-backs on the
					organization of MAC address assignment). Note that there are other 
					common methods for generating UUIDs. HL7 does not require that the UUID
					method defined by the Open Group specification so long as generated UUIDs
					are globally unique. 
				</mif:p>
                  <mif:p>
					UUIDs are <mif:b>not</mif:b> the preferred identifier
					scheme for use as HL7 UIDs. UUIDs may be used when identifiers are
					issued to objects representing individuals (e.g., entity instance
					identifiers, act event identifiers, etc.). For objects describing
					classes of things or events (e.g., catalog items), OIDs are the
					preferred identifier scheme.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type UniversalUniqueIdentifier alias UUID specializes UID {
   INT  timeLow;
   INT  timeMid;
   INT  timeHighAndVersion;
   INT  clockSequence;
   INT  node;
   literal  ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="timeLow" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Low Time"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The low field of the timestamp.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="timeMid" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Mid Time"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The middle field of the timestamp.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="timeHighAndVersion" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="High Time and Version"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The high field of the timestamp multiplexed with the version number.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="clockSequence" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Clock Sequence"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The high field of the clock sequence multiplexed with the variant and the low field of the clock sequence.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="node" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Node"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The spatially unique node identifier (usually the host address). 
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="literal" sortKey="06" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The structured definition of the UUID is provided mostly to be
						faithful to the UUID specification. Within HL7, UUIDs are used as UID
						strings only, i.e., the literal string value is the only thing that is
						communicated and is the only thing that a reciever should have to
						consider when working with UIDs in the scope of the HL7 specification.
					</mif:p>
                     <mif:p>
						The literal form for the UUID is defined according to the original
						specification of the UUID. However, because the HL7 UIDs are case
						sensitive, for use with HL7, the hexadecimal digits A-F in UUIDs
						SHALL be converted to upper case.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
UUID.literal ST.SIMPLE {
   UUID        : hex8 "-" hex4 "-" hex4 "-" hex4 "-" hex12 {
                    $.timeLow.equal($1);
                    $.timeMid.equal($3);
                    $.timeHighAndVersion.equal($5);
                    $.clockSequence.equal($7);
                    $.node.equal($9);
                    }

   INT hex4    : hexDigit hexDigit hexDigit hexDigit {
                    $.equal($1.times(16).plus($2)
                     .times(16).plus($3)
                     .times(16).plus($4);
                    }

   INT hex8    : hexDigit hexDigit hexDigit hexDigit
                       hexDigit hexDigit hexDigit hexDigit {
                    $.equal($1.times(16).plus($2)
                     .times(16).plus($3)
                     .times(16).plus($4)
                     .times(16).plus($5)
                     .times(16).plus($6)
                     .times(16).plus($7)
                     .times(16).plus($8);
                     }

   INT hex12    : hexDigit hexDigit hexDigit hexDigit
                        hexDigit hexDigit hexDigit hexDigit
                        hexDigit hexDigit hexDigit hexDigit {
                     $.equal($1.times(16).plus($2)
                      .times(16).plus($3)
                      .times(16).plus($4)
                      .times(16).plus($5)
                      .times(16).plus($6)
                      .times(16).plus($7)
                      .times(16).plus($8)
                      .times(16).plus($9)
                      .times(16).plus($10)
                      .times(16).plus($11)
                      .times(16).plus($12);
                     }

   INT hexDigit : "0"     { $.equal(0); }
                | "1"     { $.equal(1); }
                | "2"     { $.equal(2); }
                | "3"     { $.equal(3); }
                | "4"     { $.equal(4); }
                | "5"     { $.equal(5); }
                | "6"     { $.equal(6); }
                | "7"     { $.equal(7); }
                | "8"     { $.equal(8); }
                | "9"     { $.equal(9); }
                | "A"     { $.equal(10); }
                | "B"     { $.equal(11); }
                | "C"     { $.equal(12); }
                | "D"     { $.equal(13); }
                | "E"     { $.equal(14); }
                | "F"     { $.equal(15); }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="equal" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ED"/>
                        </mif:object> data type.
						The value property is not included in the equality test.<mif:object name="footnote">
								This means that values of the type UUID, UID, OID, RUID, ST, SC, and ED may be equal.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ED"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="RUID" title="HL7ReservedIdentifierScheme" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="UID"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A globally unique string defined exclusively by HL7. Identifiers in
					this scheme SHALL only be defined by balloted HL7 specifications. Local
					communities or systems SHALL never use such reserved identifiers based
					on bilateral negotiations.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					HL7 reserved identifiers are strings that consist only of (US-ASCII)
					letters and digits, where the first character SHALL be a
					letter. HL7 may assign these reserved identifiers as mnemonic
					identifiers for major concepts of interest to HL7. RUID's are case 
					sensitive; the case assigned to the identifier by HL7 will be used.
				</mif:p>
                  <mif:p>
					HL7 has reserved the RUID scheme for future use, but at this time there are no plans
					to make use of them, as <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="OID"/>
                     </mif:object>s and <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="UUID"/>
                     </mif:object>s have met all
					requirements so far identified.    
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type HL7ReservedIdentifierScheme alias RUID specializes UID;</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="equal" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ED"/>
                        </mif:object> data type.<mif:object name="footnote">
						This means that values of the type RUID, UID, ST, SC, and ED may be equal.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ED"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="II" title="InstanceIdentifier" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An identifier that uniquely identifies a thing or object. Examples
					are object identifier for HL7 RIM objects, medical record number,
					order id, service catalog item id, Vehicle Identification Number
					(VIN), etc. 
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					Note that a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> does not identify the type of the object being identified, or 
					the type of the association between the object and the identifier - it is only
					the identifier itself. <mif:object name="footnote">HL7 is preparing a document that contains common usage patterns that
					will discuss how to best use the II type in common healthcare identification use cases.</mif:object>
                  </mif:p>
                  <mif:p>
					In order to simplify processing, when the root or extension properties have some nullFlavor other than 
					NotApplicable, the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> itself must have some kind of nullFlavor.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type InstanceIdentifier alias II specializes ANY {
      UID        root;
      ST.SIMPLE  extension;
      ST.NT      identifierName;
      CS         scope;
      CS         reliability;
      BL         displayable;
  literal ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(II x) {
   root.isNull.and(root.notApplicable.not).implies(x.isNull);
   extension.isNull.and(extension.notApplicable.not).implies(x.isNull);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="root" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Root"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A unique identifier that guarantees the global uniqueness of the
						instance identifier. The root alone may be the entire instance
						identifier.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						In the presence of a non-null extension, the root is the unique identifier for
						the "namespace" of the identifier in the extension. Note that this does NOT
						necessarily correlate with the organization that manages the issuing of the
						identifiers.  A given organization may manage multiple identifier namespaces,
						and control over a given namespace may transfer from organization to organization
						over time while the root remains the same.<mif:object name="footnote">
								DICOM objects are identified by UID only. For the purpose of DICOM/HL7
								integration, it would be awkward if HL7 required the extension to be
								mandatory and to consider the UID only as an assigning
								authority. Since UID values are simpler and do not contain the risks
								of containing meaningless decoration, we do encourage systems to use
								simple UID identifiers as external references to their objects.
							</mif:object>
                     </mif:p>
                     <mif:p>
						In situations where an extension is known, but the root is not known, the II should be populated with a 
						nullFlavor "Unknown", a null root, and an extension with the value. These situations may arise when 
						identifiers such as driver's license or passport numbers are collected without ascertaining which 
					    authority issued them, or with point-of-care devices that contain a simple bar code scanner. In some
					    of these cases, it may be possible to create a new <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> with a known root at a later time.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(II x)
      where x.nonNull {
   root.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="UID"/>
      </mif:property>
      <mif:property name="extension" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Extension"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A character string as a unique identifier within the scope of the
						identifier root.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The extension is a character string that is unique in the namespace
						designated by the root. If a non-NULL extension exists, the root
						specifies a namespace (sometimes called "assigning authority" or
						"identifier type").  The extension property MAY be Not Applicable in which case
						the root <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="OID"/>
                        </mif:object> is the complete unique identifier. If
						the root is not a complete unique identifier, and the extension is not 
						known, then the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> SHALL have a null value even if the root is 
						populated.
					</mif:p>
                     <mif:p>
						The root and extension scheme means that the concatenation
						of root and extension SHALL be a globally unique identifier for the
						item that this II value identifies.
					</mif:p>
                     <mif:p>
						It is recommended that systems use the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="OID"/>
                        </mif:object> scheme for external
						identifiers of their communicated objects. The extension property is
						mainly provided to accommodate legacy alphanumeric identifier schemes.
					</mif:p>
                     <mif:p>
						Some identifier schemes define certain style options to their code
						values. For example, the U.S. Social Security Number (SSN) is normally
						written with dashes that group the digits into a pattern
						"123-12-1234". However, the dashes are not meaningful and a SSN can
						just as well be represented as "123121234" without the dashes.
					</mif:p>
                     <mif:p>
						In the case where identifier schemes provide for multiple
						representations, HL7 will make a ruling about which is the preferred
						form and document that ruling where that respective external
						identifier scheme is recognized. HL7 will decide upon the preferred
						form based on criteria of practicality and common use. In absence of
						clear criteria of practicality and common use, the safest, most
						extensible, and least stylized (the least decorated) form SHALL be
						given preference.<mif:object name="footnote">
								This ruling at design-time is necessary to prevent HL7 interfaces from
								being burdened by identifier literal style conversions at
								runtime. This is notwithstanding the fact that some applications may
								require mapping from one form into another if that application has
								settled with the representation option that was not chosen by HL7.
							
								From practical experience it is recommended that II.extensions as
								an alphanumeric identifier not contain leading zero digits (if any
								zeroes at all), for these are often erroneously stripped. "000123"
								and "123" would be different extension values, but this is prone
								to be misunderstood, leading to false non-matches and duplicate
								record entries. However applications should maintain any leading zero
								digits encountered in II extensions. Leading zero digits are
								prohibited in 's, but may occur in 's,
								where they must be maintained.
							
								There is no separate check digit property. Check digits are used
								for human purpose and work best if kept completely transparent.
								II.extensions MAY contain check digits anywhere, and the
								particular check digit scheme (if any) would be implied by the
								II.root. However, a separate check digit property is intentionally
								not recognized by this specification.
							</mif:object>
						In the absence of a preferred form or ruling, implementers should omit all non-significant separators when performing semantic equality checks.
					</mif:p>
                     <mif:p>
						HL7 MAY also decide to map common external identifiers to the value
						portion of the II.root <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="OID"/>
                        </mif:object>. For example, the U.S. SSN could be
						represented as 2.16.840.1.113883.4.1.123121234. The criteria of
						practicality and common use will guide HL7's decision on each
						individual case.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(II x)
      where x.extension.isNull {
   x.notApplicable().not.implies(x.isNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="identifierName" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Identifier Name"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						This is a human-readable name for the namespace represented in the root. It is a
						descriptive name for the actual namespace. e.g. "California, U.S. Driver's License Number, 1970-".
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						IdentifierName does NOT refer to the organization which issued the identifier (e.g. California Dept. of
						Motor Vehicles). It is intended for use as a human readable label when an identifier must be
						displayed to a human user where an OID would not be meaningful. In general, it should only be
						used when an extension is present, allowing for a display such as "California, U.S. Driver's
						License Number, 1970-: 123456789". There are absolutely no guidelines for the contents of this
						text other than it should be completely descriptive of the namespace. E.g. "Driver's License"
						or even "California Driver's License" would not be ideal. However, formatting, capitalization,
						whitepace, language, etc. are completely up to the sender. 
					</mif:p>
                     <mif:p>
						The Identifier Name has no computational value. <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> can
						never modify the meaning of <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="root"/>
                           <mif:param name="datatypeName" value="II"/>
                        </mif:object>. The purpose of a Identifier
						Name is to assist an unaided human interpreter of an II value to interpret the identifier.
						Applications SHALL NOT attempt to perform any decision-making, matching, filtering or other
						processing based on this presence or value of this property. It is for display and development
						assistance only. All decision logic SHALL be based solely on the root and extension properties.
						Conformant  systems MAY choose not to implement <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> but SHALL NOT reject 
						instances because <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is present.						
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST.NT"/>
      </mif:property>
      <mif:property name="scope" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Scope"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Specifies the scope in which the identifier applies to the object with which it is associated.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="IdentifierScope"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="reliability" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Reliability"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Specifies the reliability with which the identifier is known. This attribute MAY be used to assist with identifier matching algorithms.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="IdentifierReliability"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="displayable" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Displayable"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
                     Specifies if the identifier is intended for human
                     display and data entry (displayable = true) as
                     opposed to pure machine interoperation (displayable
                     = false).
                  </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                  	Conformant systems MAY choose not to implement <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> but SHALL NOT reject 
						instances because <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is present.
                  </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="equal" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two non-null instance identifiers are equal if and only if their root is equal, and
						their extensions are both null or equal.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(II x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.root.equal(y.root)
             .and(x.extension.notApplicable.and(y.extension.notApplicable).or(x.extension.equal(y.extension))));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="literal" sortKey="08" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The literal representation for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> provides a representation for
						the extension and root properties since they are the properties needed
						to test for equality.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
II.literal ST.SIMPLE {
   UID ":" ST { 
      $.root.equal($1).and($.extension.equal($3)); 
   }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="URL" title="UniversalResourceLocator" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A telecommunications address specified according to Internet standard
					RFC 2396 [<mif:a href="http://www.ietf.org/rfc/rfc2396.txt"/>]. The
					URI specifies the protocol and the contact point defined by that
					protocol for the resource.  Notable uses of the telecommunication
					address data type are for telephone and telefax numbers, e-mail
					addresses, Hypertext references, FTP references, etc.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					The Internet standard RFC 2396 [<mif:a href="http://www.ietf.org/rfc/rfc2396.txt"/>] defines a URI as
					follows:
				</mif:p>
                  <mif:blockquote>
                     <mif:p>
						Just as there are many different methods of access to resources, there
						are several schemes for describing the location of such resources.
						The generic syntax for URLs provides a framework for
						new schemes to be established using protocols other than those defined
						in this document.
					</mif:p>
                     <mif:p>
						URLs are used to "locate" resources, by providing an abstract
						identification of the resource location. Having located a resource, a
						system may perform a variety of operations on the resource, as might
						be characterized by such words as "access", "update", "replace", "find
						attributes". In general, only the "access" method needs to be
						specified for any URL scheme.
					</mif:p>
                     <mif:p>
						By agreement, it is permissable to use a URI in place of a URL. In these
						cases, the resources identified SHOULD be accessible
						by some agreed method. A common use of URI's is to refer to SOAP attachments.
					</mif:p>
                  </mif:blockquote>
                  <mif:p>
				  Applications SHALL ignore separator characters when comparing <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s with tel: scheme.  
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type UniversalResourceLocator alias URL specializes ANY {
   CS         scheme;
   ST.SIMPLE  address;
   literal    ST.SIMPLE;
   URL        canonical;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="scheme" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Scheme"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Identifies the protocol used to interpret the address string and 
						to access the resource so addressed.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Some URL schemes are registered by the <mif:b>Internet Assigned Numbers
						Authority</mif:b> (IANA) [http://www.iana.org], however IANA only
						registers URL schemes that are defined in Internet RFC documents. In
						fact there are a number of URL schemes defined outside RFC documents,
						some of which are registered with the World Wide Web Consortium
						(W3C).<mif:object name="footnote">
								The data type of the  is still  and for
								HL7 purposes, the  is a CNE domain. This appears to be
								at odds with the fact that there is no one official list of URL
								schemes, and so many URL schemes in use may be defined locally.
								However, we cannot allow extension of the  scheme
								using the HL7 mechanism of local alternative code systems, which is
								why technically the  is a  data type.
							</mif:object>
                     </mif:p>
                     <mif:p>
						Note that while URIs and URLs can be used for all sorts of purposes,
						this specification explicitly limits itself to locatable resources.<mif:object name="footnote">
								The W3C definitions of URL and URI are changing. Refer to 
								[] for
								further discussion.
							</mif:object>. Locatable means that the definition of the scheme SHALL
						clearly establish how to locate and access the resource without 
						implementors needing to consult local agreements to determine how 
						the resource is to be accessed. 
					</mif:p>
                     <mif:div title="HL7 Attachment Resolution">ht7-att
							The scheme hl7-att is used to make references to HL7 Attachments. HL7 attachments
							may be located in the instance itself as an attachment on the Message class, or 
							in some wrapping entity such as a MIME package, or stored elsewhere.
						
							The following rules are required to make the hl7-att scheme work:
						
								
									Attachments SHALL be globally uniquely identified. Attachment id is mandatory, and
									an ID SHALL never be re-used. Once assigned, an attachment id SHALL be accosiated
									with exactly one byte-stream as defined for ED.data.
								
							
								
									When receiving an attachment, a receiver SHOULD store that attachment for later
									reference. A sender is not required to resend the same attachment if the attachment
									has already been sent.
								
							
								
									Attachment references SHALL be resolved against all stored attachments using the
									globally unique attachment identifier in the address.
								
								
										When attempting to resolve an attachment reference receiver may need to be able to deal with references to attachments
										that have not been seen previously and will occur later in the document currently being processed. Forward references
										are allowed within an instance, as defined by the applicable ITS, but not to other message instances. 
									
							
							Applications MAY declare conformance to the HL7 Attachment Resolution Protocol, in which case they
							SHALL conform to the rules above. The rules are not mandatory for other applications. The hl7-att scheme
							should only be expected to work with applications that conform to the HL7 Attachment Resolution Protocol.
						</mif:div>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="URLScheme"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="address" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Address"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The address is a character string whose format is entirely defined by
						the <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="scheme"/>
                        <mif:param name="datatypeName" value="URL"/>
                     </mif:object>.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="literal" sortKey="03" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						While conceptually URL has the properties scheme and address,
						the common appearance of a URL is as a string literal formed according
						to the Internet standard. The general syntax of the URL literal is:
					</mif:p>
                     <mif:p>
						Note that there is no special data type for telephone numbers,
						telephone numbers are <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TEL"/>
                        </mif:object>s and are specified as <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>s.
					</mif:p>
                     <mif:p>
						The telephone number <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is defined in Internet RFC 2806
						[<mif:a href="http://www.ietf.org/rfc/rfc2806.txt"/>]. Its definition is
						summarized in this subsection. This summary does not override or
						change any of the Internet specification's rulings.
					</mif:p>
                     <mif:p>
						The <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="address"/>
                           <mif:param name="datatypeName" value="URL"/>
                        </mif:object> is the telephone number in
						accordance with ITU-T E.123 <mif:b>Telephone Network and ISDN
						Operation, Numbering, Routing and Mobile Service: Notation for
						National and International Telephone Numbers (1993)</mif:b>. While HL7
						does not add or withdraw from the URL specification, the preferred
						subset of the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="address"/>
                           <mif:param name="datatypeName" value="URL"/>
                        </mif:object> address syntax is
						given as follows:
					</mif:p>
                     <mif:p>
						The global absolute telephone numbers starting with the "+" and
						country code are preferred. Separator characters serve as decoration
						but have no bearing on the meaning of the telephone number. For
						example: "tel:+13176307960" and "tel:+1(317)630-7960" are both the
						same telephone number.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
URL.literal ST.SIMPLE {
   URL : /[a-z0-9+.-]+/ ":" ST   { $.scheme.equal($1);
                                   $.address.equal($3); }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
protected type TelephoneURL alias TelURL specializes URL {
   literal ST.SIMPLE {
      URL                 : /(tel)/ ":" address   { $.scheme.equal($1);
                                                          $.address.equal($3); };
      ST address          : "+" phoneDigits
      ST phoneDigits      : digitOrSeparator phoneDigits
                          | digitOrSeparator
      ST digitOrSeparator : digit
                          | separator;
      ST digit            : /[0..9]/;
      ST separator        : /[().-]/;
      };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="canonical" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Canonical"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> with any separator or other non-significant characters stripped out of the address. 
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
					    The actual characters stripped out depends on the scheme.
					    
						The tel: syntax allows for characters such as () which are syntactical separator characters but
						do not change the actual telephone number. <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> strips characters like these out of the 
						address portion.
						
						The email: syntax allows for the inclusion of non-semantic comment in "phrases" and "comments".
						These are removed in the canonical form. Consult RFC 2368 [<mif:a href="http://www.ietf.org/rfc/rfc2368.txt"/>]
						and RFC 822 [<mif:a href="http://www.ietf.org/rfc/rfc822.txt"/>] for further information. Headers are 
						also removed.  
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="URL"/>
      </mif:property>
      <mif:property name="equal" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two nonNull <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>s are equal if they have the same scheme and canonical address.
						If the address is not known, then it is not known whether the addresses are equal.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(URL x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.scheme.equal(y.scheme).and(x.canonical.address.equal(y.address.canonical)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="URL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TEL" title="TelecommunicationAddress" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="URL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A locatable resource that is identified by a URI. The address is specified as a Universal Resource 
					Identifier (URL) qualified by time specification and use codes that 
					help in deciding which address to use for a given time and purpose.
					TEL may be used to designate a retrievable resource such as a web 
					page, a telephone number (voice, fax or some other resource mediated 
					by telecommunication equipment), an e-mail address, or any other locatable
					resource that can be specified by a URL.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					The semantics of a telecommunication address is that a communicating
					entity (the responder) listens and responds to that address, and
					therefore can be contacted by an other communicating entity (the
					initiator).
				</mif:p>
                  <mif:p>
					The responder of a telecommunication address may be an automatic
					service that can respond with information (e.g., FTP or HTTP
					services).  In such case a telecommunication address is a reference to
					that information accessible through that address. A telecommunication
					address value can thus be resolved to some information (in the form of
					encapsulated data, <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ED"/>
                     </mif:object>).
				</mif:p>
                  <mif:p>
					The telecommunication address is an extension of the Universal
					Resource Locator (<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="URL"/>
                     </mif:object>) specified according to Internet
					standard RFC 2396 [<mif:a href="http://www.ietf.org/rfc/rfc2396.txt"/>].
					The <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="URL"/>
                     </mif:object> specifies the protocol and the contact point
					defined by that protocol for the resource. Notable use cases for the
					telecommunication address data type are for telephone and fax numbers,
					e-mail addresses, Hypertext references, FTP references, etc.
				</mif:p>
                  <mif:div title="Examples for TEL">telexamples
						The first example shows a combination work and home phone number.
					
&lt;tel value="tel:+15556755745" use="H WP"/&gt;
						The second example shows a combination work phone number with optional separators and 
						an extension 545.
					
&lt;tel value="tel:+1(555)6755745;postd=545" use="WP"/&gt;
						Note that extensions are not the only use for the post-dial sequence. Consult RFC 2806
						[] for further details. The canonical
						form of this example is:
					
&lt;tel value="tel:+15556755745;postd=545" use="WP"/&gt;</mif:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type TelecommunicationAddress alias TEL specializes URL {
   DSET&lt;CS&gt; use;
   DSET&lt;CS&gt; capabilities;
   GTS      useablePeriod;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="use" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Use Code"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						One or more codes advising a system or user which telecommunication
						address in a set of like addresses to select for a given
						telecommunication need.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							The telecommunication use code is not a complete classification for
							equipment types or locations. Its main purpose is to suggest or
							discourage the use of a particular telecommunication address. There
							are no easily defined rules that govern the selection of a
							telecommunication address.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="DSET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="TelecommunicationAddressUse"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="capabilities" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Telecommunication Equipment Capabilities"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
				    	One or more codes advising a system or user what telecommunication capabilities
				    	are known to be associated with the telecommunication address. 
				    </mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="DSET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="TelecommunicationCapabilities"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="useablePeriod" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Useable Period"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Specifies the periods of time during which the telecommunication
						address can be used.  For a telephone number, this can indicate the
						time of day in which the party can be reached on that telephone.  For
						a web address, it may specify a time range in which the web content is
						promised to be available under the given address.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="GTS"/>
      </mif:property>
      <mif:property name="equal" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="URL"/>
                        </mif:object> data type. The use and useablePeriod properties
						are excluded from the equality test.<mif:object name="footnote">
								This means that values of the type URL and TEL may be equal.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ADXP" title="AddressPart" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SC.NT"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A character string that may have a type-tag signifying its role in the
					address. Typical parts that exist in about every address are street,
					house number, or post box, postal code, city, country but other roles
					may be defined regionally, nationally, or on an enterprise level
					(e.g. in military addresses). Addresses are usually broken up into
					lines, which are indicated by special line-breaking delimiter elements
					(e.g., DEL).
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type AddressPart alias ADXP specializes SC.NT {
   CS  partType;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="partType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Address Part Type"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Specifies whether an address part names the street, city, country,
						postal code, post box, etc. If the type is NULL the address part is
						unclassified.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
					   The hierarchical nature of this code system shows composition. E.g. "Street Name" is part of "Street Address Line"
					</mif:p>
                     <mif:p>
					  Some Address Part Types are associated with a Domain, and the code of SC may be valued in these cases. 
					  If no Domain is associated with the address part type, then the code may not be valued. The text 
					  content of the part is not restricted by the vocabulary domain unless constrained in this way by a realm.
					</mif:p>
                     <mif:table width="90%">
                        <mif:caption>Domain Mappings for Part Type</mif:caption>
                        <mif:col width="200" span="1"/>
                        <mif:col width="300" span="1"/>
                        <mif:thead>
                           <mif:tr>
                              <mif:th>Part Type</mif:th>
                              <mif:th>Concept Domain</mif:th>
                           </mif:tr>
                        </mif:thead>
                        <mif:tbody>
                           <mif:tr>
                              <mif:td>UNIT</mif:td>
                              <mif:td>AddressPartUnitType</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>DINST</mif:td>
                              <mif:td>AddressPartDeliveryInstallationType</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>DMOD</mif:td>
                              <mif:td>AddressPartDeliveryMode</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>STTYP</mif:td>
                              <mif:td>AddressPartStreetType</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>CNT</mif:td>
                              <mif:td>Country</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>STA</mif:td>
                              <mif:td>AddressPartState</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>CPA</mif:td>
                              <mif:td>AddressPartCounty</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>CTY</mif:td>
                              <mif:td>AddressPartCity</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>DIR</mif:td>
                              <mif:td>AddressPartDirection</mif:td>
                           </mif:tr>
                        </mif:tbody>
                     </mif:table>
                     <mif:p>
						The concept domain Country is bound to ISO 3166. ISO 3166 is a code system with the
						OID 1.0.3166.1.2 that defines 2 letter, 3 letter, and numerical codes for each country. HL7
						defines a universal value set with the OID [oid] that includes all 3 types of code, so 
						that all 3 types of code may be used. Realms are able to restrict the use of country 
						to a particular type of code by binding the domain Country to a more restrictive 
						value set.
					</mif:p>
                     <mif:p>
					  The other concept domains are not bound
					  to any particular value set or code system, but realms may specify particular bindings.
					  Note that ISO 3166 also specifies country sub-divisions, and realms should consider 
					  using these sub-divisions where possible. 
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="AddressPartType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="language" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Language"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The human language of the address part, if known and relevant.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						While values of type <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> may be assigned a language, the meaning of the part is not 
						dependent on the language, and applications SHALL not be required to indicate the linguistic origin of 
						any address part. Like <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ST"/>
                        </mif:object>, language is not part of the equality
						test for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="HumanLanguage"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="equal" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two nonNull <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>s are equal if they have the same partType, and
						if the other <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ED"/>
                        </mif:object> equality criteria are met.<mif:object name="footnote">
								This means that values of the values of the type ADXP can not be equal with ED, ST, or SC values.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ADXP x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.partType.equal(y.partType).and(((ED)x).equal((ED)y)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ADXP"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="AD" title="PostalAddress" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="ADXP"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					Mailing and home or office addresses. A sequence of address parts,
					such as street or post office box, city, postal code, country, etc.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is primarily used to communicate data that will allow
					printing mail labels, that will allow a person to physically visit
					that address. The postal address data type is not supposed to be a
					container for additional information that might be useful for finding
					geographic locations (e.g., GPS coordinates) or for performing
					epidemiological studies. Such additional information is captured by
					other, more appropriate HL7 elements.
				</mif:p>
                  <mif:p>
					Addresses are conceptualized as text with added logical mark-up. The
					mark-up may break the address into lines and may describe in detail
					the role of each address part if it is known. Address parts occur in
					the address in the order in which they would be printed on a mailing
					label. The approach is similar to HTML or XML markup of text (but it
					is not technically limited to XML representations).
				</mif:p>
                  <mif:p>
					Addresses are essentially sequences of address parts, but add a "use"
					code and a valid time range for information about if and when the
					address can be used for a given purpose.
				</mif:p>
                  <mif:p>
						The correct presentation order of the parts is realm dependent and may not be the same between addresses 
						from different countries or realms. Patients regularly travel between realms, so realm specified ordering
						and constraints need to account for addresses from other realms as well. 
					</mif:p>
                  <mif:div title="AD Examples">ADExamples
						For examples of names, please consult the ISO datatypes [to do: what reference?].
					</mif:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type PostalAddress alias AD specializes LIST&lt;ADXP&gt; {
   DSET&lt;CS&gt; use;
   GTS      useablePeriod;
   BL       isNotOrdered;
   ST.NT    formatted;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="use" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Use Code"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A set of codes advising a system or user which address in a set of
						like addresses to select for a given purpose.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						An address without specific use code might be a default address useful
						for any purpose, but an address with a specific use code would be
						preferred for that respective purpose.
					</mif:p>
                     <mif:p>
						An address with a use of "H" and a nullFlavor of NotApplicable means that the concept of 
						a home address does not apply; i.e. that a person has no fixed place of abode.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="DSET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="PostalAddressUse"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="useablePeriod" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Useable Period"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A General Timing Specification (GTS) specifying the periods of time
						during which the address can be used.  This is used to specify
						different addresses for different times of the week or year.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="GTS"/>
      </mif:property>
      <mif:property name="isNotOrdered" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Is Not Ordered"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A boolean value specifying whether the order of the address parts is known
						or not. While the address parts are always a Sequence, the order in which
						they are presented may or may not be known. Where this matters, the
						isNotOrdered property can be used to convey this information.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The default isNotOrdered is false: the order of address parts is considered meaningful by default.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="equal" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two address values are considered equal if both contain the same
						address parts, independent of ordering. Use code, useablePeriod, and isNotOrdered are
						excluded from the equality test. <mif:object name="footnote">
						   This definition follows from the semantics of the address; Although some delivery systems may become
						   confused if the parts are re-ordered, especially in the absense of the part type semantics (for
						   instance in a formatted literal address), it is not possible to change from one valid address to
						   a different valid address by reordering the parts; for this reason equality simply depends on the
						   parts, in any order, irrespective of the valid time, use or IsNotOrdered flag.
						</mif:object>
                     </mif:p>
                     <mif:p>
						Note that two values that refer to the same address but that are encoded using different address parts 
						(perhaps to different levels of detail) would not be considered equal.						
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(AD x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal((
      forall(ADXP p) where x.contains(p) {
	     y.contains(p);
	     }).and(
            forall(ADXP p) where y.contains(p) {
	           x.contains(p);
	           }));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="formatted" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Formatting Address"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A character string value with the address formatted in lines and with
						proper spacing. This is only a semantic property to define the
						function of some of the address part types.<mif:object name="footnote">
								Remember that semantic properties are bare of all control flow
								semantics. The  could be implemented
								as a "procedure" that would "return" the formatted address, but it
								would not usually be a variable to which one could assign a formatted
								address. However, HL7 does not define applications but only the
								semantics of exchanged data values. Hence, the semantic model
								abstracts from concepts like "procedure", "return", and "assignment"
								but speaks only of property and value.
							</mif:object>
                  </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>'s main purpose is to capture postal addresses,
						such that one can visit that address or send mail to it. Humans will
						look at addresses in printed form, such as on a mailing label. The
						<mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> data type defines precise rules of how its data is
						formatted.<mif:object name="footnote">
								These rules for formatting addresses are part of the semantics of
								addresses because addresses are primarily defined as text displayed or
								printed and consumed by humans. Other uses (e.g., epidemiology) are
								secondary â although not forbidden, the AD
								data type might not serve these other use cases very well, and HL7
								defines better ways to handle these use cases. Note that these
								formatting rules are not ITS issues, since this formatting applies
								to presentations for humans whereas ITS specifications are
								presentations for computer interchange.
							</mif:object>
                     </mif:p>
                     <mif:p>
						Addresses are ordered lists of address parts. Each address part is
						printed in the order of the list from left to right and top to bottom
						(or in any other language-related reading direction, which to
						determine is outside the scope of this specification).  Every address
						part value is printed. Most address parts are framed by white
						space. The following six rules govern the setting of whitespace.
					</mif:p>
                     <mif:ol>
                        <mif:li/>
                        <mif:li/>
                        <mif:li/>
                        <mif:li/>
                        <mif:li/>
                        <mif:li/>
                     </mif:ol>
                     <mif:p>
						This means that all address parts are generally surrounded by white
						space, but whitespace does never accumulate. Delimiters are never
						surrounded by implicit whitespace and every whitespace contributed
						by preceding or succeeding address parts is discarded, whether it was
						implicit or explicit.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ST.NT"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ENXP" title="EntityNamePart" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SC.NT"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A character string token representing a part of a name. May have a
					type code signifying the role of the part in the whole entity name,
					and a qualifier code for more detail about the name part type.
					Typical name parts for person names are given names, and family names,
					titles, etc.
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type EntityNamePart alias ENXP specializes SC.NT {
   CS       partType;
   DSET&lt;CS&gt;  qualifier;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="partType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Name Part Type"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Indicates whether the name part is a given name, family name, prefix,
						suffix, etc.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Not every name part must have a type code; if the type code is
						unknown, not applicable, or simply undefined this is expressed by a
						NULL value (type.isNull). For example, a name may be "Rogan Sulma" and
						it may not be clear which one is a given name or which is a last name,
						or whether Rogan may be a title.
					</mif:p>
                     <mif:p>
						When a name is hyphenated, such as Mary-Ann, it may be ambigious whether
						to use a delimiter separating two name parts, or a single name part with 
						a hyphen in it. As a rule of thumb, if each name part should contribute an
						initial when the name is presented as initials, then a delimiter SHOULD be 
						used to separate two parts.
					</mif:p>
                     <mif:p>
						Entity names are conceptualized as text with added mark-up. The
						mark-up may describe in detail the role of each name part if it is
						known. Name parts occur in the order in which they would be printed on
						a mailing label. The model is similar to HTML or XML markup of text.
					</mif:p>
                     <mif:p>
					  Some Entity Name Part Types are associated with a Domain, and the code of SC may be valued in these cases. 
					  If no Domain is associated with the address part type, then the code may not be valued. The text 
					  content of the part is not restricted by the vocabulary domain unless constrained in this way by a realm.
					</mif:p>
                     <mif:table width="90%">
                        <mif:caption>Domain Mappings for Part Type</mif:caption>
                        <mif:col width="200" span="1"/>
                        <mif:col width="300" span="1"/>
                        <mif:thead>
                           <mif:tr>
                              <mif:th>Part Type</mif:th>
                              <mif:th>Domain</mif:th>
                           </mif:tr>
                        </mif:thead>
                        <mif:tbody>
                           <mif:tr>
                              <mif:td>PFX</mif:td>
                              <mif:td>EntityNamePrefix</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>SFX</mif:td>
                              <mif:td>EntityNameSuffix</mif:td>
                           </mif:tr>
                        </mif:tbody>
                     </mif:table>
                     <mif:p>
					  These domains are not bound to any particular value set, but realms may specify particular bindings.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="EntityNamePartType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="qualifier" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Qualifier"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The qualifier is a set of codes each of which specifies a certain
						subcategory of the name part in addition to the main name part type.
						For example, a given name may be flagged as a nickname, a family name
						may be a pseudonym or a name of public records.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
					    The following table summarizes which qualifiers may be used with which part types:
					</mif:p>
                     <mif:table hl7Id="EN-use-qualifier-combinations">
                        <mif:caption>PartType &amp; Qualifier Combinations</mif:caption>
                        <mif:col width="10" span="1"/>
                        <mif:col width="10" span="1"/>
                        <mif:col width="10" span="1"/>
                        <mif:col width="10" span="1"/>
                        <mif:col width="10" span="1"/>
                        <mif:col width="10" span="1"/>
                        <mif:thead>
                           <mif:tr>
                              <mif:td>Â </mif:td>
                              <mif:td>FAM (Family)</mif:td>
                              <mif:td>GIV (Given)</mif:td>
                              <mif:td>TITLE</mif:td>
                              <mif:td>DEL (Delimiter)</mif:td>
                              <mif:td>null</mif:td>
                           </mif:tr>
                        </mif:thead>
                        <mif:tbody>
                           <mif:tr>
                              <mif:td>LS (Legal Status)</mif:td>
                              <mif:td/>
                              <mif:td/>
                              <mif:td>â¡</mif:td>
                              <mif:td/>
                              <mif:td>â¡ </mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>BR (Birth)</mif:td>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td/>
                              <mif:td/>
                              <mif:td>â¡ </mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>AD (Acquired)</mif:td>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td/>
                              <mif:td/>
                              <mif:td>â¡ </mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>SP (Spouse)</mif:td>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td>â¡ </mif:td>
                              <mif:td/>
                              <mif:td/>
                              <mif:td>â¡ </mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>MID (Middle Name)</mif:td>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td/>
                              <mif:td/>
                              <mif:td>â¡ </mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>CL (Call Me)</mif:td>
                              <mif:td>â¡ </mif:td>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td/>
                              <mif:td/>
                              <mif:td>â¡ </mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>IN (initial)</mif:td>
                              <mif:td>â¡â¡ </mif:td>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td/>
                              <mif:td/>
                              <mif:td>â¡ </mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>PFX (Prefix)</mif:td>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td/>
                              <mif:td>â¡ </mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>SFX (Suffix)</mif:td>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td/>
                              <mif:td>â¡ </mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>AC (academic)</mif:td>
                              <mif:td/>
                              <mif:td/>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td/>
                              <mif:td>â¡ </mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>PR (professional)</mif:td>
                              <mif:td/>
                              <mif:td/>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td/>
                              <mif:td>â¡ </mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>NB (nobility)</mif:td>
                              <mif:td/>
                              <mif:td/>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td/>
                              <mif:td>â¡ </mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>HON (Honorific)</mif:td>
                              <mif:td/>
                              <mif:td/>
                              <mif:td>â¡â¡</mif:td>
                              <mif:td/>
                              <mif:td>â¡ </mif:td>
                           </mif:tr>
                        </mif:tbody>
                     </mif:table>
                     <mif:p>â¡ = This combination is allowed.</mif:p>
                     <mif:p>â¡â¡ = This combination is allowed, and it is expected that this combination will be encountered in practice.</mif:p>
                     <mif:p>
						See also the note under <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="use"/>
                           <mif:param name="datatypeName" value="EN"/>
                        </mif:object> for further rules.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="DSET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="EntityNamePartQualifier"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="language" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Language"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The human language of the name part, if known and relevant.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						While values of type <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> may be assigned a language, the meaning of the part is not
						dependent on the language, and applications SHALL not be required to indicate the linguistic origin of
						any name part. Like <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ST"/>
                        </mif:object>, language is not part of the equality
						test for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>.
					</mif:p>
                     <mif:p>
						Values of type <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> do not have any assigned language. Though names may contain
						words and concepts from a particular language, the meaning of the name part is not dependent
						on the language.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ENXP x) {
   x.language.notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="HumanLanguage"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="equal" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two nonNull <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>s are equal if they have the same partType, and
						if the other <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ED"/>
                        </mif:object> equality criteria are met. The
						qualifier property is excluded from the equality test.<mif:object name="footnote">
								This means that values of the values of the type ENXP can not be equal with ED, ST, or SC values.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ENXP x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.partType.equal(y.partType).and(((ED)x).equal((ED)y)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ADXP"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="EN" title="EntityName" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="ENXP"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A name for a person, organization, place or thing. A sequence of name
					parts, such as given name or family name, prefix, suffix, etc.
					Examples for entity name values are "Jim Bob Walton, Jr.", "Health
					Level Seven, Inc.", "Lake Tahoe", etc. An entity name may be as simple
					as a character string or may consist of several entity name parts,
					such as, "Jim", "Bob", "Walton", and "Jr.", "Health Level Seven" and
					"Inc.", "Lake" and "Tahoe".
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					Entity names are conceptualized as text with added logical mark-up.
					Name parts occur in a natural order in which they would be displayed,
					as opposed to in a order detemined by name part. The ordering of the
					name parts is significant a feature that replaces the need for a
					separate "display name" property. Applications may change that
					ordering of name parts to account for their user's customary ordering
					of name parts. The approach is similar to HTML or XML markup of text
					(but it is not technically limited to XML representations).
				</mif:p>
                  <mif:p>
					Entity names are essentially sequences of entity name parts, but add a
					"use" code and a valid time range for information about when the name
					was used and how to choose between multiple aliases that may be valid
					at the same point in time.
				</mif:p>
                  <mif:p>
					The existence of the use and qualifier codes does not mean that names must 
					always be fully encoded. For example, in most contexts, as a matter of cultural 
					practice, prefixes will simply be recorded as part of the family name to which 
					they are corrected. Some specific implementation negotiation may always be 
					required to clarify how to deal with implementations that have different policies 
					about how names are represented using the facilities of the name.
				</mif:p>
                  <mif:div title="EN Examples">ENExamples
						For examples of names, please consult the ISO datatypes [to do: what reference?].
					</mif:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type EntityName alias EN specializes LIST&lt;ENXP&gt; {
      DSET&lt;CS&gt; use;
      IVL&lt;TS&gt;  validTime;
      EN       canonical;
      ST.NT    formatted;
   
  demotion   ST.NT;
  promotion  TN (ST x);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="use" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Use Code"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A set of codes advising a system or user which name in a set of
						names to select for a given purpose.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						A name without specific use code might be a default name useful for
						any purpose, but a name with a specific use code would be preferred
						for that respective purpose.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="DSET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="EntityNameUse"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="validTime" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Valid Time"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						An interval of time specifying the time during which the name is or
						was used for the entity. This accomodates the fact that people change
						names for people, places and things.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>.validTime conforms to the history item data type extension (<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="HXIT"/>
                        </mif:object>) property validTime.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="IVL">
            <mif:argumentDatatype name="TS"/>
         </mif:type>
      </mif:property>
      <mif:property name="canonical" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Canonical"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The Entity Name with a standard ordering imposed on the parts.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
					  The canonical form contains all the part types except for the delimiters, in the following order:
					</mif:p>
                     <mif:ol>
                        <mif:li/>
                        <mif:li/>
                        <mif:li/>
                        <mif:li/>
                        <mif:li/>
                     </mif:ol>
                     <mif:p>
					  Each list of part types SHALL be in the order of the original name except as required to maintain specified prefix and suffix relationships.
					</mif:p>
                     <mif:p>
					  The canonical form is primarily defined for the purposes of defining equality, and may differ from
					  the socially accepted order for the name parts in various cultures around the world.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="EN"/>
      </mif:property>
      <mif:property name="equal" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two name values are considered equal if their canonical forms both contain the same name
						parts in the same order. Use code and valid time are excluded from the equality test.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(EN x, y)
      where x.nonNull.and(y.nonNull) {
   x.isEmpty.and(y.isEmpty).implies(x.equal(y));
   
   x.notEmpty.and(y.notEmpty).and(x.canonical.head.nonNull).implies(
      x.equal(y).equal(x.canonical.head.equal(y.canonical.head).and(x.canonical.tail.equal(y.canonical.tail))));
	  
   x.notEmpty.and(y.notEmpty).and(x.canonical.head.isNull).implies(
      x.equal(y).equal(y.canonical.head.isNull.and(x.canonical.tail.equal(y.canonical.tail))));
};					
</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="formatted" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Formatting Entity Names"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A character string value with the entity name formatted with
						proper spacing. This is only a semantic property to define the
						function of some of the name part types.<mif:object name="footnote">
								Remember that semantic properties are bare of all control flow
								semantics. The  could be implemented
								as a "procedure" that would "return" the formatted name, but it would
								not usually be a variable to which one could assign a formatted
								name. However, HL7 does not define applications but only the semantics
								of exchanged data values. Hence, the semantic model abstracts from
								concepts like "procedure", "return", and "assignment" but speaks only
								of property and value.
							</mif:object>
                  </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>'s main purpose is to capture names of people,
						places, and things (entities), so that one can address and refer to
						these entities in speech and writing. Humans will look at names in
						printed form, such as on a mailing label. <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> therefore defines
						precise rules of how its data is formatted.<mif:object name="footnote">
								These rules for formatting names are part of the semantics of names
								because the name parts have been designed with the important use case
								of displaying and rendering on labels. Note that these formatting
								rules are not ITS issues, since this formatting applies to
								presentations for humans whereas ITS specifications are presentations
								for computer interchange.
							</mif:object>
                     </mif:p>
                     <mif:p>
						Entity names are ordered lists of entity name parts. Each entity name
						part is printed in the order of the list from left to right (or in any
						other language-related reading direction).  Every entity name part
						is printed. Most entity name
						parts are framed by whitespace. The following six rules govern the
						setting of whitespace.
					</mif:p>
                     <mif:ol>
                        <mif:li/>
                        <mif:li/>
                        <mif:li>
                           <mif:b>prefix</mif:b>
                           <mif:b>suffix</mif:b>
                           <mif:b>delimiter</mif:b>
                        </mif:li>
                        <mif:li/>
                        <mif:li/>
                        <mif:li/>
                        <mif:li/>
                     </mif:ol>
                     <mif:p>
						A <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> can be demoted into <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ST"/>
                        </mif:object> by using the formatted
						representation.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(EN x)
      where x.nonNull {
   ((ST)x).equal(x.formatted);
};					
</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.NT"/>
      </mif:property>
      <mif:property name="demotion" sortKey="06" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Demotion to ST"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> can be demoted to <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ST.NT"/>
                        </mif:object> using the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="formatted"/>
                           <mif:param name="datatypeName" value="EN"/>
                        </mif:object> property.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(EN x)
      where x.nonNull {
 x.formatted.equal((ST) x);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.NT"/>
      </mif:property>
      <mif:property name="promotion" sortKey="07" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Promotion of String to Name"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						A <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ST"/>
                        </mif:object>  may be promoted to a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> where the
						equivalent <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> has one part with an unknown type (see the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TN"/>
                        </mif:object>
						flavor).
					</mif:p>
                     <mif:p>
						When <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ST"/>
                        </mif:object> is promoted to <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> and then demoted again,
						the value is preserved.						
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
  ((EN)x).length.equal(1);
  ((EN)x).item(0).type.isNull;
  
  x.equal((ST)((EN)x));  
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ST"/>
         </mif:parameter>
         <mif:type name="TN"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="QTY" title="Quantity" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					The quantity data type is an abstract generalization for all data
					types (1) whose value set has an order relation (less-or-equal) and
					(2) where difference is defined in all of the data type's totally
					ordered value subsets.  The quantity type abstraction is needed in
					defining certain other types, such as the interval and the probability
					distribution.
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
abstract type Quantity alias QTY specializes ANY {
   BL      isComparableTo(QTY x);
   BL      lessOrEqual(QTY x);
   BL      lessThan(QTY x);
   BL      greaterThan(QTY x);
   BL      greaterOrEqual(QTY x);
   TYPE    diffType;
   QTY     minus(QTY x);
   QTY     plus(QTY x);
   ED.TEXT originalText;
   promotion RTO&lt;QTY, INT&gt; (QTY x);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="isComparableTo" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Is Comparable To"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A predicate indicating if this value and the operand can be compared
						as to which is greater than the other.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two quantities are comparable if they are both elements of a common
						totally ordered partition of their data types' value space. The
						definition is based on <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="lessOrEqual"/>
                           <mif:param name="datatypeName" value="QTY"/>
                        </mif:object>.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (QTY x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.isComparableTo(y).equal(x.lessOrEqual(y).or(y.lessOrEqual(x)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="lessOrEqual" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Ordering: less-or-equal"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A predicate expressing an order relation that is reflexive, asymmetric
						and transitive, between this quantity and another quantity.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> relation is defined on any totally ordered partition
						of the quantity data type. A totally ordered partition is a subset of
						the data types's defined values where all elements have a defined
						order (e.g., the integer and real numbers are totally ordered).
					</mif:p>
                     <mif:p>
						By contrast, a partially ordered set is a set where some, but not all
						pairs of elements are comparable through the order relation (e.g., a
						tree structure or the set of physical quantities is a partially
						ordered set).  Two data values <mif:b>x</mif:b> and <mif:b>y</mif:b> of an
						ordered type are comparable (<mif:b>x</mif:b>.isComparableTo(<mif:b>y</mif:b>))
						if the less-or-equal relation holds in either way (<mif:b>x</mif:b>
						â¤ <mif:b>y</mif:b> or <mif:b>y</mif:b> â¤ <mif:b>x</mif:b>).
					</mif:p>
                     <mif:p>
						A partial order relation generates totally ordered subsets whose union
						is the entire set (e.g., the set of all length is a totally ordered
						subset of the set of all physical quantities).
					</mif:p>
                     <mif:p>
						For example, a tree structure is partially ordered, where the root is
						considered less or equal to a leaf, but there may not be an order
						among the leafs. Also, physical quantities are partially ordered,
						since an order exists only among quantities of the same dimension
						(e.g., between two lengths, but not between a length and a time).  A
						totally ordered subset of a tree is a path that transitively connects
						a leaf to the root. The physical dimension of time is a totally
						ordered subset of physical quantities.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (QTY x, y, z)
   where x.nonNull.and(y.nonNull).and(z.nonNull) {
      x.lessOrEqual(x);                                  /* reflexive */
       x.equal(y).not.implies(x.lessOrEqual(y).implies(y.lessOrEqual(x)).not);    /* asymmetric */
      x.lessOrEqual(y).and(y.lessOrEqual(z))
       .implies(x.lessOrEqual(z))                        /* transitive */
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="lessThan" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Ordering: less-than"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A predicate expressing an order relation that is asymmetric and
						transitive, between this quantity and another quantity. The ordering
						is the same as <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="lessOrEqual"/>
                        <mif:param name="datatypeName" value="QTY"/>
                     </mif:object>, but irreflexive.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (QTY x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.lessThan(y).equal(x.lessOrEqual(y)
                .and(x.equal(y).not));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="greaterThan" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Ordering: greater-than"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A predicate expressing an order relation that is asymmetric and
						transitive, between this quantity and another quantity. This
						is the invese of <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="lessThan"/>
                        <mif:param name="datatypeName" value="QTY"/>
                     </mif:object>.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (QTY x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.greaterThan(y).equal(y.lessThan(x));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="greaterOrEqual" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Ordering: greater-or-equal"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A predicate expressing an order relation that is reflexive, asymmetric
						and transitive, between this quantity and another quantity. This is
						the inverse order of <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="lessOrEqual"/>
                        <mif:param name="datatypeName" value="QTY"/>
                     </mif:object>.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (QTY x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.greaterOrEqual(y).equal(y.lessOrEqual(x));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="diffType" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    ownerScope="classifier"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="DifferenceDataType"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The type of the difference between two values of a specific QTY data type. The data type
						of the difference quantity is related to the operand quantities but need not be the same.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is a data type that can express the difference between
						two values for which the ordering relation is defined (i.e., two
						elements of a common totally ordered subset).  For example, the
						difference data type of integer number is integer number, but the
						difference type of point in time is a physical quantity in the
						dimension of time. A difference data type is a totally ordered data
						type.
					</mif:p>
                     <mif:p>
						The type will be some data type that further specializes QTY.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QTY x) {
   x.diffType.implies(QTY);
   x.diffType.equal(QTY).not;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="minus" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Difference"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A quantity expressing the "distance" of this quantity from the operand
						quantity, that must be comparable.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The difference between two quantities has the data type returned by the diffType property of the instance.
						This leads to two different minus operations, one with an operand of the same type as the instance, and
						the other with the diffType of the instance, with the return types of the matching type. When the diffType
						is the same as the dataType, there is only one minus operation.
					</mif:p>
                     <mif:p>
						A difference is defined in an ordered set if it is semantically
						meaningful to state that Î is the difference between the values
						<mif:b>x</mif:b> and <mif:b>y</mif:b>. This difference Î must be
						meaningful independently from the values <mif:b>x</mif:b> and
						<mif:b>y</mif:b>. This independence exists if for all values
						<mif:b>u</mif:b> one can meaningfully derive a value <mif:b>v</mif:b> such
						that Î would also be the difference between <mif:b>u</mif:b> and
						<mif:b>v</mif:b>. The judgment for what is <mif:b>meaningful</mif:b>
						cannot be defined formally.<mif:object name="footnote">
								The quantity data type abstraction corresponds to the notion of
								difference scales in contrast to ordinal scales and ratio scales
								(Guttman and Stevens). A data type with only the order requirement but
								not the difference requirement would be an ordinal. Ordinals are not
								currently defined with a special data type. Instead, ordinals are
								usually coded values, where the underlying code system specifies
								ordinal semantics. CO is the data type expressing thes ordinal
								semantics.
							</mif:object>
                     </mif:p>
                     <mif:p>
						The difference between two values <mif:b>x</mif:b> minus <mif:b>y</mif:b>
						must be defined for all <mif:b>x</mif:b> and <mif:b>y</mif:b> in a common
						totally ordered subset of the data type's value set.
					</mif:p>
                     <mif:p>
						If x and y are not comparable, then the difference will be Null.<mif:object name="footnote">
								Note that the converse may not apply. If the diffType is different to
								the dataType, then minus may still evaluate to a proper value, even though
								the values are not comparable in this case.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QTZ x, y)
     where y.dataType.implies(x.dataType) {
   x.minus(y).datatype.implies(x.diffType);
};

invariant(QTZ x, y)
     where y.dataType.implies(x.diffType) {
   x.minus(y).datatype.implies(x.dataType);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QTY x, y)
      where y.datatype.equal(x.dataType).and(x.isComparableTo(y).Not) {
   x.minus(y).notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="QTY"/>
      </mif:property>
      <mif:property name="plus" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Addition"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The sum of this quantity and its operand. The operand must be of a
						data type that can express the difference between two values of this
						quantity's data type.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						If <mif:var>y</mif:var> is not a valid type for the difference between two
						values of the type of <mif:var>x</mif:var>, the the result of the operation
						will be NULL.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QTY x, y)
      where y.nonNull.and(x.nonNull).and(y.dataType.implies(x.dataType).and(x.isComparableTo(y))) {
   x.plus(y.minus(x)).equal(y);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QTY x, y)
      where y.dataType.implies(x.diffType).not {
   x.plus(y).notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type qualifier="baseDiff"/>
         </mif:parameter>
         <mif:type name="QTY"/>
      </mif:property>
      <mif:property name="originalText" sortKey="09" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Original Text"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
					    The text representation from which the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> was encoded, if such a representation is the source
						of the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>. Original text can be used in a structured user interface to capture what the user
						saw as a representation of the code on the data input screen, or in a situation where the user dictates
						or directly enters text, it is the text entered or uttered by the user.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The originalText is not a substitute for a valid value. If the actual value of the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is not
						valid, then the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> SHALL be null, irrespective of whether originalText has a value or not.
					</mif:p>
                     <mif:p>
							Note that although post-coding is often performed from free text information,
							such as documents, scanned images or dictation, multi-media data is
							explicitly not permitted as original text. Also, the original text
							property is not meant to be a link into the entire source
							document. The link between different artifacts of medical information
							(e.g., document and coded result) is outside the scope of this
							specification and is maintained elsewhere in the HL7 standards. The
							original text SHALL be an excerpt of the relevant information in the
							original sources, rather than a pointer or exact reproduction. Thus
							the original text SHALL be represented in plain text form. In specific
							circumstances, as described in other HL7 specifications, the originalText
							may be a reference to some other text artefact for which the resolution
							scope is clearly described. 
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ED.TEXT"/>
      </mif:property>
      <mif:property name="promotion" sortKey="10" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Promotion of Quantity to Ratio"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							A quantity of can be promoted into a RTO&lt;?, INT&gt; where the type of ? is the 
							type of the quantity itself, and the denominator of the ratio has a value of 1. 
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="RTO">
            <mif:argumentDatatype name="QTY"/>
            <mif:argumentDatatype name="INT"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="QTZ" title="ZeroedQuantity" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					The Zeroed Quantity data type is an abstract generalization for all data
					types where the addition and subtraction operations involve both operands
					and results from the same type, and where the concept of a zero value exists. 
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
abstract type ZeroedQuantity alias QTZ specializes QTY {
   QTZ   minus(QTZ x);
   QTZ   plus(QTZ x);
   BL    isZero;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="diffType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    ownerScope="classifier"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="DifferenceDataType"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p/>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QTZ x) {
   x.diffType.equal(x.dataType)
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="minus" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Difference"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The result of minus has the same data type as the instance.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QTZ x, y) {
   x.minus(y).datatype.implies(x.dataType);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTZ"/>
         </mif:parameter>
         <mif:type name="QTZ"/>
      </mif:property>
      <mif:property name="plus" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Addition"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The operand has the same type as this quantity's data type.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTZ"/>
         </mif:parameter>
         <mif:type name="QTZ"/>
      </mif:property>
      <mif:property name="isZero" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="The Zero-Quantity"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The neutral element in the difference and addition operations, i.e.,
						if a quantity is zero, addition to, or subtraction from any other
						comparable quantity will result in that other quantity.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
					  Zero is the difference between a value and itself.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QTZ x) 
    where x.nonNull {
   x.minus(x).isZero;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="INT" title="IntegerNumber" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTZ"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise numbers
					that are results of counting and enumerating. Integer numbers are
					discrete, the set of integers is infinite but countable.  No arbitrary
					limit is imposed on the range of integer numbers. Two NULL flavors are
					defined for the positive and negative infinity.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					Since the integer number data type includes all of the semantics of
					the mathematical integer number concept, the basic operations plus
					(addition) and times (multiplication) are defined. These operations
					are defined here as characterizing operations in the sense of ISO
					11404, and because these operations are needed in other parts of this
					specification, namely the semantics of the literal form.
				</mif:p>
                  <mif:p>
					The traditional recursive definitions of addition and multiplication
					are due to Grassmann, and use the notion of <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="successor"/>
                        <mif:param name="datatypeName" value="INT"/>
                     </mif:object>.<mif:object name="footnote">
							H. Grassman. Lehrbuch der Arithmetik. 1861. We prefer
							Grassman's original axioms to the Peano axioms, because Grassman's
							axioms work for all integers, not just for natural numbers. Also, "it
							is rather well-known, through Peano's own acknowledgment, that Peano
							borrowed his axioms from Dedekind and made extensive use of
							Grassmann's work in his development of the axioms." (Hao Wang. The
							Axiomatization of Arithmetic. J. Symb. Logic; 1957:22(2); p. 145).
						</mif:object>
                  </mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type IntegerNumber alias INT specializes QTZ {
           INT  successor;
           INT  predecessor;
           INT  plus(QTY x);
           INT  times(INT x);
           INT  negated;
           BL   isNegative;
           BL   nonNegative;
           REAL  dividedBy(REAL x);
           INT  dividedBy(INT x);
           INT  remainder(INT x);
           BL   isOne;
  literal  ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x, o, i)
      where x.nonNull.and(o.isZero) {
   x.lessThan(x.successor);
   x.plus(o).equal(x);
   x.plus(y.successor).equal(x.plus(y).successor);
   x.times(o).equal(o);
   x.times(y.successor).equal(x.times(y)).plus(x);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="successor" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Successor"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value that is greater than this <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value but
						where no <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value exists between this value and its successor.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x, y)
      where x.successor(y) {
   x.lessThan(y).and.not(exists(INT z) {
      x.lessThan(z);
      z.lessThan(y);
      });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="predecessor" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Predecessor"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The inverse of <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="successor"/>
                        <mif:param name="datatypeName" value="INT"/>
                     </mif:object>.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x, y)
      where x.successor(y) {
   x.successor.predecessor.equal(x);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="diffType" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    ownerScope="classifier"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="DifferenceDataType"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The difference between two <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values is also a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> value.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x) {
   x.diffType.implies(INT);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="plus" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Addition"/>
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x, y, o)
      where x.nonNull.and(y.nonNull).and(o.isZero) {
   x.plus(o).equal(x);
   x.plus(y.successor).equal(x.plus(y).successor);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="times" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The result of multiplying this integer with the operand, equivalent to
						repeated additions of this integer.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x, y, i, o)
      where x.nonNull.and(x.isComparableTo(y)).and(o.isZero).and(i.isOne) {
   x.times(o).equal(o);
   x.times(i).equal(x);
   x.times(y.successor).equal(x.times(y)).plus(x);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="negated" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Negation"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The inverse element of the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value, another <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value,
						which, when added to that value yields zero (the neutral element).
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x)
      where x.nonNull {
   x.plus(x.negated).isZero;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="isNegative" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Negative"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A predicate indicating whether this <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is less than zero (not
						non-negative).
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x)
      where x.nonNull {
   x.isNegative.equal(x.nonNegative.not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="nonNegative" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Non-Negative"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A predicate indicating whether the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> zero (neutral element) is
						less or equal to this <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x, o)
      where x.nonNull.and(o.isZero) {
   x.nonNegative.equal(o.lessOrEqual(x));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="dividedBy" sortKey="09" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Standard Division"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The division operation of this integer (dividend) with a real number
						(divisor) to produce a real number value.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT dividend, REAL divisor)
      where dividend.nonNull.and(divisor.nonNull).and(divisor.isZero.not) {
   dividend.isZero.implies(dividend.dividedBy(divisor).isZero);
   dividend.isZero.not.implies(dividend.dividedBy(divisor).equals(dividend.times(divisor.inverted)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="dividedBy" sortKey="10" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Integer Division"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The integer division operation of this integer (dividend) with another
						integer (divisor) is the integer number of times the divisor fits into
						the dividend.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT dividend, divisor, o, i)
      where dividend.nonNull.and(divisor.nonNull).and(divisor.isZero.not).and(o.isZero) {
   dividend.isZero.implies(dividend.dividedBy(divisor).equal(o));
   dividend.isZero.not.implies(dividend.dividedBy(divisor).equal(
      absolute(dividend).minus(absolute(divisor)).dividedBy(absolute(divisor))
                        .successor.times(sign(dividend)
                        .times(sign(divisor)))));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="remainder" sortKey="11" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Remainder"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The remainder of the integer division.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						This definition of the remainder matches the C and Java programming
						languages.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x, y)
      where x.nonNull.and(y.nonNull) {
   x.reminder(y).equal(x.minus(x.dividedBy(z).times(y)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="isOne" sortKey="12" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Neutral Element of Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A predicate indicating if this value is the number one, i.e., the
						neutral element of multiplication. There is exactly one integer
						that has this property.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x, y)
      where x.nonNull.and(y.nonNull) {
   x.isOne.and(y.isOne).implies(x.equal(y));
   x.isOne.and(y.isZero).implies(x.equal(y).not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="literal" sortKey="13" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The literal form of an integer is a simple decimal number, i.e. a
						string of decimal digits.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
INT.literal ST.SIMPLE {
   INT digit : "0"         { $.isZero; }
             | "1"         { $.equal(0.successor); }
             | "2"         { $.equal(1.successor); }
             | "3"         { $.equal(2.successor); }
             | "4"         { $.equal(3.successor); }
             | "5"         { $.equal(4.successor); }
             | "6"         { $.equal(5.successor); }
             | "7"         { $.equal(6.successor); }
             | "8"         { $.equal(7.successor); }
             | "9"         { $.equal(8.successor); };

  INT uint   : digit       { $.equal($1); }
             | uint digit  { $.equal($1.times(9.successor).plus($2)); };

  INT        : uint        { $.equal($1); }
             | "+" uint    { $.equal($2); }
             | "-" uint    { $.equal($2.negated); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="equal" sortKey="14" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two nonNull <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> are equal if they have the same value.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="REAL" title="RealNumber" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTZ"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A scalar magnitude. Typically used whenever quantities are measured,
					estimated, or computed from other real numbers.  The typical
					representation is decimal, where the number of significant decimal
					digits is known as the precision.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					The term "Real number" in this specification is used to mean that
					fractional values are covered without necessarily implying the full
					set of the mathematical real numbers that would include irrational
					numbers such as Ï, Euler's number, etc.<mif:object name="footnote">
							The term "Real" for a fractional number data type originates and is
							well established in the Algol, Pascal tradition of programming
							languages.
						</mif:object>
                  </mif:p>
                  <mif:p>
					This specification offers two choices for a number data type. The
					choice is made as follows: Any number attribute is a real if it is not
					known for sure that it is an integer. A number is an integer if it is
					<mif:b>always</mif:b> counted, typically representing an ordinal
					number. If there are conceivable use cases where such a number would
					be estimated or averaged, it is not always an integer and thus should
					use the Real data type.
				</mif:p>
                  <mif:p>
					The algebraic operations are specified here as characterizing
					operations in the sense of ISO 11404, and because these operations are
					needed in other parts of this specification.
				</mif:p>
                  <mif:p>
					Unlike the integer numbers, the real numbers semantics are not
					inductively constructed but only intuitively described by their axioms
					of their algebraic properties. The completeness axioms are
					intentionally left out so as to make no statement about irrational
					numbers.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type RealNumber alias REAL specializes QTZ {
             INT   precision;
             REAL  negated;
             BL    isOne;
             REAL  times(REAL x);
             REAL  dividedBy(REAL x);
             REAL  inverted;
             REAL  power(REAL x);
  literal    ST.SIMPLE;
  promotion  REAL  (INT x);
  demotion   INT;
};</mif:data>
            </mif:otherAnnotation>
            <mif:otherAnnotation type="ITS-Note">
               <mif:text>
                  <mif:p>
						This specification defines the real number data type in the broadest
						sense possible. However, it does not imply that any conforming ITS or
						implementation must be able to represent the full range of Real
						numbers, which would not be possible in any finite
						implementation. HL7's current use cases for the Real number data type
						are measured and estimated quantities and monetary amounts. These use
						cases can be handled with a restricted Real value space, rational
						numbers, and even just very limited decimals (scaled integers).
						However, we declare the representations of the real value space as
						floating point, rational, scaled integer, or digit string, and their
						various limitations to be out of the scope of this specification.
					</mif:p>
               </mif:text>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="isComparableTo" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Is Comparable To"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The value set of <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is totally ordered.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(REAL x, y)
      where x.nonNull.and(y.nonNull) {
   x.isComparableTo(y);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="diffType" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    ownerScope="classifier"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="DifferenceDataType"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The difference between two <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values is also a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> value.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(REAL x) {
   x.diffType.implies(REAL);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="precision" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Precision of the Decimal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The number of significant digits of the decimal representation.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Precision is formally defined based on the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="literal"/>
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object>.
					</mif:p>
                     <mif:p>
						The precision attribute is only the precision of a decimal digit
						representation, <mif:b>not the accuracy of the real number
						value</mif:b>.
					</mif:p>
                     <mif:p>
						The purpose of the precision property for the real number data type is
						to faithfully capture the whole information presented to humans in a
						number. The amount of decimal digits shown conveys information about
						the uncertainty (i.e., precision and accuracy) of a measured value.
					</mif:p>
                     <mif:p>
						The rules for what digits are significant are as follows:
					</mif:p>
                     <mif:ol>
                        <mif:li/>
                        <mif:li/>
                        <mif:li/>
                     </mif:ol>
                     <mif:table hl7Id="table-REAL.precision.examples">
                        <mif:caption>Examples for the Precision of Real Number Literals.</mif:caption>
                        <mif:thead>
                           <mif:tr>
                              <mif:th>Literal</mif:th>
                              <mif:th>Number of Significant Digits</mif:th>
                           </mif:tr>
                        </mif:thead>
                        <mif:tbody>
                           <mif:tr>
                              <mif:td>2000</mif:td>
                              <mif:td>has 4 significant digits.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>2e3</mif:td>
                              <mif:td>
									has 1 significant digit, used if one would naturally say 
									"2000" but precision is only 1.
								</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>0.001</mif:td>
                              <mif:td>has 4 significant digits.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>1e-3</mif:td>
                              <mif:td>
									has 1 significant digit, use this if one would naturally
									say "0.001" but precision is only 1.
								</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>0</mif:td>
                              <mif:td>has 1 significant digit.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>0.</mif:td>
                              <mif:td>has 1 significant digit.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>0.0</mif:td>
                              <mif:td>has 2 significant digits.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>0.1</mif:td>
                              <mif:td>has 2 significant digits.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>.1</mif:td>
                              <mif:td>has 2 significant digits.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>000.0</mif:td>
                              <mif:td>has 2 significant digits.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>0.00</mif:td>
                              <mif:td>has 3 significant digits.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>4.10</mif:td>
                              <mif:td>has 3 significant digits.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>4.09</mif:td>
                              <mif:td> has 3 significant digits.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>4.1</mif:td>
                              <mif:td>has 2 significant digits.</mif:td>
                           </mif:tr>
                        </mif:tbody>
                     </mif:table>
                     <mif:p>
						The precision of the representation SHOULD match the
						uncertainty of the value. However, precision of the representation and
						uncertainty of the value are separate independent concepts. Refer to
						<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PPD_REAL"/>
                        </mif:object> for details about uncertain real numbers.
					</mif:p>
                     <mif:p>
						For example "0.123" has 3 significant digits <mif:b>in the
						representation</mif:b>, but the <mif:b>uncertainty of the value</mif:b>
						may be in any digit shown or not shown, i.e., the uncertainty may be
						0.123Â±0.0005, 0.123Â±0.005 or
						0.123Â±0.00005, etc. Note that ITS representations
						<mif:b>should</mif:b> adjust their representational precision with the
						uncertainty of the value. However, since the precision in the digit
						string is granular to 0.5 the least significant digit, while
						uncertainty may be anywhere between these "grid lines",
						0.123Â±0.005 would also be an adequate representation for the
						value between 0.118 and 0.128.
					</mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="ITS-Note">
                  <mif:text>
                     <mif:p>
							On a character based Implementation Technology the ITS may not
							represent the precision as an explicit attribute if numbers are
							represented as decimal digit strings. In that case, the ITS SHALL abide
							by the rules of an unambiguous determination of significant digits. A
							number representation SHALL not produce more or less significant digits
							than were originally in that number. Conformance can be tested through
							round-trip encoding â decoding â encoding.
						</mif:p>
                  </mif:text>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="plus" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Addition"/>
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(REAL x, y, z, o)
      where x.nonNull.and(y.nonNull).and(z.nonNull).and(o.isZero) {
   x.plus(o).equal(x);                             /* neutral element */
   x.plus(y).plus(z).equal(x.plus(y.plus(z)));     /* associative */
   x.plus(y).equal(y.plus(x));                     /* commutative */
   z.lessOrEqual(x).and(z.lessOrEqual(y)
                   .implies(z.lessOrEqual(x.plus(y))));
   x.lessOrEqual(y).implies(x.plus(z)
                   .lessOrEqual(y.plus(z)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type qualifier="baseDiff"/>
         </mif:parameter>
         <mif:type name="QTY"/>
      </mif:property>
      <mif:property name="negated" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Negation (Inverse Element of Addition)"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value, which, when added to another <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value yields
						zero (the neutral element of addition).
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(REAL x)
      where x.nonNull {
   x.plus(x.negated).isZero;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="isOne" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Neutral Element of Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A predicate indicating if this value is the number one, i.e., the
						neutral element of multiplication. There is exactly one real number
						that has this property.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(REAL x, y)
      where x.nonNull.and(y.nonNull) {
   x.isOne.and(y.isOne).implies(x.equal(y));
   x.isOne.and(y.isZero).implies(x.equal(y).not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="times" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						An operation in <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> that forms an abelian group and is related
						to addition by the law of distribution.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(REAL x, y, z, i, o)
      where x.nonNull.and(y.nonNull).and(z.nonNull)
             .and(i.isOne).and(o.isZero) {
   x.times(o).equal(o);
   x.times(i).equal(x);                                      /* neutral element */
   x.times(y).times(z).equal(x.times(y.times(z)));           /* associative */
   x.times(y).equal(y.times(x));                             /* commutative */
   x.times(y.plus(z)).equal(x.times(y).plus(x.times(z)));     /* distributive */
   o.lessOrEqual(x).and(o.lessOrEqual(y).implies(o.lessOrEqual(x.times(y))));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="dividedBy" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Standard Division"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The division operation of this real number(dividend) with a real number (divisor).
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(REAL dividend, REAL divisor)
      where dividend.nonNull.and(divisor.nonNull).and(divisor.isZero.not) {
   dividend.isZero.implies(dividend.dividedBy(divisor).isZero);
   dividend.isZero.not.implies(dividend.dividedBy(divisor).equals(dividend.times(divisor.inverted)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="inverted" sortKey="09" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Inverse Element of Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value, which, when muliplied with another <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value
						yields one (the neutral element of multiplication). Zero (the neutral
						element of addition) has no inverse element.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(REAL x, i)
      where x.isZero.not.and(i.isOne) {
   x.times(x.inverted).equal(i);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="power" sortKey="10" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Exponentiation"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The basis of exponentiation is the iterative multiplication of a
						real number, and extended to rational exponents as the inverse
						operation.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						We only list certain common properties of exponentiation.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(REAL x, y, z, o, i)
      where x.nonNull.and(y.nonNull).and(z.nonNull)
             .and(o.isZero).and(i.isOne) {
   forall(INT n)
         where n.nonNull {
      n.greaterThan(o).implies(
         x.power(n).equal(x.times(x.power(n.predecessor))));
      n.lessThan(o).implies(
         x.power(n).equal(x.power(n.negated).inverted));
      };
      x.power(o).equal(i);
      x.power(i).equal(x);
      x.power(y).power(z).equal(x.power(y.times(z)));
      x.power(y).times(x.power(z)).equal(x.power(y.plus(z)));
      x.power(y).inverted.equal(x.power(y.negated));
      x.power(y).power(y.inverted).equal(x);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="literal" sortKey="11" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The literal form of an real is a string of decimal digits with
						optional leading "+" or "-" sign, and optional decimal point, and
						optional exponential notation using a case insensitive "e" between the
						mantissa and the exponent. The number of significant digits SHALL
						conform to the precision property.
					</mif:p>
                     <mif:p>
						Examples of real literals for two thousand are 2000, 2000., 2e3,
						2.0e+3, +2.0e+3.
					</mif:p>
                     <mif:p>
						Note that the literal form does not carry type information. For
						example, "2000" is a valid representation of both a real number and an
						integer number. No trailing decimal point is used to disambiguate from
						integer numbers. An ITS that uses this literal form must recover the
						type information from other sources.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
REAL.literal ST.SIMPLE {
   REAL            : mantissa                   { $.equal($1); }
                   | mantissa /[eE]/ INT        { $.equal($1.times(10.power($3)); };

   REAL mantissa   : /0*/ 0                     { $.isZero;
                                                  $.precision.equal(1); }
                   | /0*/ "." /0*/              { $.isZero;
                                                  $.precision.equal($3.length.successor); }
                   | /0*/ "." /0*/ fractional   { $.equal($4);
                                                  $.precision.equal($4.precision); }
                   | integer                    { $.equal($1); }
                   | integer "." fractional     { $.equal($1.plus($2));
                                                  $.precision.equal(
                                                  $1.precision.plus($3.precision)); };

   REAL integer    : uintval                    { $.equal($2); }
                   | "+" uintval                { $.equal($1.times($2)); }
                   | "-" uintval                { $.equal($1.times($2).negated); };

   REAL uintval    : /0*/ uint                  { $.equal($2); };

   REAL uint       : digit                      { $.equal($1);
                                                  $.precision.equal(1); }
                   | uint digit                 { $.equal($1.times(10).plus($2));
                                                  $.precision.equal(
                                                     $1.precision.successor); };

   REAL fractional : digit                      { $.equal($1.times(10.inverted));
                                                  $.precision.equal(1); }
                   | digit fractional           { $.equal(
                                                  $1.plus($2.times(10.inverted));
                                                  $.precision.equal(
                                                     $1.precision.successor); };

   INT digit       : /[0-9]/                    { $.equal($1); }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="promotion" sortKey="12" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Homomorphism of INT and REAL"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="INT"/>
                        </mif:object> and <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> data types are related by a
						homomorphism that maps every value in <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="INT"/>
                        </mif:object> to a value
						in <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> whereby the algebraic properties of <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="INT"/>
                        </mif:object>
						are preserved. This means, an integer can be promoted to a real and a
						real can be demoted to an integer by means of rounding off the
						fractional part.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT n, m)
      where n.nonNull.and(m.nonNull) {
   ((REAL)n.plus(m)).equal(((REAL)n).plus((REAL)m));
   ((REAL)n.times(m)).equal(((REAL)n).times((REAL)m));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="demotion" sortKey="13" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Demotion to INT"/>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="equal" sortKey="14" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two nonNull <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> are equal if they have the same value and precision.<mif:object name="footnote">
								Because of precision and representation issues, such a strict
								evaluation of equals is often inappropriate in implementations, and some sort of 
								limit of difference or interval based logic is usually appropriate
								for applications.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="RTO" title="Ratio" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A quantity constructed as the quotient of a numerator quantity divided
					by a denominator quantity. Common factors in the numerator and
					denominator are not automatically cancelled out.  The <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> data
					type supports titers (e.g., "1:128") and other quantities produced by
					laboratories that truly represent ratios. Ratios are not simply
					"structured numerics": for instance, blood pressure measurements
					(e.g. "120/60") are not ratios.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					Ratios are different from rational numbers, i.e., in ratios common
					factors in the numerator and denominator never cancel out.  A ratio of
					two real or integer numbers is not automatically reduced to a real
					number. In many cases the <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="REAL"/>
                     </mif:object>
					should be used instead of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>
                  </mif:p>
                  <mif:p>
					The default value for both numerator and denominator is the integer
					number 1 (one). The denominator may not be zero.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTZ N, QTZ D&gt;
type Ratio&lt;N, D&gt; alias RTO&lt;N, D&gt; specializes QTY {
   N         numerator;
   D         denominator;
   literal   ST.SIMPLE;
   demotion  REAL;
   demotion  PQ;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="N" sortKey="1">
         <mif:type name="QTZ"/>
      </mif:parameter>
      <mif:parameter name="D" sortKey="2">
         <mif:type name="QTZ"/>
      </mif:parameter>
      <mif:property name="numerator" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Numerator"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The quantity that is being divided in the ratio.  The default is the
						integer number 1 (one).
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="N" qualifier="parameter"/>
      </mif:property>
      <mif:property name="denominator" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Denominator"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The quantity that devides the numerator in the ratio.  The default is
						the integer number 1 (one).  The denominator SHALL not be zero.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(RTO x)
      where x.nonNull {
   x.denominator.isZero.not;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="D" qualifier="parameter"/>
      </mif:property>
      <mif:property name="literal" sortKey="03" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						A ratio literal form exists for all ratios where both numerator and
						denominators have literal forms. A ratio is simply the numerator
						literal a colon as separator followed by the denominator literal. When
						the colon and denominator are missing, the integer number 1 is assumed
						as the denominator.
					</mif:p>
                     <mif:p>
						For example, the rubella virus antibody titer value 1:64 could be
						represented using the literal "1:64".
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
RTO.literal ST.SIMPLE {
   RTO : QTY          { $.numerator.equal($1);
                        $.denominator.equal((INT)1); };
       | QTZ ":" QTZ  { $.numerator.equal($1);
                        $.denominator.equal($3); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="demotion" sortKey="04" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Demotion To REAL"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A ratio can be demoted to a real by dividing the numerator by the denominator. 
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The numerator and denominator are converted to a REAL prior to the operation. 
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="demotion" sortKey="05" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Demotion To PQ"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A ratio can be demoted to a physical quantity by dividing the numerator by the denominator. The units
						are derived by dividing the units for the numerator by the units for the denominator. 
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The the numerator or denominator are not physical quantities, they must first be converted
						to a REAL and promoted to <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object> by assigning the unit "1". 
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="equal" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two nonNull <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>s are equal if their numerator and denominator are equal.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(RTO x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.numerator.equal(y.numerator).and(x.denominator.equal(y.denominator)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="RTO"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PQ" title="PhysicalQuantity" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTZ"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A dimensioned quantity expressing the result of measuring.
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type PhysicalQuantity alias PQ specializes QTZ {
            REAL      value;
            CS        unit;
            SET&lt;CS&gt;   codingRationale;
            DSET&lt;PQR&gt; translation;

            PQ        canonical;
            PQ        plus(QTY x);
            BL        isOne;
            PQ        times(REAL x);
            PQ        dividedBy(REAL x);
            PQ        times(PQ x);
            PQ        dividedBy(PQ x);
            PQ        negated;
            PQ        inverted;
            PQ        power(INT x);

  literal   ST.SIMPLE;
  promotion  PQ  (REAL x);
  demotion  REAL;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="value" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Maginitude Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The magnitude of the quantity measured in terms of the unit.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="unit" sortKey="02" propertyKind="variableProperty" visibility="public"
                    defaultValue="1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Unit of Measure"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The unit of measure specified in the Unified Code for Units of Measure
						(UCUM) [<mif:a href="http://aurora.regenstrief.org/ucum"/>]. The default
						unit is 1.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						UCUM defines two forms of expression, case sensitive and case insensitive.
						<mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> uses the case sensitive codes. The codeSystem OID for the case
						sensitive form is 2.16.840.1.113883.6.8.
					</mif:p>
                     <mif:p>
							The unit SHALL come from UCUM, which only specifies unambiguous measurement units.
							Sometimes it is not clear how some measurements in healthcare map to UCUM
							codes. The general pattern for a measurement is <mif:span style="Background:Yellow"/>
                        <mif:span style="Background:Pink"/> of <mif:span style="Background:Aqua"/>.
							In this scheme, the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> represents the <mif:span style="Background:Yellow"/> and the <mif:span style="Background:Pink"/>, and the
							<mif:span style="Background:Aqua"/> is described by some coded concept that
							is linked to the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> by the context of use. This maps obviously to some
							measurements, such as <mif:span style="Background:Aqua"/> of
							<mif:span style="Background:Yellow"/>
                        <mif:span style="Background:Pink"/>,
							and <mif:span style="Background:Yellow"/>
                        <mif:span style="Background:Pink"/> 
							of <mif:span style="Background:Aqua"/>. 
						</mif:p>
                     <mif:p>
							However for some measurements that arise in healthcare, the scheme is not so obvious.
							Two classic examples are 5 Drinks of Beer, and 3 Acetominophen tablets. At first glance
							it is tempting to classify these measurments like this: <mif:span style="Background:Yellow"/>
                        <mif:span style="Background:Pink"/> of <mif:span style="Background:Aqua"/> 
							and <mif:span style="Background:Yellow"/>
                        <mif:span style="Background:Aqua"/>
                        <mif:span style="Background:Pink"/>. The problem with this is that UCUM does not 
							support units of "beer", "tablets" or "scoops". 
						</mif:p>
                     <mif:p>
							The reason for this is that neither tablets or scoops are proper units. What kind of tablets?
							How big is the scoop? In these kinds of cases, the concept that appears to be a unit needs to 
							further specified before interoperability is established. If a correct amount is required, then
							it is generally appropriate to specify an exact measurement with an appropriate UCUM unit. If
							this is not possible, then the concept is not part of the measurement. UCUM provides a unit called
							unity for use in these cases. The proper way to understand these measurements as
							<mif:span style="Background:Yellow"/>
                        <mif:span style="Background:Pink"/>
                        <mif:span style="Background:Aqua"/>
                        <mif:span style="Background:Lime"/>, where 1 is the UCUM unit for unity, and
							the <mif:span style="Background:Aqua"/> has a <mif:span style="Background:Lime"/>.
							It is occasionally possible to use a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object>
                        <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="qualifier"/>
                           <mif:param name="datatypeName" value=""/>
                        </mif:object> to qualify the concept of
							the Thing directly, but usually there will be a need for extra information to clarify the measurements
							associated with the qualifying concept, and some further component observation would be required.
							<mif:object name="footnote">HL7 is preparing a document that contains common usage patterns that
					will discuss how to best use the PQ type in common healthcare measurement use cases.</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="UnitsOfMeasureCaseSensitive"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="codingRationale" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Coding Rationale"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
					    CodingRationale provides a reason why a particular <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> has been provided, either as the
						root concept or as one of the translations.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="SET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CodingRationale"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="translation" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Translation"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						An alternative representation of the same physical quantity expressed
						in a different unit, of a different unit code system and possibly with
						a different value.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="DSET">
            <mif:argumentDatatype name="PQR"/>
         </mif:type>
      </mif:property>
      <mif:property name="canonical" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Canonical Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A physical quantity expressed in a canonical unit. In any given unit
						system has every physical dimension can be assigned one canonical unit
						Defining the canonical unit is not subject of this specification, only
						asserting that such a canonical unit exists (and can be arbitrarily
						chosen) for every physical quantity. An abstract physical quantity is
						equal to its canonical form.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
					Physical quantities semantically are the results of measurement
					acts. Although physical quantities are represented as pairs of value
					and unit, semantically, a physical quantity is more than that. To find
					out whether two physical quantities are equal, it is not enough to
					compare equality of their two values and units independently. For
					example, 100 cm equals 1 m although neither values nor units are
					equal. To define equality we introduce the notion of a canonical form.
				</mif:p>
                     <mif:p>
						For example, for a unit system based on the SystÃ¨me
						International (SI) one can define the canonical form as (a) the
						product of only the base units; (b) without prefixes; where (c) only
						multiplication and exponents are used (no division operation); and (d)
						where the seven base units appear in a defined ordering (e.g., m, s,
						g...) Thus, 1 mm Hg would be expressed as 133322 g.m<mif:sup>-1</mif:sup>
						s<mif:sup>-2</mif:sup>. As can be seen, the rules how to build the canonical
						form of units may be quite complex. However, for the semantic
						specification it doesn't matter how the canonical form is built, nor
						what specific canonical form is chosen, only that <mif:b>some</mif:b>
						canonical form <mif:b>could</mif:b> be defined.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x)
      where x.nonNull {
   x.canonical.equal(x);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="equal" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two physical quantities are equal if their values (including precision) and their units
						of their canonical forms are equal.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.canonical.value
             .equal(y.canonical.value).and(
                x.canonical.unit.equal(y.canonical.unit)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="isComparableTo" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Is Comparable To"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two physical quantities can be compared to each other (and have an ordering and
						difference) if the units of their canonical forms are equal.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x, y)
      where x.nonNull.and(y.nonNull) {
   x.isComparableTo(y).equal(x.canonical.unit.equal(y.canonical.unit));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="diffType" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    ownerScope="classifier"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="DifferenceDataType"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The difference between 2 Physical Quantities is another Physical Quantity with
						the same units.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x) {
   x.diffType.implies(PQ);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x, y)
      where x.nonNull.and(x.isComparableTo(y)) {
   x.minus(y).canonical.unit.implies(x.canonical.unit);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="plus" sortKey="09" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Addition"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Two physical quantities that can be compared to each other can be added.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PQ x, y)
      where x.nonNull.and(x.isComparableTo(y)) {
   x.canonical.plus(y.canonical).value.equal(
      x.canonical.value.plus(y.canonical.value));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="isOne" sortKey="10" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Neutral Element of Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A predicate indicating if this value is the number one, i.e., the
						neutral element of multiplication. There is exactly one physical
						quantity that has this property and is called <mif:b>the unity</mif:b>.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x, y)
      where x.nonNull.and(y.nonNull) {
   x.isOne.and(y.isOne).implies(x.equal(y));
   x.isOne.and(y.isZero).implies(x.equal(y).not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="times" sortKey="11" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Real Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Multiplication with a real number forms a scaled quantity. A scaled
						quantity is comparable to its original quantity.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						If two quantities <mif:b>Q</mif:b>
                        <mif:sub>1</mif:sub> and
						<mif:b>Q</mif:b>
                        <mif:sub>2</mif:sub> can be compared to each other, there
						exists a real number <mif:b>r</mif:b> such that <mif:b>r</mif:b>
                        <mif:b>1</mif:b> = <mif:b>Q</mif:b>
                        <mif:sub>1</mif:sub> / <mif:b>Q</mif:b>
                        <mif:sub>2</mif:sub>.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x; REAL r)
      where x.nonNull.and(r.nonNull) {
   x.times(r).value.equal(x.value.times(r));
   x.times(r).isComparableTo(x);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="dividedBy" sortKey="12" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Standard Division"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Scalar division of the value property.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ dividend, REAL divisor)
      where dividend.nonNull.and(divisor.nonNull).and(divisor.isZero.not) {
   dividend.dividedBy(divisor).value.equal(dividend.value.dividedBy(divisor));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="times" sortKey="13" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The product of two physical quantities is the product of their values
						times the product of their units.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x, y, z, i, o)
      where x.nonNull.and(y.nonNull).and(z.nonNull)
             .and(o.isZero).and(i.isOne) {
   x.times(o).equal(o);
   x.times(i).equal(x);             /* neutral element */
   x.times(y).times(z).equal(
            x.times(y.times(z)));   /* associative */
   x.times(y).equal(y.times(x));    /* commutative */
   o.lessOrEqual(x).and(o.lessOrEqual(y).implies(o.lessOrEqual(x.times(y))));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="PQ"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="dividedBy" sortKey="14" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Standard Division"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The division of one physical quantities (dividend) by another (divisor) is the division of their values
						times the division of their units.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ dividend, PQ divisor)
      where dividend.nonNull.and(divisor.nonNull).and(divisor.isZero.not) {
   dividend.isZero.implies(dividend.dividedBy(divisor).isZero);
   dividend.isZero.not.implies(dividend.dividedBy(divisor).equals(dividend.times(divisor.inverted)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="PQ"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="negated" sortKey="15" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Negation (Inverse Element of Addition)"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value, which, when added to another <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value yields
						zero (the neutral element of addition).
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x)
      where x.nonNull {
   x.plus(x.negated).isZero;
   x.negated.unit.equals(x.unit);
   x.negated.value.equals(x.value.negated);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="inverted" sortKey="16" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Inverse Element of Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value, which, when muliplied with another <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value
						yields one (the neutral element of multiplication). Zero (the neutral
						element of addition) has no inverse element.  The quotient of two
						comparable quantities is comparable to the unity (the unit 1).
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ this, that, one)
      where this.nonNull.and(that.nonNull).and(one.isOne) {
   this.times(this.inverted).equal(one);
   this.isComparableTo(that).implies(this.times(that.inverted).equal(one));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="power" sortKey="17" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Exponentiation"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A physical quantity can be raised to an integer power.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PQ x, i; INT n, o) 
      where x.nonNull.and(i.isOne).and(n.nonNull.and(o.isZero)) {
   x.power(o).equal(i);
   n.greaterThan(o).implies(
      x.power(n).equal(x.times(x.power(n.predecessor))));
   n.lessThan(o).implies(
      x.power(n).equal(x.power(n.negated).inverted));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="literal" sortKey="18" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The literal form for a physical quantity is a real number literal
						followed by optional whitespace and a character string representing a
						valid code in the Unified Code for Units of Measure (UCUM)
						[<mif:a href="http://aurora.regenstrief.org/ucum"/>].
					</mif:p>
                     <mif:p>
						For example, 20 minutes is "20 min".
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
PQ.literal ST.SIMPLE {
   PQ       : REAL unit    { $.value.equal($1);
                             $.unit.equal($2); }
   CS  unit : ST           { $.value.equal($1);
                             $.codeSystem.equal(2.16.840.1.113883.6.8); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="promotion" sortKey="19" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Promotion of REAL to PQ"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						A <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object> value can be converted to a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> value
						with the unity, i.e. the unit <mif:b>1</mif:b> (one).
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x, unity) 
      where x.nonNull.and.unity.isOne.and(x.isComparableTo(unity)) {
   unity.times((REAL)x).equal(x);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="demotion" sortKey="20" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Demotion to REAL"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						If a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> can be compared to unity can be converted
						to a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object> number.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PQR" title="PhysicalQuantityRepresentation" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="CV"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An extension of the coded value data type representating a physical
					quantity using a unit from any code system. Used to show alternative
					representation for a physical quantity.
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type PhysicalQuantityRepresentation alias PQR specializes CV {
   REAL  value;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="value" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The magnitude of the measurement value in terms of the unit
						specified by this code.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						A value SHALL be provided if the translation is nonNull.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQR x)
    where x.nonNull {
  x.value.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="code" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The code for the unit.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						This is <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="code"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object>.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="codeSystem" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code System"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The identifier for the codeSystem from which the unit is taken.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						This is <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="codeSystem"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object>.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="UID"/>
      </mif:property>
      <mif:property name="codeSystemName" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code System Name"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The name of the codeSystem from which the unit is taken.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						This is <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="codeSystemName"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object>.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST.NT"/>
      </mif:property>
      <mif:property name="codeSystemVersion" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Code System Version"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The version for the codeSystem from which the unit is taken, if applicable.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						This is <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="codeSystemVersion"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object>.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="displayName" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Display Name"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The displayName for the unit, if applicable.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						This is <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="displayName"/>
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object>.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="originalText" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Original Text"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is a translation of a PQ which has an
						originalText, so originalText is prohibited in <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQR x) {
   x.originalText.notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ED.TEXT"/>
      </mif:property>
      <mif:property name="equal" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two nonNull <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>s are equal if they have the same value,
						and the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CD"/>
                        </mif:object> equality criteria are met.<mif:object name="footnote">
								This means that values of the values of the type PQR can not be equal with CD, CS, CO, or CV values.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQR x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.value.equal(y.value).and(((CD)x).equal((CD)y)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="PQR"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="MO" title="MonetaryAmount" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTZ"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A quantity expressing an amount of money in some
					currency. While the monetary amount
					is a single kind of quantity (money) the exchange rates between the
					different units are variable.  This is the principle difference
					between <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="PQ"/>
                  </mif:object> and <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object>, and the reason why
					currency units are not physical units.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p/>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type MonetaryAmount alias MO specializes QTZ {
           REAL  value;
           CS    currency;
           MO    plus(MO x);
           MO    times(REAL x);
           MO    dividedBy(REAL x);
   literal ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="value" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The magnitude of the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> in terms of <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="currency"/>
                        <mif:param name="datatypeName" value="MO"/>
                     </mif:object>.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                        <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="precision"/>
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object> is the precision of
							the decimal representation, not the precision of the value. <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object>
							has no notion of uncertainty or accuracy. For example,
							"1.99 USD" (precision 3) times 7 is "13.93 USD" (precision 4) and
							should not be rounded to "13.9" to keep the precision constant.
						</mif:p>
                     <mif:p>
							A value is required.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(MO x) where x.nonNull {
  x.value.nonNull;
}</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="currency" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Currency"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The currency unit as defined in ISO 4217.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							Note: the OID specified here will be changing to a new OID once a new OID is agreed in association with ISO. 
						</mif:p>
                     <mif:p>
							This table only shows a representative subset of the
							codes defined by ISO 4217. All codes from ISO 4127 are
							valid for this attribute.
						</mif:p>
                     <mif:p>
							A currency SHALL be provided.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(MO x) where x.nonNull {
  x.currency.nonNull;
}</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="Currency"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="equal" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							Two <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values are equal if both <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="value"/>
                           <mif:param name="datatypeName" value="MO"/>
                        </mif:object> and
							<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="currency"/>
                           <mif:param name="datatypeName" value="MO"/>
                        </mif:object> are equal.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(MO x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.value.equal(y.value)
             .and(x.unit.equal(y.unit)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="isComparableTo" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Is Comparable To"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							Two <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values can be compared to each other (and have an ordering and
							difference) if their <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="currency"/>
                           <mif:param name="datatypeName" value="MO"/>
                        </mif:object>s are equal.
						</mif:p>
                     <mif:p>
							If their <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="currency"/>
                           <mif:param name="datatypeName" value="MO"/>
                        </mif:object>s are not identical,
							the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="values"/>
                           <mif:param name="datatypeName" value="MO"/>
                        </mif:object> cannot be
							compared. Conversion between currencies is outside the scope of
							this specification. In practice, foreign exchange rates are highly
							variable not only over long and short amounts of time, but also
							depending on location and access to currency trade markets.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(MO x, y)
      where x.nonNull.and(y.nonNull) {
   x.isComparableTo(y).equal(x.currency.equal(y.currency));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="diffType" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    ownerScope="classifier"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="DifferenceDataType"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							The difference between 2 <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>s is another <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x) {
   x.diffType.implies(MO);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="plus" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Addition"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							Two <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s can be added if their
							<mif:object name="propertyRef">
                        <mif:param name="propertyName" value="currency"/>
                        <mif:param name="datatypeName" value="MO"/>
                     </mif:object>s are equal.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (MO x, y)
      where x.nonNull.and(y.nonNull).and(x.currency.equal(y.currency)) {
   x.plus(y).currency.equal(x.currency);
   x.plus(y).value.equal(x.value.plus(y.value));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="MO"/>
         </mif:parameter>
         <mif:type name="MO"/>
      </mif:property>
      <mif:property name="times" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Real Multiplication"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							Multiplication with a <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="REAL"/>
                     </mif:object> forms a scaled quantity. A scaled
							quantity is comparable to its original quantity.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(MO x; REAL r)
      where x.nonNull.and(r.nonNull) {
   x.times(r).value.equal(x.value.times(r));
   x.times(r).currency.equal(x.currency);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="MO"/>
      </mif:property>
      <mif:property name="dividedBy" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Standard Division"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						Scalar division of the value property.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(MO dividend, REAL divisor)
      where dividend.nonNull.and(divisor.nonNull).and(divisor.isZero.not) {
   dividend.isZero.implies(dividend.dividedBy(divisor).isZero);
   dividend.isZero.not.implies(dividend.dividedBy(divisor).equals(dividend.times(divisor.inverted)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="MO"/>
      </mif:property>
      <mif:property name="literal" sortKey="09" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							The literal form for an <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> consists of a currency code string,
							optional whitespace, and a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object> literal amount.
						</mif:p>
                     <mif:p>
							For example, "USD189.95" is the literal for 189.95 U.S. Dollar.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
MO.literal ST.SIMPLE {
   MO           : currency value  { $.currency.equal($1); }
                                    $.value.equal($2);
   CS  currency : ST              { $.currency.value.equal($1);
                                    $.currency.codeSystem
                                    .equal(2.16.840.1.113883.6.9); }
   REAL value   : REAL           { $.value.equal($1); }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CAL" title="Calendar" datatypeKind="Definition" visibility="private">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="DSET">
            <mif:argumentDatatype name="CLCY"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A calendar is a concept of measuring time in various cycles. Such
					cycles are years, months, days, hours, minutes, seconds, and
					weeks. Some of these cycles are synchronized and some are not (e.g.,
					weeks and months are not synchronized).
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					After "rolling the time axis" into these cycles
					a calendar expresses a point in time as a sequence
					of integer counts of cycles, e.g., for year, month, day, hour,
					etc. The calendar is rooted in some conventional start point, called
					the "epoch."
				</mif:p>
                  <mif:img imageType="image/gif" hl7Id="CAL" src="datyp2fig9.gif" alt="**NO CAPTION**"/>
                  <mif:p>
					A calendar "rolls" the time axis into a complex convolute according to
					the calendar periods year (blue), month (yellow), day (green), hour
					(red), etc. The cycles need not be aligned, for example, the week (not
					shown) is not aligned to the month.<mif:object name="footnote">
							Imagine a special clock that measures those cycles, where the pointers
							are not all stacked on a common axis but each pointer is attached to
							the end of the pointer measuring the next larger cycle.
						</mif:object>
                  </mif:p>
                  <mif:p>
					Calendar is defined as a set of calendar cycles, and has a name and a
					code. The head of the Calendar is the largest CalendarCycle appearing
					right most in the calendar expression. The epoch is the beginning of
					that calendar, i.e., the point in time where all calendar cycles are
					zero.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
private type Calendar alias CAL specializes DSET&lt;CLCY&gt;  {
   CS    name;
   CLCY  head;
   TS    epoch;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="name" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Name"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
					The calendar definition can be shown as in <mif:object name="conceptDomainRef">
                           <mif:param name="domain" value="CalendarCycle"/>
                        </mif:object>
					for the modern Gregorian calendar. The calendar definition table lists a
					calendar cycle in each row. The calendar units are dependent on each other and
					defined in the value column. The sequence column shows the relationship through
					the next property. The other columns are as in the formal calendar cycle
					definition.<mif:object name="footnote"> 
							At present, the CalendarCycle properties sum and value are not
							formally defined. The computation of calendar digits involves some
							complex computation which to specify here would be hard to understand
							and evaluate for correctness. Unfortunately, no standard exists that
							would formally define the relationship between calendar expressions
							and elapsed time since an epoch. ASN.1, the XML Schema Data Type
							specification and SQL92 all refer to ISO 8601, however, ISO 8601 does
							only specify the syntax of Gregorian calendar expressions, but not
							their semantics. In this standard, we define the syntax and semantics
							formally, however, we presume the semantics of the sum-, and
							value-properties to be defined elsewhere.  
						</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CAL c)
      where c.nonNull {
   c.name.nonNull;
   c.contains(c.head);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="CS"/>
      </mif:property>
      <mif:property name="head" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Head"/>
         <mif:type name="CLCY"/>
      </mif:property>
      <mif:property name="epoch" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Epoch"/>
         <mif:type name="TS"/>
      </mif:property>
      <mif:property name="equal" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="DSET"/>
                        </mif:object> data type.<mif:object name="footnote">
								This means that values of the type CAL and DSET&lt;CLCY&gt; may be equal.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="CAL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CLCY" title="CalendarCycle" datatypeKind="Definition"
                 visibility="private">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>    
					A calendar cycle defines one group of decimal digits in the calendar
					expression. Examples for calendar cycles are year, month, day, hour,
					minute, second, and week.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					A calendar cycle has a name and two codes, a one-letter code and a
					two-letter code. The property <mif:b>ndigits</mif:b> is the number of
					decimal digits occupied in the calendar expression. The property
					<mif:b>start</mif:b> specifies where counting starts (i.e., at 0 or 1).
					The <mif:b>next</mif:b> property is the next lower cycle in the order of
					the calendar expression. The max(<mif:b>t</mif:b>) property is the
					maximum number of cycles at time <mif:b>t</mif:b> (max depends on the
					time <mif:b>t</mif:b> to account for leap years and leap seconds).  The
					property value(<mif:b>t</mif:b>) is the integer number of cycles shown
					in the calendar expression of time <mif:b>t</mif:b>. The property
					sum(<mif:b>t</mif:b>, <mif:b>n</mif:b>) is the sum of <mif:b>n</mif:b>
					calendar cycles added to the time <mif:b>t</mif:b>.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
private type CalendarCycle alias CLCY specializes ANY {
   CV     name;
   INT    ndigits;
   INT    start;
   CLCY   next;
   INT    max(TS t);
   TS     sum(TS t, REAL r);
   INT    value(TS t);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CLCY c)
      where c.nonNull {
   c.name.nonNull;
   c.start.equal(0).or(c.start.equal(1));
   c.digits.greaterThan(0);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="name" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Name"/>
         <mif:type name="CV"/>
      </mif:property>
      <mif:property name="ndigits" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Number Of Digits"/>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="start" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Start"/>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="next" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Next"/>
         <mif:type name="CLCY"/>
      </mif:property>
      <mif:property name="max" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Maximum"/>
         <mif:parameter name="t" sortKey="1">
            <mif:type name="TS"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="sum" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Sum"/>
         <mif:parameter name="t" sortKey="1">
            <mif:type name="TS"/>
         </mif:parameter>
         <mif:parameter name="r" sortKey="2">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="TS"/>
      </mif:property>
      <mif:property name="value" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value"/>
         <mif:parameter name="t" sortKey="1">
            <mif:type name="TS"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="equal" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Two nonNull <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>s are equal if they have the same ndigits, start, and next.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CLCY x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.ndigits.equal(y.ndigits).and(x.start.equal(y.start)).and(x.next.equal(y.next)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="CLCY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TS" title="PointInTime" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A quantity specifying a point on the axis of natural time. A point
					in time is most often represented as a calendar expression.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					Semantically, however, time is independent from calendars and best
					described by its relationship to elapsed time (measured as a physical
					quantity in the dimension of time).  A <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> plus an elapsed
					time yields another <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>.  Inversely, a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> minus
					another <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> yields an elapsed time.
				</mif:p>
                  <mif:p>
					As nobody knows when time began, a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is conceptualized as
					the amount of time that has elapsed from some arbitrary zero-point,
					called an epoch.  Because there is no absolute zero-point on the time
					axis; natural time is a difference-scale quantity, where only
					differences are defined but no ratios. (For example, no <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>
					is â absolutely speaking â "twice as late" as another
					<mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>).
				</mif:p>
                  <mif:p>
					Given some arbitrary zero-point, one can express any point in time as
					an elapsed time measured from that offset. Such an arbitrary
					zero-point is called an epoch. This epoch-offset form is used as a
					semantic representation here, without implying that any system would
					have to implement <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> in that way. Systems that do not
					need to compute distances between <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s will not need any
					other representation than a calendar expression literal.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type PointInTime alias TS specializes QTY {
           PQ   offset;
           CS   calendar;
           INT  precision;
           PQ   timezone;
           TS   plus(PQ x);
           PQ   minus(TS x);
           TS   minus(PQ x);
  literal  ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:property name="offset" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Offset from Epoch"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The elapsed time since any constant epoch, measured as a physical
							quantity in the dimension of time (i.e., comparable to one second).
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							It is not necessary for this specification to define a canonical
							epoch; the semantics is the same for any epoch, as long as the epoch
							is constant.
						</mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="ITS-Note">
                  <mif:text>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> may be treated as a purely semantic property that
								is not represented in any way other than the calendar literal
								expression. However, an ITS may just as well choose to define a
								constant epoch and represent <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values as elapsed time
								offsets relative to that epoch. However, an ITS using an epoch-offset
								representation would still need to communicate the calendar code and
								the precision of a calendar representation once other calendars are
								supported.
							</mif:p>
                  </mif:text>
               </mif:otherAnnotation>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(TS x, PQ y)
      where x.nonNull.and(y.unit.code.equal("s")) {
   x.offset.isComparableTo(y);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="equal" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							Two <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values are equal if and only if their
							<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="offset"/>
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object>s
							(relative to the same epoch) are equal. If both TS value have timezones, 
							the values should be be corrected for timezone before comparison. 
							If neither TS value has a timezone, then they may be compared for 
							equality without correction. If only one TS value has a timezone, 
							then the equality is null (nullFlavor NI).
					</mif:p>
                     <mif:p>
						Two nonNull <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> are only equal if they have the same precision.<mif:object name="footnote">
								Because of precision and representation issues, such a strict
								evaluation of equals is often inappropriate in implementations, and some sort of
								limit of difference or interval based logic is usually appropriate
								for applications.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(TS x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.offset.equal(y.offset)).and(x.precision.equal(y.precision));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="lessOrEqual" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Ordering: less-or-equal"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A predicate expressing an order relation that is reflexive, asymmetric
						and transitive, between this <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> and another <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values with the same precision form a totally ordered subset.
						The outcome of lessOrEqual between two <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is NULL unless they
						have the same precision.
					</mif:p>
                     <mif:p>
						By contrast, a partially ordered set is a set where some, but not all
						pairs of elements are comparable through the order relation (e.g., a
						tree structure or the set of physical quantities is a partially
						ordered set).  Two data values <mif:b>x</mif:b> and <mif:b>y</mif:b> of an
						ordered type are comparable (<mif:b>x</mif:b>.isComparableTo(<mif:b>y</mif:b>))
						if the less-or-equal relation holds in either way (<mif:b>x</mif:b>
						â¤ <mif:b>y</mif:b> or <mif:b>y</mif:b> â¤ <mif:b>x</mif:b>).
					</mif:p>
                     <mif:p>
						A partial order relation generates totally ordered subsets whose union
						is the entire set (e.g., the set of all length is a totally ordered
						subset of the set of all physical quantities).
					</mif:p>
                     <mif:p>
						For example, a tree structure is partially ordered, where the root is
						considered less or equal to a leaf, but there may not be an order
						among the leafs. Also, physical quantities are partially ordered,
						since an order exists only among quantities of the same dimension
						(e.g., between two lengths, but not between a length and a time).  A
						totally ordered subset of a tree is a path that transitively connects
						a leaf to the root. The physical dimension of time is a totally
						ordered subset of physical quantities.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(TS x, y)
      where x.nonNull.and(y.nonNull) {
   x.lessOrEqual(y).nonNull.implies(x.offset.equal(y.offset));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (QTY x, y, z)
   where x.nonNull.and(y.nonNull).and(z.nonNull) {
      x.lessOrEqual(x);                                  /* reflexive */
      x.lessOrEqual(y).implies(y.lessOrEqual(x)).not;    /* asymmetric */
      x.lessOrEqual(y).and(y.lessOrEqual(z))
       .implies(x.lessOrEqual(z))                        /* transitive */
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="calendar" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="GREG"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Calendar"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A code specifying the calendar used in the literal representation of
							this <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>. The default values is GREG.<mif:object name="footnote">
									At this time, no other calendars than the Gregorian calendar are
									defined. However, the notion of a calendar as an arbitrary convention
									to specify absolute time is important to properly define the semantics
									of time and time-related data types. Furthermore, other calendars
									might be supported when needed to facilitate HL7's use in other
									cultures.
								</mif:object>
                  </mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							The purpose of this property is mainly to faithfully convey what has
							been entered or seen by a user in a system originating such a
							<mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> value. <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> also advises any system
							rendering a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> value into a literal form of which calendar
							to use. However, this is only advice; any system that renders
							<mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values to users may choose to use the calendar and
							literal form demanded by its users rather than the calendar mentioned
							in <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object>. Hence, <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is not constant
							in communication between systems, the calendar is not part of the
							equality test.
						</mif:p>
                     <mif:p>
							For the purpose of defining the relationship between calendar
							expression and epoch/offset form, two private data types,
							<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CAL"/>
                        </mif:object> and <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="CLCY"/>
                        </mif:object>
							are defined. These calendar data types
							exist only for defining this specification. These private data types
							may not be used at all outside this specification.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="Calendar"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="precision" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Precision of the Calendar Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The number of significant digits of the calendar expression
							representation.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is formally defined based on the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="literal"/>
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object>.
						</mif:p>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is only the precision of a decimal digit
							representation, <mif:b>not the accuracy of the <mif:object name="itemName">
                              <mif:param name="item" value="datatype"/>
                           </mif:object>
							value</mif:b>.
						</mif:p>
                     <mif:p>
							The purpose of <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object>
							is to faithfully capture the whole information presented to humans in
							a calendar expression. The number of digits shown conveys information
							about the uncertainty (i.e., precision and accuracy) of a measured
							<mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>. The decimal point between seconds and fractions of a second - if 
							present - does not count towards the significant digits. 
						</mif:p>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is dependent on <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="calendar"/>
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object>.
							A given <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> relative to one calendar does not mean the same in another
							calendar with different periods.
						</mif:p>
                     <mif:p>
							For example "20000403" has 8 significant digits <mif:b>in the
							representation</mif:b>, but the <mif:b>uncertainty of the value</mif:b>
							may be in any digit shown or not shown, i.e., the uncertainty may be
							to the day, to the week, or to the hour. Note that external
							representations <mif:b>should</mif:b> adjust their representational
							precision with the uncertainty of the value. However, since the
							precision in the digit string depends on the calendar and is granular
							to the calendar periods, uncertainty may not fall into that grid
							(e.g., 2000040317 is an adequate representation for the value between
							2000040305 and 2000040405).
						</mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="ITS-Note">
                  <mif:text>
                     <mif:p>
								A character based ITS MAY NOT
								represent <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> as an explicit attribute if <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
								values are represented as literal calendar expressions. A <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
								representation SHALL NOT produce more or less significant digits
								than were originally in that value. Conformance can be tested through
								round-trip encoding - decoding - encoding.
							</mif:p>
                  </mif:text>
               </mif:otherAnnotation>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="timezone" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Timezone Offset"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The difference between the local time in that time zone and Universal
							Coordinated Time (UTC, formerly called Greenwich Mean Time, GMT). The
							time zone is a <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PQ"/>
                     </mif:object> in the dimension of time (i.e.,
							comparable to one second).  A zero time zone value specifies UTC. The
							time zone value does not permit conclusions about the geographical
							longitude or a conventional time zone name.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							For example, 200005121800-0500 may be eastern standard time (EST) in
							Indianapolis, IN, or central daylight savings time (CDT) in Decatur,
							IL. Furthermore in other countries having other latitude the time
							zones may be named differently.
						</mif:p>
                     <mif:p>
							When <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is NULL (unknown), "local time" is
							assumed. However, "local time" is always local to some place, and
							without knowledge of that place, the time zone is unknown. Hence, a
							local time cannot be converted into UTC. <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> SHOULD be
							specified for all <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values in order to avoid a significant
							loss of precision when <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>s are compared. The difference of
							two local times where the locality is unknown has an error of
							Â±12 hours.
						</mif:p>
                     <mif:p>
							In administrative data context, some time values do not carry a time
							zone. For a date of birth in administrative data, for example, it
							would be incorrect to specify <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object>, since this may effectively
							change the date of birth when converted into other time zones. For
							such administrative data the time zone is NULL (not applicable).
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(TS x, y)
      where x.nonNull.and(y.nonNull) {
   x.timezone.isComparableTo("1 s");
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="diffType" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    ownerScope="classifier"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="DifferenceDataType"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							The difference between 2 <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>s is a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object> in
							the dimension of time.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(TS x) {
   x.diffType.implies(PQ);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="plus" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Addition"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> plus an elapsed time (i.e., <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PQ"/>
                     </mif:object> in the
							dimension of time) is a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(TS x, PQ t)
      where x.nonNull.and(t.isComparableTo("1 s")) {
   x.plus(t).offset.equal(x.offset.plus(t));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="PQ"/>
         </mif:parameter>
         <mif:type name="TS"/>
      </mif:property>
      <mif:property name="minus" sortKey="09" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Difference"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The difference between two <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s is an elapsed time.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(TS x, y)
      where x.nonNull.and(y.nonNull) {
   x.minus(y).dataType.equal(PQ);
   x.minus(y).offset.equal(x.offset.plus(y.offset.negated));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="TS"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="minus" sortKey="10" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Difference"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The subtraction of a PQ from a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(TS x, PQ y)
      where x.nonNull.and(y.nonNull) {
   x.minus(y).dataType.equal(TS);
   x.minus(y).equal(x.plus(y.negated));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="PQ"/>
         </mif:parameter>
         <mif:type name="TS"/>
      </mif:property>
      <mif:property name="literal" sortKey="11" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> literals are simple calendar expressions, as defined by
							the calendar definition table. By default, the western (Gregorian)
							calendar shall be used (<mif:object name="conceptDomainRef">
                           <mif:param name="domain" value="CalendarCycle"/>
                        </mif:object>).
						</mif:p>
                     <mif:p>
							For the default Gregorian calendar the calendar expression literals of
							this specification conform to the constrained ISO 8601 that is defined
							in ISO 8824 (ASN.1) under clause 32 (generalized time) and to the HL7
							Version 2 TS data type.
						</mif:p>
                     <mif:p>
							Calendar expression literals are sequences of integer numbers ordered
							according to the "counter" column of <mif:object name="conceptDomainRef">
                           <mif:param name="domain" value="CalendarCycle"/>
                        </mif:object>.
							Periods with lower order numbers stand to the left of periods with higher order
							numbers. Periods with no assigned order number cannot occur in the calendar
							expression for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>.
						</mif:p>
                     <mif:p>
							The "digits" column of <mif:object name="conceptDomainRef">
                           <mif:param name="domain" value="CalendarCycle"/>
                        </mif:object>
							specifies the exact number of digits for the counter number for any
							period.
						</mif:p>
                     <mif:p>
							Thus, <mif:object name="conceptDomainRef">
                           <mif:param name="domain" value="CalendarCycle"/>
                        </mif:object> specifies that western
							calendar expressions begin with the 4-digit year (beginning counting
							at zero); followed by the 2-digit month of the year (beginning
							counting at one); followed by the 2-digit day of the month (beginning
							with one); followed by the 2-digit hour of the day (beginning with
							zero); and so forth. For example, "200004010315" is a valid expression
							for April 1, 2000, 3:15 am.
						</mif:p>
                     <mif:p>
							A calendar expression can be of variable precision, omitting parts
							from the right.
						</mif:p>
                     <mif:p>
							For example, "20000401" is precise only to the day of the month.
						</mif:p>
                     <mif:p>
							The least defined calendar period (i.e. the second) may be written as
							a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object>, with the number of integer digits specified, followed
							by the decimal point and any number of fractional digits.
						</mif:p>
                     <mif:p>
							For example, "20000401031520.34" means April 1, 2000, 3:15 and 20.34
							seconds.
						</mif:p>
                     <mif:p>
							When other calendars are used in the future, a prefix "GREG:" can
							be placed before the western (Gregorian) calendar expression to
							disambiguate from other calendars. Each calendar shall have its own
							prefix. However, the western calendar is the default if no prefix is
							present.
						</mif:p>
                     <mif:p>
							In the modern Gregorian calendar (and all calendars where time of day
							is based on UTC), the calendar expression may contain a time zone
							suffix. The time zone suffix begins with a plus (+) or minus (-)
							followed by digits for the hour and, for non UTC times, minute cycles. UTC is designated
							as offset "+00" or "-00"; the ISO 8601 and ISO 8824 suffix "Z" for UTC
							is not permitted.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
TS.literal ST.SIMPLE {
   TS   : cal timestamp($1)                  { $.equal($2); }
        | timestamp(GREG)                    { $.equal($1); };

   TS timestamp(Calendar C)
        : cycles(C.head, C.epoch) zone(C)    { $.equal($1.minus($2)); }
                                               $.timezone.equal($2); }
        | cycles(C.head, C.epoch)            { $.equal($1);
                                               $.timezone.unknown; };
   Calendar cal
        : /[a-zA-Z_][a-zA-Z0-9_]*:/          { $.equal($1); };

   TS cycles(CalendarCycle c, TS t)
        : cycle(c, t) cycles(c.next, $1)     { $.equal($2); }
        | cycle(c, t) "." REAL.fractional    { $.equal(c.sum($1, $3));
                                               $.precision.equal(
                                                  t.precision.plus($3.precision)); }
        | cycle(c, t)                        { $.equal($1); };

   TS cycle(CalendarCycle c, TS t)
        : /[0-9]{c.ndigits}/                 { $.equal(c.sum(t, $1));
                                                $.precision.equal(
                                                   t.precision.plus(c.ndigits)); };

   PQ zone(Calendar C)
        : "+" cycles(C.zonehead, C.epoch)    { $.equal($2.minus(C.epoch)); }
        | "-" cycles(C.zonehead, C.epoch)    { $.equal(C.epoch.minus($2)); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="EXPR" title="Expression" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="T" qualifier="parameter"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A generic data type extension used to specify an expression
					that can be used to derive the actual value of T given information
					taken from the context of use.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					For example <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> can be used for expressing dosage instructions that
					depend on patient body weight. 
				</mif:p>
                  <mif:p>
				The expression specifies how the value of type T can be evaluated. 
				Either an expression or a value or both may be provided. It is at the
				discretion of the receiver of the information whether to evaluate the 
				expression when the information is being processed. If no value is 
				provided, then the value SHALL have a nullFlavor, whether or not an 
				expression is provided.
			</mif:p>
                  <mif:p>
				Note that as a generic type extension, <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> does not modify the
				meaning of equality for the type which it specializes.
			</mif:p>
                  <mif:div title="Factor: A simple language for dosage quantities">
     This is a very simple language to support 
     common dosage formulas that dependent on some patient observations, e.g., body mass or the body surface area.
     The language supports any formula that uses one or more input data as factors multiplied with some constant coefficient. 
     For example, a standard dose might be 30 mL per kg of body mass,
     i.e. the constant coefficient is 30 mL/kg and is multiplied with the body mass.
				Introduction
						A factor expression simply calculates the value from as specified from one or more derivedFrom
						observations on the context of the local act of which the expression is an attribute.
						Here is an example:
					
 &lt;substanceAdministration&gt;
   ...
   &lt;doseQuantity xsi:type="EXPR_PQ" unit="mL" mediatype="application/hl7-factor+xml"&gt;
     &lt;coefficient value="30" unit="mL/kg"&gt;
     &lt;factor&gt;bodyMass&lt;/factor&gt;
   &lt;/doseQuantity&gt;
   ...
   &lt;derivedFrom&gt;
     &lt;localVariableName&gt;bodyMass&lt;/localVariableName&gt;
     &lt;monitoringObservation&gt;
       &lt;code code="29463-7" codeSystem="2.16.840.1.113883.6.1" displayName="BODY WEIGHT:MASS:PT:^PATIENT:QN"/&gt;
     &lt;/monitoringObservation&gt;
   &lt;/derivedFrom&gt;
 &lt;/substanceAdministration&gt;
      The value of the input observations that serve as factors is usually not provided but resolved at 
      the time of evaluating the expression; at that time the receiving application will have to source an
      appropriate observation in order to evaluate the expression. If no appropriate
      observation can be found, the result of the expression is null.     
					Formal Definition
      The mediatype for this language is "application/hl7-factor+xml".
      This language is only applicable to . The source SHALL be provided 
      in-line, and no translations are allowed. For interest, here is the formal definition:
					
					
invariant(EXPR x) where
  x.mediaType.equals("application/hl7-factor+xml") {
  x.expression.nonNull;
  x.expression.language.notApplicable;
  x.expression.compression.notApplicable;
  x.expression.reference.notApplicable;
  x.expression.integrityCheck.notApplicable;
  x.expression.integrityCheckAlgorithm.notApplicable;
  x.expression.description.notApplicable;
  x.expression.thumbnail.notApplicable;
  x.expression.translation.isEmpty;
};
      The expression consists of a coefficient with a type of , and a 
      series of factors, which are simple names. Factors are specified as a simple 
      data value, and refer to an ActRelationship.localVariableName of the relationship
	  specifying the input variable. The specific wire format for this is defined in the ITS specifications.
					
      An expression of this type SHALL only be used on an attribute that is part
      of an Act, and the Act SHALL have one ActRelationship for each named factor in
      the expression, where the ActRelationship has an Observation as target and
      a localVariableName attribute equal to the named factor.
      The target Observation SHALL 
      have a code that specifies the type of observation. 
      The target Observation MAY have a value, but typically NEED NOT carry a value. 
 					
      The result of the expression is the product of the coefficient and all the factors according to the 
      semantics of all data types involved.
      Specifically, Units in  factors SHALL be carried through correctly and determine the dimension of the final result. 
      If a unit is specified in the  itself, then the units of the result SHALL be compared to the units specified. If no
      conversion to the correct units is possible, the result of the evaluation SHALL be NULL. 
      In other words, specifying the unit will guarantee the dimension of the result.
   					
      This language is deliberately limited in scope for ease of implementation. For more
      sophisticated requirements other languages should be used instead.
      HL7 plans to develop separate appendix documents describing the use of other expression languages.
					</mif:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type Expression&lt;T&gt; alias EXPR&lt;T&gt; specializes T {
  ED      expression;
  EXPR&lt;T&gt;  evaluate;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="expression" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Expression"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The definition of the expression that can be evaluated to generate the actual value.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							The language of the expression SHALL be inferred from the mediatype of the content. If multiple translations are
							provided in the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="ED"/>
                        </mif:object>, the evaluator is free to choose whichever language is
							preferred; all translations SHALL specify the same outcome.
						</mif:p>
                     <mif:p>
							The language of the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> defines the forms that the expression property can take,
							how the information available in the context of the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is made available within
							the features of the language, and how the language declares the new form of the value.
							Implementers are not required to implement any languages in order to claim conformance to
							this specification, but SHOULD declare what languages are supported in their conformance
							statements.
						</mif:p>
                     <mif:table width="90%">
                        <mif:caption>Known languages</mif:caption>
                        <mif:tr>
                           <mif:th>Language</mif:th>
                           <mif:th>Mediatype</mif:th>
                        </mif:tr>
                        <mif:tr>
                           <mif:td>OCL</mif:td>
                           <mif:td>text/plain+ocl</mif:td>
                        </mif:tr>
                        <mif:tr>
                           <mif:td>Factor (see below)</mif:td>
                           <mif:td>application/hl7-factor+xml</mif:td>
                        </mif:tr>
                        <mif:tr>
                           <mif:td>MathML</mif:td>
                           <mif:td>application/mathml+xml</mif:td>
                        </mif:tr>
                     </mif:table>
                     <mif:p>
							This is not a list of allowed expression languages, just a convenient summary of some types that
							may be encountered. If no supported language is found in the expression, then the outcome of the
							evaluation is NULL.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="evaluate" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Evaluate"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The result of evaluating the expression.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							The result is also an expression so that the expression used to derive the result can be carried with
							the result of the evaluation. If the evaluation fails because required information is not available
							of the language is not supported by the implementation, then the value will have a nullFlavor.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="EXPR">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="GLIST" title="GeneratedSequence" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="LIST"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A periodic or monotone sequence of values generated from
					parameters, rather than being enumerated. 
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is used to specify regular sampling points for biosignals.
				</mif:p>
                  <mif:p>
					The item at a certain index in the list is calculated by performing an
					integer division on the index (<mif:var>i</mif:var>) with the
					<mif:object name="propertyRef">
                        <mif:param name="propertyName" value="denominator"/>
                        <mif:param name="datatypeName" value="GLIST"/>
                     </mif:object> (<mif:var>d</mif:var>) and then take that
					value's remainder modulus <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="period"/>
                        <mif:param name="datatypeName" value="GLIST"/>
                     </mif:object>
					(<mif:var>p</mif:var>). Multiply this value with the
					<mif:object name="propertyRef">
                        <mif:param name="propertyName" value="increment"/>
                        <mif:param name="datatypeName" value="GLIST"/>
                     </mif:object> (<mif:var>Îx</mif:var>) and add to the
					<mif:object name="propertyRef">
                        <mif:param name="propertyName" value="head"/>
                        <mif:param name="datatypeName" value="GLIST"/>
                     </mif:object> (<mif:var>x</mif:var>
                     <mif:sub>0</mif:sub>).
				</mif:p>
                  <mif:blockquote>
                     <mif:p>
                        <mif:var>x</mif:var>
                        <mif:sub>
                           <mif:var>i</mif:var>
                        </mif:sub>=<mif:var>x</mif:var>
                        <mif:sub>0</mif:sub>
						+ <mif:var>Îx</mif:var> Ã (<mif:var>i</mif:var>/<mif:var>d</mif:var>)
						mod <mif:var>p</mif:var>.
					</mif:p>
                  </mif:blockquote>
                  <mif:table width="90%" hl7Id="table-GLIST.example">
                     <mif:caption>Examples for Generated Sequences</mif:caption>
                     <mif:thead>
                        <mif:tr>
                           <mif:th>head</mif:th>
                           <mif:th>increment</mif:th>
                           <mif:th>denominator</mif:th>
                           <mif:th>period</mif:th>
                           <mif:th>meaning</mif:th>
                        </mif:tr>
                     </mif:thead>
                     <mif:tbody>
                        <mif:tr>
                           <mif:td>0</mif:td>
                           <mif:td>1</mif:td>
                           <mif:td>1</mif:td>
                           <mif:td>â</mif:td>
                           <mif:td>The identity-sequence where each item is equal to its index.</mif:td>
                        </mif:tr>
                        <mif:tr>
                           <mif:td>198706052000</mif:td>
                           <mif:td>2 hour</mif:td>
                           <mif:td>1</mif:td>
                           <mif:td>â</mif:td>
                           <mif:td>
								Sequence starting on June 5, 1987 at 7 PM and
								incrementing every two hours: 9 PM, 11 PM, 1 AM (June 6), 3
								AM, 5 AM, and so on.
							</mif:td>
                        </mif:tr>
                        <mif:tr>
                           <mif:td>0 V</mif:td>
                           <mif:td>1 mV</mif:td>
                           <mif:td>1</mif:td>
                           <mif:td>100</mif:td>
                           <mif:td>
								The x-wave of a digital oscillograph scanning between
								0 and 100 mV in 100 steps of 1 mV. The frequency is unknown
								from these data as we do not know how much time elapses
								between each step of the index.
							</mif:td>
                        </mif:tr>
                        <mif:tr>
                           <mif:td>2002072920300</mif:td>
                           <mif:td>100 us</mif:td>
                           <mif:td>1</mif:td>
                           <mif:td>â</mif:td>
                           <mif:td>
								A timebase from June 29,
								2002 at 8:30 PM with 100 us between each steps of the
								index. If combined with the previous generator as a second
								sampling dimension this would now describe our digital
								oscilloscope's x-timebase as 1 mV per 100 us. At 100 steps
								per period, the period is 10 ms, which is equal to a
								frequency of 100 Hz.
							</mif:td>
                        </mif:tr>
                        <mif:tr>
                           <mif:td>0 V</mif:td>
                           <mif:td>1 mV</mif:td>
                           <mif:td>100</mif:td>
                           <mif:td>100</mif:td>
                           <mif:td>
								Combining this generator to the previous two generators
								could describe a three-dimensional sampling space with two
								voltages and time. This generator also steps at 1 mV and has
								100 steps per period, however, it only steps every 100 index
								increments, so, the first voltage generator makes one full
								cycle before this generator is incremented. One can think of
								the two voltages as "rows" and "columns" of a "sampling
								frame". With the previous generator as the timebase, this
								results in a scan of sampling frames of 100 mV Ã 100
								mV with a framerate of 1 Hz.
							</mif:td>
                        </mif:tr>
                     </mif:tbody>
                  </mif:table>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type GeneratedSequence&lt;T&gt; alias GLIST&lt;T&gt; specializes LIST&lt;T&gt; {
   T.diffType  increment;
   INT  period;
   INT  denominator;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(GLIST&lt;T&gt; list, INT index)
      where list.nonNull.and(index.nonNull) {
   list.period.nonNull.implies(list.item(index).equal(
      list.head.plus(item.dividedBy(list.increment.denominator)
          .remainder(list.period)).times(increment)));
   list.period.isNull.implies(list.item(index).equal(
      list.head.plus(item.dividedBy(list.increment.denominator))
          .times(increment)));
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="head" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Head Item"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The start-value of the generated list.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="LIST"/>
         </mif:derivedFrom>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="increment" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Increment"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The difference between one value and the previous different value.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						For example, to generate the sequence (1; 4; 7; 10; 13; ...) the
						increment is 3; likewise, to generate the sequence (1; 1; 4; 4; 7; 7;
						10; 10; 13; 13; ...), the increment is also 3.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(GLIST&lt;T&gt; x, T.diffType y) where x.nonNull.and(y.isZero) {
   x.increment.greaterThan(y);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="T" qualifier="parameterDiff"/>
      </mif:property>
      <mif:property name="period" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Period Step Count"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						If non-NULL, the duration over which the sequence repeats.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p> 
					    I.e., after this
						many increments, the sequence item values roll over to start from the
						initial sequence item value. For example, the sequence (1; 2; 3; 1; 2;
						3; 1; 2; 3; ...) has period 3; also the sequence (1; 1; 2; 2; 3; 3; 1;
						1; 2; 2; 3; 3; ...) has period 3 too.
					</mif:p>
                     <mif:p>
						The period allows the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> to repeatedly sample the same value space.  The
						waveform of this periodic generator is always a "saw," just like the
						x-function of an oscilloscope.<mif:object name="footnote">
								Note the difference to the . The  is
								a generator for a  not for a
								.  A sequence of discrete
								values from a continuous domain makes not much sense other than in sampling
								applications. The , however,
								can be thought of as a sequence of , which still is different from a
								.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(GLIST&lt;T&gt; x) where x.nonNull {
   x.period.nonNull.implies(x.period.greaterThan(0));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="denominator" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Denominator"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The integer by which the index for the sequence is divided,
						giving the number of times the sequence generates the same
						sequence item value before incrementing to the next sequence item
						value. For example, to generate the sequence (1; 1; 1; 2; 2; 2; 3; 3;
						3; ...)  the denominator is 3.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The denominator allows multiple generated sequences to
						periodically scan a multidimensional space. For example, an (abstract)
						TV screen might use 2 such generators for the columns and rows of
						pixels. If there were 200 scan lines and 320 raster
						columns, the column-generator would have denominator 1, and the
						line-generator would have denominator 320.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(GLIST&lt;T&gt; x) where x.nonNull {
   x.denominator.nonNull;
   x.denominator.greaterThan(0);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="equal" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as
						the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="LIST"/>
                        </mif:object> data type: Two nonNull <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="LIST"/>
                        </mif:object>s are
						equal if they have the same elements.<mif:object name="footnote">
								This means that values of the type GLIST and any other kind of LIST may be equal.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="LIST">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="SLIST" title="SampledSequence" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="LIST"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A sequence of sampled values scaled and translated from a list of
					integer values.  
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is used to specify sampled biosignals. The parameter T must be a type of<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QTY"/>
                     </mif:object>.
					A <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> contains a list of integers. The item at a certain index (<mif:var>i</mif:var>) in the list is calculated
					by multiplying the item at the same index in the
					<mif:object name="propertyRef">
                        <mif:param name="propertyName" value="digits"/>
                        <mif:param name="datatypeName" value="SLIST"/>
                     </mif:object> sequence
					(<mif:var>d</mif:var>
                     <mif:sub>
                        <mif:var>i</mif:var>
                     </mif:sub>) with the
					<mif:object name="propertyRef">
                        <mif:param name="propertyName" value="scale"/>
                        <mif:param name="datatypeName" value="SLIST"/>
                     </mif:object> (<mif:var>s</mif:var>)
					and then add that value to the <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="origin"/>
                        <mif:param name="datatypeName" value="SLIST"/>
                     </mif:object>
					(<mif:var>x</mif:var>
                     <mif:sub>
                        <mif:var>o</mif:var>
                     </mif:sub>).
				</mif:p>
                  <mif:blockquote>
                     <mif:p>
                        <mif:var>x</mif:var>
                        <mif:sub>
                           <mif:var>i</mif:var>
                        </mif:sub>=<mif:var>x</mif:var>
                        <mif:sub>
                           <mif:var>o</mif:var>
                        </mif:sub> + <mif:var>s</mif:var>
						Ã <mif:var>d</mif:var>
                        <mif:sub>
                           <mif:var>i</mif:var>
                        </mif:sub>
                     </mif:p>
                  </mif:blockquote>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is usually used for measured values of type <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PQ"/>
                     </mif:object>. 
					The <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is just a list of values; in order to 
					fully understand the data, information concerning the sampling conditions must be provided separately.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type SampledSequence&lt;T&gt; alias SLIST&lt;T&gt; specializes LIST&lt;T&gt; {
   T          origin;
   T.diffType        scale;
   LIST&lt;INT&gt;  digits;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SLIST&lt;T&gt; list, INT index)
      where list.nonNull.and(index.nonNegative) {
   list.item(index).equal(
      list.scale.times(digits.item(index))
          .plus(list.origin));
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="origin" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Scale Origin"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The origin of the list item value scale, i.e., the physical quantity
						that a zero-digit would represent in the sequence of values.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="scale" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Scale Factor"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A ratio-scale quantity that is factored out of the digit sequence.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="T" qualifier="parameterDiff"/>
      </mif:property>
      <mif:property name="digits" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Sampled Digits"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A sequence of raw digits representing the sample values.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						This is typically the
						raw output of an A/D converter.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="LIST">
            <mif:argumentDatatype name="INT"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as
						the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="LIST"/>
                        </mif:object> data type: Two nonNull <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="LIST"/>
                        </mif:object>s are
						equal if they have the same elements.<mif:object name="footnote">
								This means that values of the type SLIST and any other kind of LIST may be equal.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="LIST">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="QSET" title="ContinuousSet" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
            <mif:argumentDatatype name="CEQ">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:argumentDatatype>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An unordered set of distinct values which are quantities.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					Continuous sets are distinguished from discrete sets in that they may contain an infinite number of elements, viz., 
					a period of time containing infinitely many points in time that can be defined to an arbitrary level of precision.
				</mif:p>
                  <mif:p>
					Although <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> provides methods to test for membership of the set, it does not actually
					contain any properties that specify what the contents of the set are. An instance of a 
					<mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is constructed by combining the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> builder types in an expression
					tree using mathematical operation types. The expression tree specifies exactly which 
					values are part of the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>. The central <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> builder type is <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object>
					which specifies a contiguous range of values. Multiple intervals may be combined into 
					expressions using the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> specializations for mathematical operations: 
					union (<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSU"/>
                     </mif:object>), intersection (<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSI"/>
                     </mif:object>), difference (<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSD"/>
                     </mif:object>), 
					and periodic hull (<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSP"/>
                     </mif:object>). In addition, there are special types for 
					periodically repeating intervals (<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PIVL"/>
                     </mif:object>), event-related intervals (<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="EIVL"/>
                     </mif:object>),
					and <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSC"/>
                     </mif:object> which allows common timing expressions to be represented as simple codes.
					Note that <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="GTS"/>
                     </mif:object> is a full alias for <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object>&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object>&gt;.
				</mif:p>
                  <mif:p>
					Since the semantics of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> are tightly bound to the definitions of equality in the <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QTY"/>
                     </mif:object>
					specializations, it is never appropriate to redefine the meaning of uniqueness in these sets, and all
					<mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s use the default comparator <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="CEQ"/>
                     </mif:object>. Membership of the set is always based on equality.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
abstract type ContinuousSet&lt;T&gt; alias QSET&lt;T&gt; specializes SET&lt;T, CEQ&lt;T&gt;&gt; {
    IVL&lt;T&gt;    hull;
    IVL&lt;T&gt;    intervalAt(T x);
    IVL&lt;T&gt;    intervalAtOrAfter(T x);
    IVL&lt;T&gt;    intervalAfter(T x);
    BL        interleaves(QSET&lt;T&gt; x);
    QSET&lt;T&gt;   periodicHull(QSET&lt;T&gt; x);
    ED.TEXT   originalText;
  demotion  LIST&lt;IVL&lt;T&gt;&gt;;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="hull" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Convex Hull of Totally Ordered Sets"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							Given a totally ordered set <mif:b>S</mif:b>, the smallest interval that is a superset of <mif:b>S</mif:b>. 
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							Continuous Sets are totally ordered sets because there is an order
							relationship defined between any two elements in the set,<mif:object name="footnote">
									Note that "ordered set" does not mean the same as Sequence ().
									For example, the set {3; 2; 4; 88; 1} is an ordered set. The ordering of the elements
									in the set notation is still irrelevant, but elements can be compared to establish an
									order (1; 2; 4; 88).
								</mif:object>
							and because all elements in the set must be comparable.<mif:object name="footnote">
									Note that the data type of the elements itself need not be totally ordered. For
									example, the data type  is only partially ordered (since only
									quantities of the same kind can be compared), but a  may
									still be totally ordered if it contains only comparable quantities. For example,
									{4 s, 20 s, 55 s} is a valid , while  is [4 s;55 s], while {2 m; 4 m; 8 s} is
									not a valid , because it is not totally ordered (seconds are not
									comparable with meters).
								</mif:object>
                     </mif:p>
                     <mif:p>
							As totally ordered sets, Continuous Sets have a convex hull. 
						</mif:p>
                     <mif:img imageType="application/jpeg" src="datyp2fig11.jpg"
                              alt="Convex Hull of a Totally Ordered Set"/>
                     <mif:p>
						The convex hull of a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> can less formally be called the "outer bound
						interval". Thus the convex hull of a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
						describes the absolute beginning and end of a schedule. For some set specifications,
						where there are infinite repetitions (e.g., a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PIVL&lt;TS&gt;"/>
                        </mif:object>) the
						convex hull has infinite bounds. The term schedule is used throughout this section
						in its general sense, that of an organized series of values. The more common meaning
						of the term schedule, that of a time-based plan of events, is exactly a 
						<mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>&lt;<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object>&gt;.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QSET&lt;T&gt; s) where s.nonNull {
   forall(QTY x, y) where s.contains(x).and(s.contains(y)) {
      x.isComparableTo(y);
  };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QSET&lt;T&gt; s) where s.nonNull {
   s.hull.contains(s);
   forall(T e)
         where s.contains(e) {
      s.hull.low.lessOrEqual(e);
      e.lessOrEqual(s.hull.high);
      };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="intervalAt" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Interval At"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							Given a value <mif:b>t</mif:b>,
							the greatest continuous subset <mif:b>v</mif:b> (an "occurrence interval") of
							the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value <mif:b>S</mif:b>, where <mif:b>v</mif:b> includes <mif:b>x</mif:b>.
							If there is no occurrence interval that includes v, intervalAt(x) will be null.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QSET&lt;T&gt; s, TS t) {
   s.contains(t).not.implies(s.intervalAfter(t).equal(s.intervalAtOrAfter(t)));
   s.contains(t).implies(s.intervalAfter(t).equal(
               s.except(intervalAtOrAfter(t)).intervalAtOrAfter(t)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="intervalAtOrAfter" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Interval At or After"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							Given a value <mif:b>t</mif:b>, 
							the greatest continuous subset <mif:b>v</mif:b> (an "occurrence interval") of
							the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value <mif:b>S</mif:b>, where <mif:b>v</mif:b> is the interval that
							contains <mif:b>t</mif:b> or the first interval that has a low value greater
							than <mif:b>t</mif:b>.
						</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QSET&lt;T&gt; s, T t, IVL&lt;T&gt; v) {
   v.equal(s.intervalAtOrAfter(t)).equal(
      s.contains(o).and(
         forall(IVL&lt;T&gt; u) where x.contains(u) {
            u.contains(v).implies(u.equal(v));
            })
         .and(v.contains(t).or(forall(T i) where t.lessOrEqual(i)
               .and(i.lessThan(v.low)) {
            s.contains(i).not; })));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="intervalAfter" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Interval After"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							Given a value <mif:b>t</mif:b>,
							the greatest continuous subset <mif:b>v</mif:b> (an "occurrence interval") of
							the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value <mif:b>S</mif:b>, where <mif:b>v</mif:b> is the first interval
							that has a low value greater than <mif:b>t</mif:b>.
					</mif:text>
               </mif:definition>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QSET&lt;T&gt; s, TS t) {
   s.contains(t).not.implies(s.intervalAfter(t).equal(s.intervalAtOrAfter(t)));
   s.contains(t).implies(s.intervalAfter(t).equal(
               s.except(intervalAtOrAfter(t)).intervalAtOrAfter(t)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="interleaves" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Interleaves"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							For two <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> values <mif:b>A</mif:b> and <mif:b>B</mif:b>, <mif:b>A</mif:b> interleaves <mif:b>B</mif:b> if their occurrence
							intervals alternate consistently with no overlap on the time line. This concept is visualized in the Figure below.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:img imageType="application/jpeg" src="datyp2fig15.jpg"
                              alt="Interleaving occurence intervals and Periodic Hull"/>
                     <mif:p>
						For <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values <mif:b>A</mif:b> and <mif:b>B</mif:b>
						to interleave, the occurrence intervals of both groups must be capable of being arranged
						in pairs of corresponding occurrence intervals. It must further hold
						that for all corresponding occurrence intervals <mif:b>a</mif:b>
						â <mif:b>A</mif:b> and <mif:b>b</mif:b> â <mif:b>B</mif:b>,
						<mif:b>a</mif:b> starts before <mif:b>b</mif:b> starts (or at the same
						time) and <mif:b>b</mif:b> ends after <mif:b>a</mif:b> ends (or at the
						same time).
					</mif:p>
                     <mif:p>
						The interleaves-relation holds when two schedules have the same
						average frequency, and when the second schedule never "outpaces" the
						first schedule. That is, no occurrence interval in the second schedule
						may start before its corresponding occurrence interval in the first
						schedule.
					</mif:p>
                     <mif:p>
					The interleaves-relation is reflexive, asymmetric, and
					intransitive.<mif:object name="footnote">
								The interleaves property may appear overly constrained. However, these
								constraints are reasonable for the use case for which the interleaves
								and periodic hull properties are defined. To safely and predictably
								combine two schedules one would want to know which of the operands
								sets the start points and which sets the endpoints of the periodic
								hull's occurrence intervals.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QSET&lt;T&gt; A, B)
      where x.nonNull.and(y.nonNull) {
   A.interleaves(B).equal(
      forall(IVL&lt;T&gt; a, b, c; T t)
         where a.equal(A.intervalAtOrAfter(t))
                .and(b.equal(B.intervalAtOrAfter(a.low)))
                .and(c.equal(A.intervalAtOrAfter(b.high))) {
            b.equal(B.intervalAtOrAfter(a.high));
            a.low.lessOrEqual(b.low);
            c.equal(A.intervalAtOrAfter(b.high));
            c.equal(a).or(c.equal(A.intervalAfter(a.high)));
            });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QSET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="periodicHull" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Periodic Hull"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						For two <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> values <mif:b>A</mif:b> and <mif:b>B</mif:b>
						where <mif:b>A</mif:b> interleaves <mif:b>B</mif:b>, a periodic hull is
						defined as the set of convex hulls of the corresponding occurrence
						intervals of <mif:b>A</mif:b> and <mif:b>B</mif:b>.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						With two interleaving <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> values, one can derive a
						periodic hull such that each occurrence interval of the periodic hull
						is the convex hull of a pair of corresponding occurrence intervals.
					</mif:p>
                     <mif:p>
						The periodic hull may be used to construct episodic durations by combining
						<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="QSET&lt;TS&gt;"/>
                        </mif:object> expressions. For example, to construct the periodic
						interval from Memorial Day to Labor Day every year, one first needs to
						set up the schedules <mif:b>M</mif:b> for Memorial Day (the last Monday
						in May) and <mif:b>L</mif:b> for Labor Day (the first Monday in
						September) and then combine these two schedules using the periodic
						hull of <mif:b>M</mif:b> and <mif:b>L</mif:b>.
					</mif:p>
                     <mif:p>
						The periodic hull operation is non-commutative and
						non-associative.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QSET&lt;T&gt; A, B, C)
      where A.interleaves(B) {
   A.periodicHull(B).equal(C).equal(
      forall(IVL&lt;T&gt; a, b; T t)
         where a.equal(A.intervalAtOrAfter(t))
                .and(b.equal(B.intervalAtOrAfter(a.low))) {
            C.contains(c).equal(c.equal(a.hull(b)));
            });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QSET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="QSET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as
						the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="SET"/>
                        </mif:object> data type: Two nonNull <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="SET"/>
                        </mif:object>s are
						equal if they have the same elements.<mif:object name="footnote">
								This means that values of the type QSET and any other kind of SET may be equal.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="SET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="originalText" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Original Text"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
					    The text representation from which the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> was encoded, if such a representation is the source
						of the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>. Original text can be used in a structured user interface to capture what the user
						saw as a representation of the code on the data input screen, or in a situation where the user dictates
						or directly enters text, it is the text entered or uttered by the user.
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The originalText is not a substitute for a valid value. If the actual content of the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is not
						valid, then the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> SHALL be null, irrespective of whether originalText has a value or not.
					</mif:p>
                     <mif:p>
							Note that although post-coding is often performed from free text information,
							such as documents, scanned images or dictation, multi-media data is
							explicitly not permitted as original text. Also, the original text
							property is not meant to be a link into the entire source
							document. The link between different artifacts of medical information
							(e.g., document and coded result) is outside the scope of this
							specification and is maintained elsewhere in the HL7 standards. The
							original text SHALL be an excerpt of the relevant information in the
							original sources, rather than a pointer or exact reproduction. Thus
							the original text SHALL be represented in plain text form. In specific
							circumstances, as described in other HL7 specifications, the originalText
							may be a reference to some other text artefact for which the resolution
							scope is clearly described. 
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="ED.TEXT"/>
      </mif:property>
      <mif:property name="demotion" sortKey="09" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Demotion of QSET to LIST"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							A <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> value can be converted into a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="LIST&lt;IVL&lt;T&gt;&gt;"/>
                        </mif:object>.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QSET&lt;T&gt;  x)
      where x.isEmpty {
   ((LIST&lt;IVL&lt;T&gt;&gt;)x).isEmpty; };

invariant(QSET&lt;T&gt; x, IVL&lt;T&gt; first)
      where x.notEmpty.and(x.hull.low.nonNull)
                      .and(first.equal(x.intervalAtOrAfter(x.hull.low))) {
   ((LIST&lt;IVL&lt;T&gt;&gt;)x).head.equal(first);
   ((LIST&lt;IVL&lt;T&gt;&gt;)x).tail.equal(
      (LIST&lt;IVL&lt;T&gt;&gt;)x.except(first));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="LIST">
            <mif:argumentDatatype name="IVL">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:argumentDatatype>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="QSU" title="ContinuousSetUnion" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A Term in a <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="QSET"/>
                  </mif:object> expression that builds a <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="QSET"/>
                  </mif:object> from a union
					of other <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="QSET"/>
                  </mif:object>s.
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type ContinuousSetUnion&lt;T&gt; alias QSU&lt;T&gt; specializes QSET&lt;T&gt; {
    DSET&lt;QSET&lt;T&gt;&gt;   terms;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="terms" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Terms"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="DSET"/>
                     </mif:object> of other <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object>s from which the union is
						built using the <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="SET"/>
                     </mif:object> union operator.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="DSET">
            <mif:argumentDatatype name="QSET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:argumentDatatype>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="QSI" title="ContinuousSetIntersection" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A Term in a <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="QSET"/>
                  </mif:object> expression that builds a <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="QSET"/>
                  </mif:object> from an intersection
					of other <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="QSET"/>
                  </mif:object>s.
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type ContinuousSetIntersection&lt;T&gt; alias QSI&lt;T&gt; specializes QSET&lt;T&gt; {
    DSET&lt;QSET&lt;T&gt;&gt;   terms;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="terms" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Terms"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						A <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="DSET"/>
                     </mif:object> of other <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object>s from which the intersection is
						built using the <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="SET"/>
                     </mif:object> intersection operator.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="DSET">
            <mif:argumentDatatype name="QSET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:argumentDatatype>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="QSD" title="ContinuousSetDifference" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A Term in a <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="QSET"/>
                  </mif:object> expression that builds a <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="QSET"/>
                  </mif:object> from the
					difference between 2 <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="QSET"/>
                  </mif:object>s.
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type ContinuousSetDifference&lt;T&gt; alias QSD&lt;T&gt; specializes QSET&lt;T&gt; {
    QSET&lt;T&gt;   minuend;
    QSET&lt;T&gt;   subtrahend;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="minuend" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Minuend"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The set that performs the difference operation.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="QSET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="subtrahend" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Subtrahend"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The parameter to the difference operation.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="QSET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="QSP" title="ContinuousSetPeriodicHull" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A Term in a <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="QSET"/>
                  </mif:object> expression that builds a <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="QSET"/>
                  </mif:object> from the
					difference between 2 <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="QSET"/>
                  </mif:object>s.
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type ContinuousSetPeriodicHull&lt;T&gt; alias QSP&lt;T&gt; specializes QSET&lt;T&gt; {
    QSET&lt;T&gt;   low;
    QSET&lt;T&gt;   high;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="low" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Low"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The set that performs the periodic hull operation.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="QSET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="high" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="High"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
						The parameter to the periodic hull operation.
					</mif:text>
               </mif:definition>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="QSET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="QSC" title="CodedContinuousSet" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="CS"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A Term in a <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="QSET"/>
                  </mif:object> expression that builds a <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="QSET"/>
                  </mif:object> from a coded value.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					The code unambiguously describes a <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object>&lt;T&gt; 
					such that <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object> properties can be supported. <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> SHALL only be used with 
					parameter types for which HL7 has defined domains and their associated codeSystems. At present 
					HL7 has only done this for <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object>, which is the domain GTSAbbreviation, associated with
					the codeSystem defined below. 
				</mif:p>
                  <mif:div title="GTSAbbreviation: Codes for &lt;&gt;.">datyp2gtslitsym
							
								
								
								
							
							
							
							
							
							
							
							
							

								 
									
									
									
									
									
									
								
								
									
									
									
									
									
									
									
									
									
									
									
									
									
								
							
						
								This table is not complete, nor does it include religious holidays
								other than Christian (of the Gregorian [Western] tradition) or
								national holidays countries other than those of the US. This
								is a limitation to be remedied by subsequent additions.
							
								Holidays are locale-specific. Exactly which religious holidays are
								subsumed under JH depends on the locale and other tradition. For
								global interoperability, using constructed 
								expressions is safer than named holidays. However, some holidays that
								depend on moon phases (e.g., Easter) or ad-hoc decree cannot be easily
								expressed in a  other than by use .
							
							Where possible, table  defines 
							literal values for  values that could be used in
							 literals in place of a coded value. Codes
							are defined for common periods of the day (AM, PM),
							for periods of the week (business day, weekend), and for holidays.
							The computation for the dates of some holidays, namely
							the Easter holiday, involve some sophistication that goes beyond what
							one would represent in a  literal. It is
							assumed that the dates of these holidays are drawn from some table or
							some generator module that is outside the scope of this specification.
						</mif:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type CodedContinuousSet&lt;T&gt; alias QSC&lt;T&gt; specializes QSET&lt;T&gt;, CS;</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="IVL" title="Interval" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A set of consecutive values of an ordered base data type.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					Any ordered type can be the basis of an <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>; it does not matter
					whether the base type is discrete or continuous. If the base data type
					is only partially ordered, all elements of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> must be
					elements of a totally ordered subset of the partially ordered data
					type. 
				</mif:p>
                  <mif:p>
					For example, <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PQ"/>
                     </mif:object> is considered ordered. However the
					ordering of <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PQ"/>
                     </mif:object>s is only partial; a total order is only
					defined among comparable quantities (quantities of the same physical
					dimension).  While <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s between 2 and 4 meter exist, there is no
					<mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> between 2 meters and 4 seconds.
				</mif:p>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s are <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="SET"/>
                     </mif:object>s and have all the properties of
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="SET"/>
                     </mif:object>s. However, union and difference of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s
					may not be <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s, since the elements of these union and
					difference <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="SET"/>
                     </mif:object>s might not be
					contiguous. Intersections of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s are always <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s.
				</mif:p>
                  <mif:p>
							An interval specifies a set where all values apply simultaneously 
							(e.g. The encounter lasted from January 6th through January 12th).  For situations 
							where only one value within the specified range (e.g. "Take 2-4 tablets"), the 
							<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value=""/>
                     </mif:object> type should be used. Intervals arise commonly with time, 
							so intervals of <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object> are the most common type encountered. 
							Uses for intervals of <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PQ"/>
                     </mif:object> include age &gt; 65, blood 
							pressure &lt; 150 mm Hg, an instruction to keep systolic bp between 80 and 110 mmHg,
							or the width a stain on an electrophoresis gel.
						</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type Interval&lt;T&gt; alias IVL&lt;T&gt; specializes QSET&lt;T&gt; {
              T       low;
              T       high;
              QTY     width;
              T       center;
              BL      lowClosed;
              BL      highClosed;
              T       any;
              IVL&lt;T&gt;  hull(IVL&lt;T&gt; x);
   literal    ST.SIMPLE;
   promotion  IVL&lt;T&gt;  (T x);
   demotion   T;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="low" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Low Boundary"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The low limit of the interval.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							The low limit SHALL NOT be positive infinity. 
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; x; T e)
      where x.nonNull.and(x.contains(e)) {
   x.low.lessOrEqual(e);
   x.low.nullFlavor.implies(NullFlavor.PINF).not;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="high" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="High Boundary"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The high limit of the interval.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							The high limit SHALL NOT be negative infinity, and SHALL be higher than the low limit if one exists. 
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; x; T e)
      where x.nonNull.and(x.contains(e)) {
   e.lessOrEqual(x.high);
   x.high.nullFlavor.implies(NullFlavor.NINF).not;
};

invariant(IVL&lt;T&gt; x)
    where x.low.nonNull.and(x.high.nonNull) {
	x.low.lessOrEqual(x.high);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="width" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Width"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The difference between <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="HIGH"/>
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object> and <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="LOW"/>
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object>
							boundary. The purpose of distinguishing <mif:object name="itemName">
                        <mif:param name="item" value="property"/>
                     </mif:object> is to handle all cases of incomplete
							information symmetrically. In any <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> representation only two of
							the three properties <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="HIGH"/>
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object>, <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="LOW"/>
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object>,
							and <mif:object name="itemName">
                        <mif:param name="item" value="property"/>
                     </mif:object> need to be stated: the third can be derived.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							When both boundaries are known, <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> can be derived as
							<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="HIGH"/>
                           <mif:param name="datatypeName" value="IVL"/>
                        </mif:object> minus <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="LOW"/>
                           <mif:param name="datatypeName" value="IVL"/>
                        </mif:object>.
							When one boundary and <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is known, the other boundary is
							also known. When no boundary is known, <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> may still be
							known. For example, one knows that an activity takes about 30 minutes,
							but one may not yet know when that activity is started.
						</mif:p>
                     <mif:p>
							Note that the data type of <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is not always the same as for the
							boundaries. For ratio scale quantities (<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object>,
							<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object>, <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="MO"/>
                        </mif:object>) it is the same. For
							difference scale quantities (e.g., <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object>) is
							the data type of the difference (e.g., <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object> in
							the dimension of time for <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object>).
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; x) where x.low.nonNull.and(x.high.nonNull) {
   x.low.lessOrEqual(x.high);
   x.width.equal(x.high.minus(x.low));
};

invariant(IVL&lt;T&gt; x, T.diffType z) 
  where x.low.nonNull.and(x.high.nonNull).and(z.isZero) {
   x.width.greaterOrEqual(z);
};

invariant(IVL&lt;T&gt; x) {
   x.width.dataType.implies(T.diffType);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="QTY"/>
      </mif:property>
      <mif:property name="center" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Central Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The arithmetic mean of the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>
							(<mif:object name="propertyRef">
                        <mif:param name="propertyName" value="LOW"/>
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object> plus <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="HIGH"/>
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object> divided by 2). The
							purpose of distinguishing <mif:object name="itemName">
                        <mif:param name="item" value="property"/>
                     </mif:object> as a semantic property is for
							conversions of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s to and from point values. For discrete elements
							(<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="INT"/>
                     </mif:object>) the center is the floor of true arithmetic center.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							Note that <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> doesn't always exist for every <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>.
							Notably <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>s that are infinite on one side do not have
							<mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object>. Also <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>s of discrete base types with an
							even number of elements do not have a <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object>. 
						</mif:p>
                     <mif:p>
							If the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> only has one boundary, and the other is the appropriate
							flavor of infinity, the center is also infinity. If both boundaries
							are infinity, the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> has no center.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; x)
      where x.low.nonNull.and(x.high.nonNull) {
   x.center.equal(x.low.plus(x.width.dividedBy(2)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; x) 
   where x.low.nonNull.xor(x.high.nonNull) {
   x.low.nullFlavor.implies("NINF").implies(x.center.nullFlavor.implies("NINF"));
   x.high.nullFlavor.implies("PINF").implies(x.center.nullFlavor.implies("PINF"));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="lowClosed" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Low Boundary Closed"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							Specifies whether <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="LOW"/>
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object> is included in the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>
							(is closed) or excluded from the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> (is open).
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						 	 The default value is true (closed).
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; x)
      where x.nonNull {
   x.low.nonNull.implies(x.lowClosed.equal(x.contains(x.low)));
   x.low.isNull.implies(x.lowClosed.not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="highClosed" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="High Boundary Closed"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							Specifies whether <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="HIGH"/>
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object> is included in the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>
							(is closed) or excluded from the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> (is open). 
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						 	 The default value is true (closed).
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; x)
      where x.nonNull {
   x.high.nonNull.implies(x.highClosed.equal(x.contains(x.high)));
   x.high.isNull.implies(x.highClosed.not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="any" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Contained Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							Specifies that nothing is known about the interval except that some particular value
							lies within the interval.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							This should be used when it is not known when something started, or will end, but
							it is known that it was happening at a given time. This is relatively common for observations
							(i.e. of disease processes), procedure, and scheduling.
						</mif:p>
                     <mif:p>
							If <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> has value, then nothing else is known about the interval, except that the
							interval contains any. Althought not much is known about the interval, it is still possible
							to determine whether the interval overlaps with another.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; x)
      where x.nonNull.and(x.any.nonNull) {
   x.low.isNull;
   x.high.isNull;
   x.center.isNull;
   x.width.isNull;
   x.lowClosed.isNull;
   x.highClosed.isNull;
};

invariant(IVL&lt;T&gt; ivl, T t)
       where ivl.any.nonNull.and(vl.any.equals(t)) {
  ivl.contains(t);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; set, IVL&lt;T&gt; ivl)
    where set.nonNull.and(ivl.nonNull) {  
  set.contains(ivl.any).implies(set.intersection(ivl).isEmpty.not);
  set.contains(ivl.any).not.implies(set.intersection(ivl).isNull);
};
</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="hull" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Convex Hull"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The convex hull of the set specified by the interval.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						  The interval is automatically the convex hull of set that it specifies, so the convex hull of an interval is itself.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; i) 
    where i.nonNull {
   i.equal(i.hull());
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QSET"/>
         </mif:derivedFrom>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="hull" sortKey="09" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Convex Hull"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A convex hull or "interval hull" of two <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s is the least
							<mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> that is a superset of its operands.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:img imageType="application/jpeg" src="datyp2fig12.jpg"
                              alt="Convex Hull of two Intervals"/>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; h, IVL&lt;T&gt; i, j)
      where h.nonNull.and(h.equal(i.hull(j))) {
   i.low.lessOrEqual(j.low).implies(h.low.equal(i.low));
   j.low.lessOrEqual(i.low).implies(h.low.equal(j.low));
   i.high.lessOrEqual(j.high).implies(h.high.equal(j.high));
   j.high.lessOrEqual(i.high).implies(h.high.equal(i.high));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="IVL">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="literal" sortKey="10" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							The literal form for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is defined such that it is
							as intuitive to humans as possible. Seven different forms are
							defined:<mif:object name="footnote">
									The presence of so many options deserves explanation. In principle,
									the interval form together with the width-only form would be
									sufficient. However, the interval form is felt alien to many in the
									field of medical informatics. One important purpose of the literal
									forms is to eradicate non-compliance through making compliance easy,
									without compromising on the soundness of the concepts.
								
									Furthermore, the different literal forms all have strength and
									weaknesses. The interval and center-width forms' strength is that they
									are most exact, showing closed and open boundaries. The interval
									form's weakness, however, is that infinite boundaries require special
									symbols for infinities, not necessary in the "comparator" form. The
									center-width form cannot specify intervals with an infinite boundary
									at all. The "comparator" form, however, can only represent
									single-bounded intervals (i.e., where the other boundary is infinite
									or unknown).  The dash form, while being the weakest of all, is the
									most intuitive form for double bounded intervals.
								</mif:object>
                     </mif:p>
                     <mif:ol>
                        <mif:li/>
                        <mif:li/>
                        <mif:li/>
                        <mif:li/>
                        <mif:li/>
                        <mif:li/>
                        <mif:li/>
                     </mif:ol>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
IVL&lt;T&gt;.literal ST.SIMPLE {
   IVL&lt;T&gt; range : interval                { $.equal($1); }
                | dash                    { $.equal($1); }
                | comparator              { $.equal($1); }
                | center_width            { $.equal($1); }
                | width                   { $.equal($1); }
                | center                  { $.equal($1); }
                | any                     { $.equal($1); };

   IVL&lt;T&gt; interval
                : open T ";" T close;     { $.low.equal($2);
                                            $.high.equal($4);
                                            $.lowClosed.equal($1);
                                            $.highClosed.equal($5); };
   BL open      : "["                     { $.equal(true); }
                | "]"                     { $.equal(false); };
   BL close     : "]"                     { $.equal(true); }
                | "["                     { $.equal(false); };
   IVL&lt;T&gt; width
                : open T.diffType close   { $.width.equal($2);
                                            $.lowClosed.equal($1);
                                            $.highClosed.equal($3); };
   IVL&lt;T&gt; center_width
                : T width                 { $.center.equal($1);
                                            $.width.equal($2.width);
                                            $.lowClosed.equal($2.lowClosed);
                                            $.highClosed.equal($2.highClosed); };

   IVL&lt;T&gt; center
                : T width                 { $.center.equal($1)};
                
   IVL&lt;T&gt; any
                : "? T "?"                 { $.any.equal($1)};
                
   IVL&lt;T&gt; dash  : T "-" T;                { $.low.equal($2);
                                            $.high.equal($4);
                                            $.lowClosed.equal(true);
                                            $.highClosed.equal(true); };
   IVL&lt;TS&gt; comparator
                : "&lt;"  T                  { $.high.equal(T);
                                            $.high.closed(false);
                                            $.low.negativelyInfinite; }
                | "&gt;"  T                  { $.low.equal(T);
                                            $.low.closed(false);
                                            $.high.positivelyInfinite; }
                | "&lt;=" T                  { $.high.equal(T);
                                            $.high.closed(true);
                                            $.low.negativelyInfinite; }
                | "&gt;=" T                  { $.low.equal(T);
                                            $.low.closed(true);
                                            $.high.positivelyInfinite; };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="promotion" sortKey="11" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Promotion of Element Values to Intervals"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							An integer can be promoted into a trivial <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
							where <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="LOW"/>
                           <mif:param name="datatypeName" value="IVL"/>
                        </mif:object> and <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="HIGH"/>
                           <mif:param name="datatypeName" value="IVL"/>
                        </mif:object>
							are equal and boundaries closed.
						</mif:p>
                     <mif:p>
							Where T is a type that represents a continuous domain, the conversion
							to an interval is a function of the precision of the value. The value will convert
							to an interval centered on the value of T, with the lower and upper limits expressing
							the range that is implied by the precision.
						</mif:p>
                     <mif:p>
						A <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object> is promoted to an <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="IVL_TS"/>
                        </mif:object>
						whereby the low boundary is the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object> value itself, and
						the width is inferred from the precision of the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object>
						and the duration of the least significant calendar period specified.
						The high boundary is open. For example, the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object> literal
						"200009" is converted to an <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="IVL_TS"/>
                        </mif:object> with low
						boundary 200009 and width 30 days, which is the interval
						"[20000901000000.000;20001001000000.000[".
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x) where x.nonNull {
   ((IVL&lt;INT&gt;)x).low.equal(x);
   ((IVL&lt;INT&gt;)x).high.equal(x);
   ((IVL&lt;INT&gt;)x).highClosed;
   ((IVL&lt;INT&gt;)x).lowClosed;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(T x) where x.nonNull.and(T.equals(INT).not).and(T.equals(TS).not) {
   ((IVL&lt;T&gt;)x).center.equal(x);
   ((IVL&lt;T&gt;)x).highClosed.not;
   ((IVL&lt;T&gt;)x).lowClosed;
   /* cannot make formal statements about low and high*/
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(TS x) where x.nonNull {
   /*
   ((IVL&lt;TS&gt;)x).low.equal(x); 
   
   this is not true, the precision of low is arbitrarily high
   and therefore they are not equal */
   
   ((IVL&lt;T&gt;)x).highClosed.not;
   ((IVL&lt;T&gt;)x).lowClosed;
   
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="demotion" sortKey="12" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Demotion of Intervals to a Representative Element Value"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							An <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> can be demoted to a simple quantity of type T that is
							representative for the whole <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>. If the interval bounds
							match the bounds expected for a single value/precision combination,
							as defined in <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="promotionT"/>
                           <mif:param name="datatypeName" value="IVL"/>
                        </mif:object> then that is
							the value.  If both boundaries are finite, it is the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="center"/>
                           <mif:param name="datatypeName" value="IVL"/>
                        </mif:object>.
							If one boundary is infinite, the representative value is the other boundary. If both
							boundaries are infinite, the conversion to a point value is not applicable. If the
							contained value (<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="any"/>
                           <mif:param name="datatypeName" value="IVL"/>
                        </mif:object>) is not NULL, then that is the value.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; x)
      where x.nonNull {
   x.center.nonNull.implies(((T)x).equal(x.center));
   x.low.nonNull.and(x.high.nonNull).implies(((T)x).equal(x.center).or(((IVL&lt;T&gt;)((T)x)).equal(x)));
   x.high.nonNull.and(x.low.isNull).implies(((T)x).equal(x.high));
   x.low.nonNull.and(x.high.isNull).implies(((T)x).equal(x.low));
   x.low.isNull.and(x.high.isNull).and(x.any.isNull).implies(((T)x).notApplicable);
   x.any.nonNull.implies(((T)x).equal(x.any));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="equal" sortKey="13" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as
						the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="SET"/>
                        </mif:object> data type: Two nonNull <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="SET"/>
                        </mif:object>s are
						equal if they have the same elements. For IVLs, there are two special cases. 
						Highs are considered equal if they are both positive infinity, and lows are
						considered equal if they are both negative infinity.<mif:object name="footnote">
								This means that values of the type  and any other kind of SET with an equal parameter type may be equal.
							</mif:object>. Note that if two intervals have the same width and the bounds are not known, 
						they are not considered equal. The same applies where the interval is known by a 
						contained value (<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="any"/>
                           <mif:param name="datatypeName" value="IVL"/>
                        </mif:object>): such intervals are never considered
						equal.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="SET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="IVL_PQ" title="Interval&lt;PhysicalQuantity&gt;" datatypeKind="Binding"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A set of consecutive values of physical quantities.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> has a special literal form which is simply an interval of real numbers, a space,
					and the unit.
				</mif:p>
                  <mif:p>
					For example: "[0;5] mmol/L" or "&lt;20 mg/dL" are valid literal forms
					of intervals of physical quantities. Note that the generic interval form, e.g.,
					"[50 nm; 2 m]" is also allowed.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
IVL&lt;PQ&gt;.literal ST.SIMPLE {
   IVL&lt;PQ&gt;  : IVL&lt;REAL&gt; " " unit       { $.low.value.equal($1.low);
                                      $.low.unit.equal($3);
                                      $.lowClosed.equal($1.lowClosed);
                                      $.high.value.equal($1.high);
                                      $.high.unit.equal($3);
                                      $.highClosed.equal($1.highClosed); }
            | IVL&lt;REAL&gt;             { $.low.value.equal($1.low);
                                      $.low.unit.equal("1");
                                      $.lowClosed.equal($1.lowClosed);
                                      $.high.value.equal($1.high);
                                      $.high.unit.equal("1");
                                      $.highClosed.equal($1.highClosed); };
   CS unit  : ST                    { $.code.equal($1);
                                      $.codeSystem(2.16.840.1.113883.3.2); };
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:binding>
         <mif:targetDatatype name="IVL"/>
         <mif:argumentDatatype name="PQ"/>
      </mif:binding>
      <mif:property name="value" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value"/>
         <mif:type name="IVL">
            <mif:argumentDatatype name="REAL"/>
         </mif:type>
      </mif:property>
      <mif:property name="unit" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Unit"/>
         <mif:type name="CS"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="IVL_TS" title="Interval&lt;PointInTime&gt;" datatypeKind="Binding"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A set of consecutive values of time-stamps.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					The generic interval data type defines the interval of points in time
					too. However, there are some special considerations about literal
					representations and conversions of intervals of point in time, which
					are specified in this section.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type Interval&lt;PointInTime&gt; alias IVL&lt;TS&gt; specializes IVL&lt;T&gt;;</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:binding>
         <mif:targetDatatype name="IVL"/>
         <mif:argumentDatatype name="TS"/>
      </mif:binding>
      <mif:property name="literal" sortKey="01" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The literal form for interval of point in time is exceptional.
					</mif:p>
                     <mif:ul>
                        <mif:li/>
                        <mif:li/>
                     </mif:ul>
                     <mif:p>
						In order to avoid syntactic conflicts with the timezone and slightly
						different usage profiles of the ISO 8601 that occur on some ITS
						platforms, <mif:b>the dash form of the interval is not
						permitted for</mif:b>
                        <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="IVL_TS"/>
                        </mif:object>. The
						interval-form using square brackets is preferred.
					</mif:p>
                     <mif:p>
						Example: May 12, 1987 from 8 to 9:30 PM is k
						"<mif:code>[198705122000;198705122130]</mif:code>".
					</mif:p>
                     <mif:p>
						The "hull-form" of the literal is defined as the convex hull (see
						<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="hull"/>
                           <mif:param name="datatypeName" value="IVL"/>
                        </mif:object>) of interval-promotions from two time
						stamps.
					</mif:p>
                     <mif:p>
						For example, "<mif:code>19870901..19870930</mif:code>" is a valid literal
						using the hull form. The value is equivalent to the interval form
						"<mif:code>[19870901;19871001[</mif:code>".<mif:object name="footnote">
								The hull form may appear superfluous for the simple interval all by
								itself. However, the hull form will become important for the periodic
								interval notation as it shortens the notation and (perhaps arguably)
								makes the notation of more complex timing structures more intuitive.
							</mif:object>
                     </mif:p>
                     <mif:p>
						The hull-form further allows an abbreviation, where the higher
						timestamp literal does not need to repeat digits on the left that are
						the same as for the lower timestamp literal. The two timestamps are
						right-aligned and the digits to the left copied from the lower to the
						higher timestamp literal. This is a simple string operation and is not
						formally defined here.
					</mif:p>
                     <mif:p>
						Example: May 12, 1987 to May, 23, 1987 is
						"<mif:code>19870512..23</mif:code>". However, note that May 12, 1987 to June
						2, 1987 is "<mif:code>19870512..0602</mif:code>", and not
						"<mif:code>20000512..02</mif:code>".
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
   IVL&lt;TS&gt; hull : TS ".." TS     { $.equal(((IVL&lt;TS&gt;)$1)
                                    .hull((IVL&lt;TS&gt;)$3));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PIVL" title="PeriodicInterval" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An interval of time that recurs periodically. <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> has
					two properties, <mif:object name="propertyRef">
                     <mif:param name="propertyName" value="phase"/>
                     <mif:param name="datatypeName" value="PIVL"/>
                  </mif:object> and <mif:object name="propertyRef">
                     <mif:param name="propertyName" value="period"/>
                     <mif:param name="datatypeName" value="PIVL"/>
                  </mif:object>/<mif:object name="propertyRef">
                     <mif:param name="propertyName" value="frequency"/>
                     <mif:param name="datatypeName" value="PIVL"/>
                  </mif:object>.
					<mif:object name="propertyRef">
                     <mif:param name="propertyName" value="phase"/>
                     <mif:param name="datatypeName" value="PIVL"/>
                  </mif:object> specifies the "interval
					prototype" that is repeated every <mif:object name="propertyRef">
                     <mif:param name="propertyName" value="period"/>
                     <mif:param name="datatypeName" value="PIVL"/>
                  </mif:object> or <mif:object name="propertyRef">
                     <mif:param name="propertyName" value="frequency"/>
                     <mif:param name="datatypeName" value="PIVL"/>
                  </mif:object>.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					For example, "every eight hours for two minutes" is a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>
					where the interval's <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="WIDTH"/>
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object> equals 2
					minutes and the <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="period"/>
                        <mif:param name="datatypeName" value="PIVL"/>
                     </mif:object>
					at which the interval recurs equals 8 hours.
				</mif:p>
                  <mif:p>
                     <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="phase"/>
                        <mif:param name="datatypeName" value="PIVL"/>
                     </mif:object> also marks the anchor point
					in time for the entire series of periodically recurring intervals.
					If count is null, the recurrence of a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> has no
					beginning or ending, but is infinite in both future and past.
				</mif:p>
                  <mif:p>
					A <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is fully specified when both <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="period"/>
                        <mif:param name="datatypeName" value="PIVL"/>
                     </mif:object>/<mif:object name="propertyRef">
                        <mif:param name="propertyName" value="frequency"/>
                        <mif:param name="datatypeName" value="PIVL"/>
                     </mif:object>
					and <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="phase"/>
                        <mif:param name="datatypeName" value="PIVL"/>
                     </mif:object> are fully specified.
					The interval MAY be only partially specified where either
					only <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="WIDTH"/>
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object> or only one boundary is
					specified. If count is null, then there is no limit to the number of repetitions.
				</mif:p>
                  <mif:p>
					For example: "every eight hours for two minutes" specifies only
					<mif:object name="propertyRef">
                        <mif:param name="propertyName" value="period"/>
                        <mif:param name="datatypeName" value="PIVL"/>
                     </mif:object> and <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="WIDTH"/>
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object>
					of <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="phase"/>
                        <mif:param name="datatypeName" value="PIVL"/>
                     </mif:object> but no boundary of the
					<mif:object name="propertyRef">
                        <mif:param name="propertyName" value="phase"/>
                        <mif:param name="datatypeName" value="PIVL"/>
                     </mif:object>. Conversely,
					"every eight hours starting at 4 o'clock" specifies only
					<mif:object name="propertyRef">
                        <mif:param name="propertyName" value="period"/>
                        <mif:param name="datatypeName" value="PIVL"/>
                     </mif:object>
					and <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="LOW"/>
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object> of <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="phase"/>
                        <mif:param name="datatypeName" value="PIVL"/>
                     </mif:object>
					but not <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="HIGH"/>
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object> of <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="phase"/>
                        <mif:param name="datatypeName" value="PIVL"/>
                     </mif:object>.
					"Every eight hours for two minutes starting at 4 o'clock" is fully specified
					since <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="period"/>
                        <mif:param name="datatypeName" value="PIVL"/>
                     </mif:object>, and both <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="LOW"/>
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object>
					and <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="WIDTH"/>
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object> of <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="phase"/>
                        <mif:param name="datatypeName" value="PIVL"/>
                     </mif:object>
					are	specified.
				</mif:p>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is a generic type whose type
					parameter T is restricted to a <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object>
					and its extensions. <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PPD_TS&gt;"/>
                     </mif:object> is
					an extension of <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object> and therefore can be used to form
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PIVL&lt;PPD_TS&gt;"/>
                     </mif:object> values. This approach can model schedules of varying specificity.
				</mif:p>
                  <mif:p>
					Often times, repeating schedules are only approximately specified. For
					instance "three times a day for ten minutes each" does not usually
					mean a <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="period"/>
                        <mif:param name="datatypeName" value="PIVL"/>
                     </mif:object> of precisely 8 hours and does
					often not mean exactly 10 minutes intervals. Rather the distance
					between each occurrence may	vary as much as between 3 and 12 hours
					and the <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="WIDTH"/>
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object> of the interval
					may be less than 5 minutes or more than 15 minutes.
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PIVL&lt;PPD_TS&gt;"/>
                     </mif:object> can be used to indicate how much
					leeway is allowed or how critical timing is to the specification.
				</mif:p>
                  <mif:p>
					Sometimes the periodic interval may occur a set number of times.
					For instance, the the schedule might be "2 minutes every 10 minutes 5 times".
					This can be represented with a phase of width 2 min, a period of 10 min, and
					a count of 5. Note that a more common use case is that the period only occurs
					for a limited time period, such as "once a day between June 3 and Jun 10. Though
					this may be represented using the count property, the proper way to implement
					this is to define the timing specification as an intersection between a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> and 
					an <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="IVL"/>
                     </mif:object>. The data type flavor <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value=""/>
                     </mif:object> represents
					this common pattern.   
				</mif:p>
                  <mif:div title="Periodic Intervals as Sets">
						The essential property of a set is that it contains elements. For
						non-aligned s, the contains-property is
						defined as follows. A Â t is
						contained in the  if and only if there is an integer
						i for which t plus 
						times i is an element of .
					
					
invariant (PIVL&lt;TS&gt; x, TS t)
      where x.nonNull.and(x.alignment.isNull) {
   x.contains(t).equal(exists(INT i) {
      x.phase.contains(t.plus(x.period.times(i)));
      });
};
						For calendar-aligned s the contains
						property is defined using the calendar-cycle's sum(t,
						n) property that adds n such calendar cycles
						to the time t.
					
					
invariant (PIVL&lt;TS&gt; x, TS t, CalendarCycle c)
      where x.nonNull.and(c.equal(x.alignment)) {
   x.contains(t).equal(exists(INT i) {
      x.phase.contains(c.sum(t, i));
      });
};</mif:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;TS T&gt;
type PeriodicInterval&lt;T&gt; alias PIVL&lt;T&gt;
            specializes  QSET&lt;T&gt; {
            IVL&lt;T&gt;       phase;
            PQ           period;
            RTO&lt;INT, PQ.TIME&gt;  frequency;
            INT.POS      count;
            BL           displayFrequencyInd;
            CS           alignment;
            BL           isFlexible;
   literal  ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="TS"/>
      </mif:parameter>
      <mif:property name="phase" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Phase"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A interval specifying the duration of
							each occurrence and anchoring the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> sequence at a
							certain point in time.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is the prototype interval for the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>, and it also marks the anchor point in time for the entire series of
							periodically recurring intervals. If count is null, the recurrence of a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
							has no begin or end but is infinite in both future and
							past. <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="WIDTH"/>
                           <mif:param name="datatypeName" value="IVL"/>
                        </mif:object> of <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> SHALL
							be less than or equal to <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="period"/>
                           <mif:param name="datatypeName" value="PIVL"/>
                        </mif:object>.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PIVL&lt;T&gt; x)
      where x.nonNull {
   x.phase.nonNull.implies(x.phase.width.lessThan(x.period));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="period" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Period"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A time duration specified as a reciprocal measure of the frequency at
							which the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> repeats.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object> in the dimension of time
							(T.diff). For an uncertain <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
                        <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is a probability
							distribution over elapsed time.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PIVL&lt;T&gt; x)
      where x.nonNull {
   x.period.nonNull;
};

invariant(PIVL x) {
   period.isZero.not;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="frequency" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Frequency"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The number of times the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> repeats (numerator) within a specified time-period (denominator).
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							The denominator is a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object> in the dimension of time (TS.diffType). For an
							uncertain periodic interval the numerator is a probability distribution.
						</mif:p>
                  </mif:text>
               </mif:designComments>
               <mif:otherAnnotation type="ITS-Note">
                  <mif:text>
                     <mif:p>
								It would generally be appropriate for only one of period and frequency to represented in an ITS. 
								Although one can be calculated from the other, the ITS SHOULD arrange for only the preferred form
								to be represented.
							</mif:p>
                  </mif:text>
               </mif:otherAnnotation>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PIVL&lt;T&gt; x)
      where x.nonNull {
   x.frequency.nonNull;
   x.period.equal(x.frequency.denominator.dividedBy(x.frequency.numerator));
};
</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="RTO">
            <mif:argumentDatatype name="INT"/>
            <mif:argumentDatatype name="PQ.TIME"/>
         </mif:type>
      </mif:property>
      <mif:property name="count" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Count"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The number of times the period repeats in total. If count is null, then the period repeats indefinitely
							both before and after the anchor implicit in the phase.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
					      It is often not necessary to use the <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object>. Limits to the period over which the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> repeats
					      can be applied by combining the PIVL with other QSETs, for example intersecting it with an 
					      <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="IVL"/>
                        </mif:object>&lt;<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object>&gt; to determine the start and end times.
					     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="INT.POS"/>
      </mif:property>
      <mif:property name="displayFrequencyInd" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Display Frequency Indicator"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							If true, indicates that frequency takes priority over period for display purposes
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							While mathematically frequency and period are interchangeable, reliable human communication requires
							differentiation. For example "4 times per day" and "Every 6 hours" are mathematically equivalent.
							However, good clinical practice requires distinguishing which form was originally expressed as
							this conveys something of the intent.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="alignment" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Alignment to the Calendar"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							Specifies if and how the repetitions are aligned to the cycles 
							of the underlying calendar (e.g., to distinguish every 30 days
							from "the 5th of every month"). A non-aligned <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> recurs
							independently from the calendar. An aligned <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is
							synchronized with the calendar.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							For example, "every 5th of the month" is a calendar aligned <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>.
							<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="period"/>
                           <mif:param name="datatypeName" value="PIVL"/>
                        </mif:object> varies from 28 to 31 days depending
							on the calendar month. Conversely, "every 30 days" is an independent
							<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="period"/>
                           <mif:param name="datatypeName" value="PIVL"/>
                        </mif:object> that will
							fall on a different date each month.
						</mif:p>
                     <mif:p>
							The calendar alignment specifies a calendar cycle to which the
							<mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is aligned. The even flow of time will then be
							partitioned by the calendar cycle. The partitioning is called the
							calendar "grid" generated by the aligned-to calendar cycle. The
							boundaries of each occurrence interval will then have equal distance
							from the earliest point in each partition. In other words, the
							distance from the next lower grid-line to the beginning of the
							interval is constant.
						</mif:p>
                     <mif:p>
							For example, with "every 5th of the month" the alignment
							calendar cycle would be month of the year (<mif:code>MY</mif:code>).  The even
							flow of time is partitioned in months of the year. The distance
							between the beginning of each month and the beginning of its
							occurrence interval is 4 days (4 days because day of month (DM) starts
							counting with 1).  Thus, as months differ in their number of days, the
							distances between the recurring intervals will vary slightly, so that
							the interval occurs always on the 5th.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CalendarCycle"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="isFlexible" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Is Flexible"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							Indicates whether the exact timing is up to the party executing the
							schedule (e.g., to distinguish "every 8 hours" from "3 times a day".). 
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							For example, with a schedule "three times a day" the average time
							between repetitions is 8 hours, however, with isFlexible indicator 
							equal to <mif:b>true</mif:b>, the timing could follow some rule
							made by the executing person or organization that
							e.g., three times a day schedules are executed at 7 am, noon, and 7
							pm.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="literal" sortKey="08" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
                        <mif:b>Generic Literal Form</mif:b>. The generic
							literal form for periodic intervals of time is as follows:
						</mif:p>
                     <mif:p>
							(<mif:b>phase</mif:b> : IVL&lt;T&gt;( <mif:b>/</mif:b>
							(<mif:b>period</mif:b> : QTY  ( [ <mif:b>@</mif:b>
							(<mif:b>alignment</mif:b>( ] [ <mif:b>IST</mif:b> ].
						</mif:p>
                     <mif:p>
							For example, "<mif:code>[200004181100;200004181110]/(7 d)@DW</mif:code>"
							specifies every Tuesday from 11:00 to 11:10 AM. Conversely,
							"<mif:code>[200004181100;200004181110]/(1 mo)@DM</mif:code>" specifies every
							18th of the month 11:00 to 11:10 AM.
						</mif:p>
                     <mif:p>
                        <mif:b>Calendar Pattern Form</mif:b>. This form is
							used to specify calendar-aligned timing more intuitively using "calendar
							patterns."  The calendar pattern syntax is (semi-formally) defined as
							follows:
						</mif:p>
                     <mif:p>
							(<mif:b>anchor</mif:b>( [ (<mif:b>calendar digits</mif:b>(
							 [ <mif:b>..</mif:b> (<mif:b>calendar digits</mif:b>( ]]
							<mif:b>/</mif:b> (<mif:b>number</mif:b>
							 : INT( [ <mif:b>IST</mif:b> ]
						</mif:p>
                     <mif:p>
							A calendar pattern is a calendar date where the higher significant
							digits (e.g., year and month) are omitted. In order to interpret the
							digits, a period identifier is prefixed that identifies the calendar
							period of the left-most digits. This calendar period identifier
							<mif:b>anchors</mif:b> the calendar digits following to the right.
						</mif:p>
                     <mif:p>
							See <mif:object name="conceptDomainRef">
                           <mif:param name="domain" value="CalendarCycle"/>
                        </mif:object> for calendar-period codes
							defined for the Gregorian calendar. There are 1-character and
							2-character symbols. The 2-character symbols are preferred for the
							<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="alignment"/>
                           <mif:param name="datatypeName" value="PIVL"/>
                        </mif:object>. The 1-character symbols are preferred for the
							calendar pattern anchor.
						</mif:p>
                     <mif:p>
							For example: "<mif:code>M0219</mif:code>" is February 19 the entire day every
							year. This periodic interval has the February 19 of any year as its
							phase (e.g., "<mif:code>[19690219;19690220[</mif:code>" ), a period of one
							year, and alignment month of the year (M). The alignment
							calendar-cycle is the same as the anchor (e.g., in this example, month
							of the year).
						</mif:p>
                     <mif:p>
							The calendar digits may also omit digits on the right. When digits are
							omitted on the right, this means the interval from lowest to highest
							for these digits. For example, "<mif:code>M0219</mif:code>" is February 19 the
							entire day; "<mif:code>M021918</mif:code>" is February 19, the entire hour
							between 6 and 7 PM.
						</mif:p>
                     <mif:p>
							In absence of a formal definition for this, the rules for parsing a
							calendar pattern are as follows (example is "<mif:code>M021918..21</mif:code>"):
						</mif:p>
                     <mif:ol>
                        <mif:li>
                           <mif:code>M</mif:code>
                        </mif:li>
                        <mif:li/>
                        <mif:li>
                           <mif:code>2000</mif:code>
                           <mif:code>2000021918</mif:code>
                        </mif:li>
                        <mif:li>
                           <mif:code>2000021918</mif:code>
                           <mif:object name="datatypeRef">
                              <mif:param name="datatypeName" value="TS"/>
                           </mif:object>
                           <mif:object name="propertyRef">
                              <mif:param name="propertyName" value="promotionTS"/>
                              <mif:param name="datatypeName" value="IVL_TS"/>
                           </mif:object>
                        </mif:li>
                        <mif:li/>
                        <mif:li>
                           <mif:pre>
     "2000021918"
     "        21"
								</mif:pre>
                        </mif:li>
                        <mif:li>
                           <mif:code>2000021921</mif:code>
                        </mif:li>
                        <mif:li>
                           <mif:code>2000021918</mif:code>
                           <mif:object name="datatypeRef">
                              <mif:param name="datatypeName" value="TS"/>
                           </mif:object>
                           <mif:object name="datatypeRef">
                              <mif:param name="datatypeName" value="IVL_TS"/>
                           </mif:object>
                           <mif:object name="propertyRef">
                              <mif:param name="propertyName" value="promotionTS"/>
                              <mif:param name="datatypeName" value="IVL_TS"/>
                           </mif:object>
                           <mif:code>[2000021921;2000021922[</mif:code>
                        </mif:li>
                        <mif:li>
                           <mif:object name="propertyRef">
                              <mif:param name="propertyName" value="phase"/>
                              <mif:param name="datatypeName" value="PIVL"/>
                           </mif:object>
                           <mif:code>[2000021918;2000021922[</mif:code>
                        </mif:li>
                        <mif:li>
                           <mif:object name="propertyRef">
                              <mif:param name="propertyName" value="phase"/>
                              <mif:param name="datatypeName" value="PIVL"/>
                           </mif:object>
                        </mif:li>
                     </mif:ol>
                     <mif:p>
                        <mif:b>Interleave.</mif:b> A calendar pattern
							followed by a slash and an integer number <mif:b>n</mif:b> indicates that the
							given calendar pattern is to apply every nth time.
						</mif:p>
                     <mif:p>
							For example: "<mif:code>D19/2</mif:code>" is the 19th of every second month.
						</mif:p>
                     <mif:p>
							A calendar pattern expression is evaluated at the time the pattern is
							first encountered. At this time, the calendar digits missing from the left
							are completed using the earliest date matching the pattern (and
							following a preceding pattern in a combination of time sets).
						</mif:p>
                     <mif:p>
							For example: "<mif:code>D19/2</mif:code>" is the 19th of every second
							month. If this expression is evaluated on March 14, 2000 
							<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="phase"/>
                           <mif:param name="datatypeName" value="PIVL"/>
                        </mif:object> is
							completed to: "<mif:code>[20000319;20000320[/(2 mo)@DM</mif:code>" and thus
							the two-months cycle begins with March 19, followed by May 19, etc. If
							the expression were evaluated by March 20, the cycle would begin at
							April 19, followed by June 19, etc.
						</mif:p>
                     <mif:p>
							If no calendar digits follow after the calendar period identifier, the
							pattern matches any date. The integer number following the slash
							indicates the length of the cycle. <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="phase"/>
                           <mif:param name="datatypeName" value="PIVL"/>
                        </mif:object>
							in these cases
							has only the width specified to be the duration of the anchoring
							calendar-cycle (e.g., in this example 1 day).
						</mif:p>
                     <mif:p>
							For example: "<mif:code>CD/2</mif:code>" is every other day,
							"<mif:code>H/8</mif:code>" is every 8th hour, for the duration of one hour.
						</mif:p>
                     <mif:p>
                        <mif:b>Institution Specified Time.</mif:b> Both a 
							<mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> literal and a calendar pattern may be followed by
							the three letters "IST" to indicate that within the larger calendar
							cycle (e.g., for "hour of the day" the larger calendar cycle is "day")
							the repeating events are to be appointed at institution specified
							times. This is used to specify such schedules as "three times a day"
							where the periods between two subsequent events may vary well between
							4 hours (between breakfast and lunch) and 10 hours (over night).
							</mif:p>
                     <mif:table width="90%" hl7Id="examples-PIVL.literal">
                        <mif:caption>
								Examples for literal expressions for <mif:object name="itemName">
                              <mif:param name="item" value="datatype"/>
                           </mif:object>s
              				</mif:caption>
                        <mif:col width="258" span="1"/>
                        <mif:col width="137" span="1"/>
                        <mif:col width="513" span="1"/>
                        <mif:thead>
                           <mif:tr>
                              <mif:th>Generic Form</mif:th>
                              <mif:th>Calendar Pattern Form</mif:th>
                              <mif:th>Description</mif:th>
                           </mif:tr>
                        </mif:thead>
                        <mif:tbody>
                           <mif:tr>
                              <mif:td>[198709;198710[/(1 a)@MY</mif:td>
                              <mif:td>M09</mif:td>
                              <mif:td>
										September, the entire month, every year (note that in 
										the year 1987 in the generic form is irrelevant since the
										periodic interval recurs every year past and future).
									</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[19870915;19870916[/(1 a)@DM</mif:td>
                              <mif:td>M0915</mif:td>
                              <mif:td>September 15, the entire day, every year</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[1987091516;1987091517[/(1 a)@DM</mif:td>
                              <mif:td>M091516</mif:td>
                              <mif:td>September 15 at 4 PM, the entire hour, every year</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[198709151630;198709151710]/(1 a)@DM</mif:td>
                              <mif:td>M09151630..1710</mif:td>
                              <mif:td>September 15 at 4:30 5:10 PM, every year</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[1987091516;[/(1 a)@DM</mif:td>
                              <mif:td>Â </mif:td>
                              <mif:td>September 15 at 4 PM, end time explicitly unknown, every year</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[198709151630;198709151631[/(1 a)@DM</mif:td>
                              <mif:td>M09151630</mif:td>
                              <mif:td>September 15 at 4:30 PM, the entire minute, every year</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[1987091516;1987091517[/(1 mo)@DM</mif:td>
                              <mif:td>D1516..17</mif:td>
                              <mif:td>every 15th day of the month at 4 to 5 PM</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[1987091516;1987091517[/(1 mo)</mif:td>
                              <mif:td>Â </mif:td>
                              <mif:td>
										September 15, 1987 from 4 to 5 PM and then every 730.5 
										hours continuously (this example has little practical value 
										beyond comparing the unaligned with the aligned form in the 
										preceding row).
									</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[1987091516;1987091517[/(1 mo)@HD</mif:td>
                              <mif:td>Â </mif:td>
                              <mif:td>
										September 15, 1987 from 4 to 5 PM and then every 30.4375
										days, but aligned to the hour of the day.
									</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[1 mo]/(2 mo)@MY</mif:td>
                              <mif:td>M/2</mif:td>
                              <mif:td>
										every other month of the year; (Jan, Mar, ...) vs. (Feb, 
										Apr, ...) is undefined
									</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[198701;197502[/(2 mo)@MY</mif:td>
                              <mif:td>M01..12/2</mif:td>
                              <mif:td>every other month of the year, Jan, Mar, ...</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[198702;197503[/(2 mo)@MY</mif:td>
                              <mif:td>M02..12/2</mif:td>
                              <mif:td>every other month of the year, Feb, Apr, ...</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[19870401;19870930[/(1 a)@DM</mif:td>
                              <mif:td>M04..09</mif:td>
                              <mif:td>April 1until (and including) September 30</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>19870401-0930/(1 a)@DM</mif:td>
                              <mif:td>M0401..0930</mif:td>
                              <mif:td>
										April 1 to September 30 (the generic form uses the 
										dash-form for the phase interval)
									</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[20001202;20001203[/(1 wk)@DW</mif:td>
                              <mif:td>J6</mif:td>
                              <mif:td>every Saturday</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[20001202;20001203[/(2 wk)@DW</mif:td>
                              <mif:td>J6/2</mif:td>
                              <mif:td>every other Saturday</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[20001202;20001203[/(3 wk)@DW</mif:td>
                              <mif:td>J6/3</mif:td>
                              <mif:td>every third Saturday</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[1 d]/(2 d)@DW</mif:td>
                              <mif:td>J/2</mif:td>
                              <mif:td>
										every other day of the week; (Mon, Wed, Fri, ...) vs. 
										(Tue, Thu, Sat, ...)  is undefined
									</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[20001204;20001205[/(2 d)@DW</mif:td>
                              <mif:td>J2..6/2</mif:td>
                              <mif:td>
										every other day of the week (Tue, Thu, Sat, Tue, Thu, 
										Sat, ...)
									</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[20001204;20001205[/(2 d)</mif:td>
                              <mif:td>D/2</mif:td>
                              <mif:td>
										every other day (Tue, Thu, Sat, Mon, Wed, Fri, Sun, 
										Tue, ...)
									</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[19870601;19870606[/(1 wk)@DW</mif:td>
                              <mif:td>J1..5</mif:td>
                              <mif:td>Monday to Friday every week</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[19870601;19870608[/(2 wk)</mif:td>
                              <mif:td>W/2</mif:td>
                              <mif:td>every other week (continuous)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[19870101;19870105[/(2 wk)@WY</mif:td>
                              <mif:td>WY/2</mif:td>
                              <mif:td>
										every other week of the year (a blunt example on the 
										impact of the calendar alignment: the phase interval spans 
										only 4 days and yet it represents an entire week in the 
										calendar alignment "week of the year").
									</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[19870406;19870413[/(1 a)@WY</mif:td>
                              <mif:td>WY15</mif:td>
                              <mif:td>the 15th calendar week of every year</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[19870105;19870112[/(1 mo)@WM</mif:td>
                              <mif:td>WM2</mif:td>
                              <mif:td>the second week of the month, every month</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[19870508;19870509[/(1 a)@DY</mif:td>
                              <mif:td>DY128</mif:td>
                              <mif:td>the 128th day of the year, every year</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[10 min]/(2 d)</mif:td>
                              <mif:td>Â </mif:td>
                              <mif:td>
										every other day for 10 minutes (only width of repeating 
										interval is known)
									</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[1 h]/(8 h)</mif:td>
                              <mif:td>H/8</mif:td>
                              <mif:td>every eighth hour (each time a 60 minutes interval)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[1 h]/(8 h) IST</mif:td>
                              <mif:td>H/8 IST</mif:td>
                              <mif:td>
										three times a day at institution specified times (each 
										time a 60 minutes interval)
									</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>/(8 h) IST</mif:td>
                              <mif:td>Â </mif:td>
                              <mif:td>
										three times a day at institution specified times. 
										Nothing about the repeating interval is known i.e., this 
										includes only a period (frequency), while the phase is left 
										undefined
									</mif:td>
                           </mif:tr>
                        </mif:tbody>
                     </mif:table>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
PIVL&lt;T&gt;.literal ST.SIMPLE {
   PIVL&lt;T&gt;    : S2                  { $.equal($1); }
              | S2 "IST"            { $.phase.equal($1.phase);
                                      $.period.equal($1.period);
                                      $.isFlexible.equal(true); };
   PIVL&lt;T&gt; S2 : S1                  { $.equal($1); }
              | S1 "@" "(" ST ")"   { $.phase.equal($1.phase);
                                      $.period.equal($1.period);
                                      $.alignment.equal($4); };
   PIVL&lt;T&gt; S1 :
      IVL&lt;T&gt; "/" "(" QTY ")"        { $.phase.equal($1);
                                      $.period.equal($3); }
              | "/" "(" QTY ")"     { $.period.equal($2); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="equal" sortKey="09" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as
						the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="SET"/>
                        </mif:object> data type: Two nonNull <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="SET"/>
                        </mif:object>s are
						equal if they have the same elements.<mif:object name="footnote">
								This means that values of the type  and any other kind of SET may be equal.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="SET"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="EIVL" title="EventRelatedPeriodicInterval" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					Specifies a periodic interval of time where the recurrence is based on
					activities of daily living or other important events that are
					time-related but not fully determined by time.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					For example, "one hour after breakfast" specifies the beginning of the
					interval at one hour after breakfast is finished. Breakfast is assumed
					to occur before lunch but is not determined to occur at any specific
					time.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;TS T&gt;
type EventRelatedPeriodicInterval&lt;T&gt; alias EIVL&lt;T&gt;
           specializes  QSET&lt;T&gt; {
           CS           event;
           IVL&lt;PQ&gt;      offset;
  literal  ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="TS"/>
      </mif:parameter>
      <mif:property name="event" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Event"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A code for a common (periodical) activity of daily living based on
							which the event related periodic interval is specified.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							A proper EIVL requires the event to be specified.
						</mif:p>
                     <mif:p>
							In order for an event to qualify for being adopted in the domain of this
							attribute, all of the following must be true:
						</mif:p>
                     <mif:ul>
                        <mif:li/>
                        <mif:li/>
                        <mif:li/>
                     </mif:ul>
                     <mif:p>
					   Events that are not listed in this table, and that do not meet the criteria listed above are not
					   suitable for use with the EIVL data type. On such example is sequenced acitivities as part of 
					   a clinical trial. More sophisticated RIM derived pattern should be used for such event 
					   associations. 
					<mif:object name="footnote">HL7 is preparing a document that contains common usage patterns that
					will discuss how to best handle event associations in common healthcare identification use cases.</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(EIVL&lt;T&gt; x)
     where x.nonNull {
   x.event.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="TimingEvent"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="offset" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Offset"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							An interval of elapsed time (duration, not absolute point in time)
							that marks the offsets for the beginning, width and end of
							the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> measured from the time each such
							event actually occurred.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							For example: if the specification is "one hour before breakfast for 10
							minutes", the event is CM, <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="LOW"/>
                           <mif:param name="datatypeName" value="IVL"/>
                        </mif:object> of <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is -1 h
							and the <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="WIDTH"/>
                           <mif:param name="datatypeName" value="IVL"/>
                        </mif:object> of <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is
							10 min(consequently the offset's high boundary is -50 min).
						</mif:p>
                     <mif:p>
							The <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> SHALL be null if the event code specifies "before", "after" or "between meals". 
							The <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> SHALL be nonNull if the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is nonNull and the event code is C, CM, CD, or CV. 
							The <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> may or may not be null for the event codes HS and WAKE.   
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="IVL">
            <mif:argumentDatatype name="PQ"/>
         </mif:type>
      </mif:property>
      <mif:property name="literal" sortKey="03" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							The literal form for an <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> begins with the event
							code followed by an optional interval of the time-difference.
						</mif:p>
                     <mif:p>
							For example, one hour after meal would be
							"<mif:code>PC+[1h;1h]</mif:code>". One hour before bedtime for 10 minutes:
							"<mif:code>HS-[50min;40min]</mif:code>".
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
EIVL&lt;TS&gt;.literal ST.SIMPLE {
   EIVL&lt;TS&gt; : event          { $.event.equal($1); }
            | event offset   { $.event.equal($1);
                               $.offset.equal($2); };
   CS event : ST             { $.code.equal($1);
                               $.codeSystem.equal(2.16.840.1.113883.5.1019); }
   IVL&lt;PQ&gt; offset
            : "+" IVL&lt;PQ&gt;    { $.equal($2); }
            | "-" IVL&lt;PQ&gt;    { $.low.equal($2.high.negate);
                               $.high.equal($2.low.negate);
                               $.width.equal($2.width);
                               $.lowClosed($2.highClosed);
                               $.highClosed($2.lowClosed); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="intervalAt" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Interval At"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
					  An <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is a set of time, that is, one can test whether a particular time or time interval is an element of the set.
					  Whether an <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> contains a given interval of time is decided using a relation event ? time referred to as
					  EVENT(event, time). The property prop-EIVL.intervalAt(t) is the occurrence interval that would exist if the event occurred
					  at time t.
					</mif:p>
                     <mif:p>
						Thus, an EIVL contains a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object> t if there is an event time e with an occurrence interval v such that v contains t.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(EIVL&lt;T&gt; x, T eventTime, IVL&lt;T&gt; v)
      where v.equal(x.intervalAt(eventTime)) {
   v.low.equal(eventTime.plus(x.offset.low));
   v.high.equal(eventTime.plus(x.offset.high));
   v.lowClosed.equal(x.offset.lowClosed);
   v.highClosed.equal(x.offset.highClosed);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(EIVL&lt;T&gt; x, T y) {
   x.contains(y).equal(exists(T e, IVL&lt;T&gt; v)
      where EVENT(x.event, y).and(v.resolvedAt(y)) {
         v.contains(y);
         });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QSET"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="TS"/>
         </mif:parameter>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as
						the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="SET"/>
                        </mif:object> data type: Two nonNull <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="SET"/>
                        </mif:object>s are
						equal if they have the same elements.<mif:object name="footnote">
								This means that values of the type  and any other kind of SET may be equal.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="SET"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="QSET_TS" title="ContinuousSet&lt;PointInTime&gt;" datatypeKind="Binding"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A set of intervals constructed to describe specific and potentially complex schedules.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is used to specify the timing of schedules, events, actions and the cyclical validity-patterns
					that may exist for certain kinds of information, such as phone numbers (evening,
					daytime), addresses (so called "snowbirds," residing closer to the equator during
					winter and farther from the equator during summer) and office hours.
				</mif:p>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> has the following aspects:
				</mif:p>
                  <mif:ul>
                     <mif:li>
                        <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
                        <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="QSET&lt;TS&gt;"/>
                        </mif:object>
                        <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
                        <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object>
                        <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
                     </mif:li>
                     <mif:li>
                        <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
                        <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PIVL"/>
                        </mif:object>
                        <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
                     </mif:li>
                     <mif:li>
                        <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
                        <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="LIST&lt;IVL&lt;TS&gt;&gt;"/>
                        </mif:object>
                        <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
                     </mif:li>
                     <mif:li>
                        <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
                        <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
                     </mif:li>
                  </mif:ul>
                  <mif:p>
					In all cases, <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> as a <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="SET&lt;TS&gt;"/>
                     </mif:object> is built from one
					of the building blocks of <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET&lt;TS&gt;"/>
                     </mif:object>: <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSU&lt;TS&gt;"/>
                     </mif:object>,
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSI&lt;TS&gt;"/>
                     </mif:object>, <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSD&lt;TS&gt;"/>
                     </mif:object>, <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSC&lt;TS&gt;"/>
                     </mif:object>, <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="IVL&lt;TS&gt;"/>
                     </mif:object>, 
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PIVL&lt;TS&gt;"/>
                     </mif:object> and <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="EIVL&lt;TS&gt;"/>
                     </mif:object>.
					Ultimately the building blocks from which all <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> values are constructed
					are <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="IVL&lt;TS&gt;"/>
                     </mif:object>, <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSC&lt;TS&gt;"/>
                     </mif:object>, <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PIVL"/>
                     </mif:object>, and <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="EIVL"/>
                     </mif:object>.
					Since <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object> can be promoted to <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="IVL&lt;TS&gt;"/>
                     </mif:object>, it is 
					also possible to use <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object> directly when building a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>.
				</mif:p>
                  <mif:p>
				 	This example specifies every other Tuesday in the season from the (US holidays) Memorial Day to Labor Day in the 
				 	years 2002 and 2003. This set of times is built as an expression of the intersection between 3 sets:
				</mif:p>
                  <mif:ul>
                     <mif:li>
                        <mif:p>Every other tuesday</mif:p>
                     </mif:li>
                     <mif:li>
                        <mif:p>The years 2002 and 2003</mif:p>
                     </mif:li>
                     <mif:li>
                        <mif:p>The season between Memorial Day and Labor Day</mif:p>
                     </mif:li>
                  </mif:ul>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type ContinuousSet&lt;PointInTime&gt; alias QSET&lt;TS&gt; specializes QSET&lt;T&gt; {
  literal  ST.SIMPLE;  
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:staticExample itsName="XML">
               <mif:data>
                  <example>
&lt;example xsi:type="QSI_TS"&gt; 
	&lt;!-- intersection, because it is a QSI --&gt;

	&lt;!-- every other Tuesday --&gt;
	&lt;term xsi:type='PIVL_TS' alignment='DW'&gt;
		&lt;phase lowClosed='true' highClosed='false'&gt;
			&lt;low value='20001202'/&gt;
			&lt;high value='20001203'/&gt;
		&lt;/phase&gt;
		&lt;period value='2' unit='wk'/&gt;
	&lt;/term&gt;

	&lt;!-- 2002 and 2003 --&gt;
	&lt;term xsi:type='IVL_TS' lowClosed='true' highClosed='false'&gt;
		&lt;low value='20020101'/&gt;
		&lt;high value='20040101'/&gt;
	&lt;/term&gt;					
	
	&lt;!-- season between Memorial Day and Labor Day --&gt;
	&lt;!-- periodic hull between Memorial day and Labor Day --&gt;
	&lt;term xsi:type='QSP_TS'&gt;
		&lt;first type="QSI_TS"&gt; 
		&lt;!-- memorial day: intersection of mondays and last week of May --&gt;
			&lt;term xsi:type='PIVL_TS'&gt;
				&lt;phase highClosed='false'&gt;
					&lt;low value='19870525'/&gt;
					&lt;high value='19870601'/&gt;
				&lt;/phase&gt;
				&lt;period value='1' unit='a'/&gt;
			&lt;/term&gt;
			&lt;term xsi:type='PIVL_TS'&gt;
				&lt;phase highClosed='false'&gt;
					&lt;low value='19870105'/&gt;
					&lt;high value='19870106'/&gt;
				&lt;/phase&gt;
				&lt;period value='1' unit='wk'/&gt;
			&lt;/term&gt;
		&lt;/first&gt;
		&lt;second type="QSI_TS"&gt;
		&lt;!-- labor day :  intersection of mondays and first week of Sept --&gt;
			&lt;term xsi:type='PIVL_TS'&gt;
				&lt;phase highClosed='false'&gt;
					&lt;low value='19870901'/&gt;
					&lt;high value='19870908'/&gt;
				&lt;/phase&gt;
				&lt;period value='1' unit='a'/&gt;
			&lt;/term&gt;
			&lt;term xsi:type='PIVL_TS'&gt;
				&lt;phase highClosed='false'&gt;
					&lt;low value='19870105'/&gt;
					&lt;high value='19870106'/&gt;
				&lt;/phase&gt;
				&lt;period value='1' unit='wk'/&gt;
			&lt;/term&gt;
		&lt;/second&gt;
	&lt;/term&gt;
&lt;/example&gt;</example>
               </mif:data>
            </mif:staticExample>
         </mif:appInfo>
      </mif:annotations>
      <mif:binding>
         <mif:targetDatatype name="QSET"/>
         <mif:argumentDatatype name="TS"/>
      </mif:binding>
      <mif:property name="literal" sortKey="01" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> literal is a direct representation of the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="QSET&lt;TS&gt;"/>
                        </mif:object>
						expression tree used to build a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>.<mif:object name="footnote">
								Since GTS is only an alias for , the
								literal specification defined here actually applies to any 
								.
							</mif:object>
                     </mif:p>
                     <mif:p>
						Unions are specified by a semicolon-separated list. Intersections
						are specified by a whitespace separated list. Intersection has higher
						priority than union. Set difference can be specified
						using a backslash; differences have an intermediate priority,
						i.e. weaker than intersection but stronger than union. Periodic 
						Hulls are indicated by separating two sets with "..".
						The hull operator has the same priority as set difference.
						Parentheses can be used to overcome operator precedence when
						necessary.<mif:object name="footnote">
								This literal specification again looks surprisingly simple, so one
								might assume it is incomplete. However, the 
								literal is based on the , ,
								, and  literals
								and also implies the
								literals for the extensions of , notably the
								.  is represented 
								directly by its GTSAbbreviation () code.								
								The  literal 
								specification itself only needs to tie the other literal
								forms together, which is indeed a fairly simple task by itself.
							</mif:object>
                     </mif:p>
                     <mif:p>
						The following table contains paradigmatic examples for complex
						<mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> literals. For simpler examples refer to the literal
						forms of <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="IVL"/>
                        </mif:object>, <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PIVL"/>
                        </mif:object>,
						and <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="EIVL"/>
                        </mif:object>.
					</mif:p>
                     <mif:table width="90%" hl7Id="examples-GTS.literal">
                        <mif:caption>
							Examples for Literal Expressions for Generic Timing
							Specifications
						</mif:caption>
                        <mif:col width="168" span="1"/>
                        <mif:col width="407" span="1"/>
                        <mif:thead>
                           <mif:tr>
                              <mif:th>Literal Expression</mif:th>
                              <mif:th>Meaning</mif:th>
                           </mif:tr>
                        </mif:thead>
                        <mif:tbody>
                           <mif:tr>
                              <mif:td>M09 D15 H16 N30 S34.12</mif:td>
                              <mif:td>
									September 15 at 4:30:34.12 PM as the intersection of
									multiple periodic intervals of times (calendar patterns)
								</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>M0915163034.12</mif:td>
                              <mif:td>
									September 15 at 4:30:34.12 PM as one simple periodic
									interval of time (calendar pattern)
								</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>M01; M03; M07</mif:td>
                              <mif:td>
									January, March, and July (a union of three periodic 
									intervals of time)
								</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>M04..09 M/2</mif:td>
                              <mif:td>
									Every second month from April to September (April, June, 
									August)
								</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>J1; J2; J4</mif:td>
                              <mif:td>Monday, Tuesday, Thursday</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>W/2 J2</mif:td>
                              <mif:td>
									every other Tuesday (intersection of every other week and 
									every Tuesday)
								</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>1999 WY15</mif:td>
                              <mif:td>
									the 15th calendar week in 1999 (period code is optional 
									for the highest calendar unit)
								</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>WM2 J6</mif:td>
                              <mif:td>Saturday of the 2nd week of the month</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>M05 WM2 J6</mif:td>
                              <mif:td>Saturday of the 2nd week of May</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>M05 DM08..14 J7</mif:td>
                              <mif:td>Mother's day (second Sunday in May).</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>J1..5 H0800..1600</mif:td>
                              <mif:td>Monday to Friday from 8 AM to 4 PM</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>
									J1..4 H0800..1600;<mif:br/>
									J5    H0800..1200
								</mif:td>
                              <mif:td>Monday to Thursday 8 AM to 4 PM and Friday 8 AM to 12 noon.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>[10 d] H/8</mif:td>
                              <mif:td>Three times a day over 10 days (each time a 60 minutes interval).</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>H0800..1600 \J3</mif:td>
                              <mif:td>Every day from 8 AM to 4 PM, except Wednesday.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>(M0825..31 J1)..M0831</mif:td>
                              <mif:td>The last calendar week of August.</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>JHNUSMEM..JHNUSLBR</mif:td>
                              <mif:td>The season from the U.S. holidays Memorial Day to Labor Day (typical midwestern swimming pool season)</mif:td>
                           </mif:tr>
                           <mif:tr>
                              <mif:td>JHCHRXME H08..12</mif:td>
                              <mif:td>To indicate that the office hours on Christmas Eve are from 8 AM to 1PM only</mif:td>
                           </mif:tr>
                        </mif:tbody>
                     </mif:table>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
GTS.literal ST.SIMPLE {
   GTS symbol : union                      { $.equal($1); }
              | exclusion                  { $.equal($1); };
   SET&lt;TS&gt; union
              : symbol ";" intersection    { $.equal($1.union($3)); }
              | intersection               { $.equal($1); };
   SET&lt;TS&gt; exclusion
              : symbol "\" intersection    { $.equal($1.except($3)); }
              | intersection               { $.equal($1); };
   SET&lt;TS&gt; intersection
              : hull intersection          { $.equal($1.intersection($2)); }
              | hull                       { $.equal($1); };
   SET&lt;TS&gt; hull
              : hull ".." factor           { $.equal($1.periodicHull($3)); }
              | factor                     { $.equal($1); };
   SET&lt;TS&gt; factor
              : IVL&lt;TS&gt;                    { $.equal($1); }
              | QSC&lt;TS&gt;                    { $.code.equal($1); }
              | PIVL&lt;TS&gt;                   { $.equal($1); }
              | EIVL&lt;TS&gt;                   { $.equal($1); }
              | "(" GTS ")"                { $.equal($1); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="GTS" title="GeneralTimingSpecification" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="annotated">
         <mif:targetDatatype name="QSET">
            <mif:argumentDatatype name="TS"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An alias for <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="QSET"/>
                  </mif:object>&lt;<mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="TS"/>
                  </mif:object>&gt;. 
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>  is an alias for <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object>&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object>&gt;, and the 
					terms may be freely used interchangeably to refer to the type semantically. 
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="ITS-Note">
               <mif:text>
                  <mif:p>
							Implementation Technology Specifications MAY not support aliasing the type
							if this is not easily supported in the typing system. In such cases, the specification
							MAY only define types for <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="QSET"/>
                     </mif:object>&lt;<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object>&gt;, and 
							not support <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> as an alias.
						</mif:p>
               </mif:text>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="UVP" title="UncertainValueProbabilistic" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="T" qualifier="parameter"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A generic data type extension used to specify a quantified probability expressing
					the information producer's belief that the given value is correct.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					How the probability number is determined is outside the scope of this
					specification.
				</mif:p>
                  <mif:p>
					Probabilities are subjective and (as any data value) must be
					interpreted in their individual context; for example, when new
					information is found, the probability might change. Thus, for any
					message, document, or other information representation, the
					information â and particularly the probabilities â reflect
					what the information producer believed was appropriate for the purpose
					and at the time the message or document was created.
				</mif:p>
                  <mif:p>
					For example, at the beginning of the 2000 baseball season (May), the
					Las Vegas odds makers may have given the New York Yankees a
					probability of 1 in 10 (0.100) of winning the World Series. At the
					time of this writing, the Yankees and Mets have won their respective
					pennants, but the World Series has yet to begin. The probability of
					the Yankees winning the World Series is obviously significantly
					greater at this point in time, perhaps 6 in 10 (0.600). The context,
					and in particular the time of year, make a significant difference.
				</mif:p>
                  <mif:p>
					Since probabilities are subjective measures of belief, they can be
					stated without being "correct" or "incorrect" per se, let alone
					"precise" or "imprecise." Notably, one does not have to conduct
					experiments to measure a frequency of some outcome in order to specify
					a probability. In fact, whenever statements about individual people or
					events are made, it is not possible to confirm such probabilities with
					"frequentist" experiments.
				</mif:p>
                  <mif:p>
					Returning to our example, the Las Vegas odds makers can not insist on
					the Yankees and Mets playing 1000 trial games prior to the Series;
					and even if they could, they would not have the fervor of the real Series
					and therefore not be accurate. Instead, the odds makers must derive
					the probability from history and judgment.
				</mif:p>
                  <mif:p>
					The type T is not formally constrained. In theory, discrete
					probabilities can only be stated for discrete data values. Thus,
					generally <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> SHOULD NOT be used with <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="REAL"/>
                     </mif:object>,
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PQ"/>
                     </mif:object>, or <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="MO"/>
                     </mif:object> values. 
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type UncertainValueProbabilistic&lt;T&gt; alias UVP&lt;T&gt; specializes T {
   REAL  probability;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="probability" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Probability"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The probability assigned to the value, a decimal number between 0
							(impossible) and 1 (certain), inclusive.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							There is no "default probability" that one can assume when the
							probability is unstated. Therefore, it is impossible to make any
							semantic difference between an <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> without probability and
							a simple T. <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> does not mean "uncertain", and a simple T
							does not mean "certain". In fact, the probability of the <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
							could be 0.999 or 1, which is quite certain, where a simple T value
							could be a very vague guess.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(UVP&lt;T&gt; x)
      where x.nonNull.and(x.probability.nonNull) {
   ((IVL&lt;REAL&gt;)"[0;1]").contains(x.probability);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="NPPD" title="NonParametricProbabilityDistribution"
                 datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="DSET">
            <mif:argumentDatatype name="UVP">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:argumentDatatype>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A set of <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="UVP"/>
                  </mif:object> with explicit probabilities.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
				   An <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is a histogram).  All the elements in the set are considered alternatives, and each is assigned a number expressing either the probability that its value is correct or the frequency with which it occurs in a sample.
				</mif:p>
                  <mif:p>
					The purpose of <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is chiefly
					to support statistical data reporting as it occurs in measurements
					taken from many subjects and consolidated in a histogram. This occurs
					in epidemiology, veterinary medicine and laboratory medicine, but also in
					cost controlling and business process engineering.
				</mif:p>
                  <mif:p>
					Semantically, the information of a stated value exists in contrast to
					the complement set of unstated possible values. Thus, semantically, an
					<mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> contains <mif:b>all</mif:b>
					possible values and assigns probabilities to each of them.
				</mif:p>
                  <mif:p>
					The easiest way to visualize this is a bar chart as shown in this figure:
				</mif:p>
                  <mif:img imageType="image/gif" src="DT-NPPD-ex1.gif" alt="Example of a Histogram"/>
                  <mif:p>
					This example illustrates the probability of selected major league
					baseball teams winning the World Series (prior to the season
					start). Each team is mutually exclusive, and were we to include all of
					the teams, the sum of the probabilities would equal 1 (i.e., it is
					certain that one of the teams will win).
				</mif:p>
                  <mif:p>
					Just as with <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="UVP"/>
                     </mif:object>, the type T is not formally
					constrained, even though there are reasonable and unreasonable
					uses. Typically one would use <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> for unordered types, if
					only a "small" set of possible values is assigned explicit
					probabilities, or if the probability distribution cannot (or should
					not) be approximated with parametric methods. For other cases, one may
					prefer <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PPD"/>
                     </mif:object>.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type NonParametricProbabilityDistribution&lt;T&gt; alias NPPD&lt;T&gt;
      specializes DSET&lt;UVP&lt;T&gt;&gt; {
   UVP&lt;T&gt; mostLikely(INT n);
};</mif:data>
            </mif:otherAnnotation>
            <mif:otherAnnotation type="ITS-Note">
               <mif:text>
                  <mif:p>
						Even though semantically <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> assigns probabilities to all
						possible values, not all values need to be represented
						explicitly. Those possible values that are not mentioned
						will have the remaining probability distributed equally over
						all unmentioned values. For example, if the value set is {A; B; C; D}
						but the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> value states just {(B; 0.5); (C; 0.25)} then the
						remaining probability is 1 - 0.75 = 0.25, which is distributed evenly over
						the complement set: {(A; 0.125); (D; 0.125)}. Semantically, the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>
						is the union of the stated probability distribution and the unstated
						complement with the remaining probability distributed evenly.
					</mif:p>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> SHALL be used where only one value for T may be true. The sum of the probabilities assigned
						to the mentioned values should be &lt;= 1, but due to estimating and rounding inaccuracies, the total 
						MAY actually exceed 1.
					</mif:p>
               </mif:text>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="mostLikely" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Most Likely"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
					  The value identified as the most likely in the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>. If 
					</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Note that a non-null <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> must have at least one member.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(NPPD&lt;T&gt; x)
      where x.nonNull {
   x.notEmpty;
   x.contains(x.mostLikely(n));
   forall(UVP&lt;T&gt; d, e; DSET&lt;UVP&lt;T&gt;&gt; m; INT n)
         where x.contains(d).and(m.equal(x.mostLikely(n)))
                .and(m.contains(e)) {
      e.greaterOrEqual(d).or(m.contains(d));
      };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="n" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="UVP">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The evaluation of equality for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is the same as the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="DSET"/>
                        </mif:object> data type.<mif:object name="footnote">
								This means that values of the type NPPD and DSET may be equal.
							</mif:object>
                     </mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="URG" title="UncertainRange" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="T" qualifier="parameter"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					Indicates that the value comes from a range of possible values of an ordered base data type.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is used where the actual value is unknown, but it is known that the 
					value comes from a known range of possible values (e.g. "Take 2-4 tablets").
					For situations where all values apply simultaneously (e.g. The encounter lasted 
					from January 6th through January 12th) the <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value=""/>
                     </mif:object> type should be used.
				</mif:p>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> differs from <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PPD"/>
                     </mif:object> in that <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PPD"/>
                     </mif:object> is used to report a 
					particular value along with an associated distribution of uncertainty for the 
					value, or to report the summary distribution of a set of data, whereas <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> indicates
					that there is a single value that, although unknown, must come from a particular range
					of values. No inference regarding distribution of values can be taken. <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> 
					is often associated with an instruction to perform a particular operation at 
					some point within a given time interval.  
				</mif:p>
                  <mif:p>
					Any ordered type can be the basis of an <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>; it does not matter
					whether the base type is discrete or continuous. If the base data type
					is only partially ordered, all possible values for the <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> SHALL be
					elements of a totally ordered subset of the partially ordered data
					type.
				</mif:p>
                  <mif:p>
					For example, <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PQ"/>
                     </mif:object> is considered ordered. However the
					ordering of <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PQ"/>
                     </mif:object>s is only partial; a total order is only
					defined among comparable quantities (quantities of the same physical
					dimension).  While <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>s between 2 and 4 meter exists, there is no
					<mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> between 2 meters and 4 seconds.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type UncertainRange&lt;T&gt; alias URG&lt;T&gt; specializes T {
   IVL&lt;T&gt;   range;
   BL       couldBe(T value);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="range" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Range"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The range of possible values.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							When a range is specified, it SHALL be anchored to known values, not just a width,
							and the property <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="any"/>
                           <mif:param name="datatypeName" value="IVL"/>
                        </mif:object> SHALL be null.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(URG&lt;T&gt; x) 
      where x.range.nonNull {
   x.range.any.isNull;
   x.range.center.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="couldBe" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Could Be"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							Whether a given value can be in the specified range.
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							Although the actual value is unknown, it is possible to determine whether
							a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> could be a particular value. A particular value is possible if
							it is contained within the specified range.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(URG&lt;T&gt; x, T t) 
    where x.range.nonNull {
  x.couldBe(t).equals(x.range.contains(t));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="value" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="equal" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Equality"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						The criteria for equality of <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> are taken from the range.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(URG&lt;T&gt; x, y) 
    where x.nonNull.and(y.nonNull) {
  x.equal(y).equal(x.range.equal(y));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="BN" title="BooleanNonNull" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="BL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains the <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="BL"/>
                  </mif:object> so that it is not null.
						This is defined for use within the data types specification where it is not
						appropriate for a null value to be used.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						Values conforming to the BN flavor SHALL NOT have null values.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor BooleanNonNull alias BN constrains BL;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (BN x) {
   x.isNull.not;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="isNull" sortKey="01" propertyKind="variableProperty" visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Exceptional Value"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BN"/>
      </mif:property>
      <mif:property name="nonNull" sortKey="02" propertyKind="variableProperty" visibility="public"
                    fixedValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Proper Value"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BN"/>
      </mif:property>
      <mif:property name="other" sortKey="03" propertyKind="variableProperty" visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value Domain Exception"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="notApplicable" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Inapplicable Proper Value"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="unknown" sortKey="05" propertyKind="variableProperty" visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="unknown"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="nullFlavor" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Exceptional Value Detail"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="NullFlavor"/>
         </mif:vocabularySpecification>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ED.TEXT" title="TextWithReference" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="ED"/>
                  </mif:object> so that it  
						only contains plain text. 
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						This is useful because there is sometimes
						a need to allow for references, but the content must be a simple
						string. In addition, no translations are allowed.
					</mif:p>
                  <mif:p>
						The mediaType of the ED content SHALL be plain text, like the type <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ST"/>
                     </mif:object>
						but a reference is allowed.
					</mif:p>
                  <mif:p>
						The mediaType of the ED content SHALL be plain text, like the type <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ST"/>
                     </mif:object>
						but a reference is allowed.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor TextWithReference alias ED.TEXT constrains ED;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ED.TEXT x) where x.nonNull {
  x.mediaType.equal("text/plain");
  x.integrityCheck.isNull;
  x.thumbnail.isNull;
  x.compression.isNull;
  x.translation.isEmpty;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="mediaType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="text/plain"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Media Type"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="MediaType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="compression" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Compression"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CompressionAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="integrityCheck" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Integrity Check"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="BIN"/>
      </mif:property>
      <mif:property name="integrityCheckAlgorithm" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="SHA-1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Integrity Check Algorithm"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="IntegrityCheckAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="thumbnail" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Thumbnail"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="translation" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:businessName name="Translation"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="ED"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ED.SIGNATURE" title="DigitalSignature" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="ED"/>
                  </mif:object> so that the contents are an 
						XML digital Signature according the W3C Signature specifications. 
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						Reference, integrityCheck, thumbnail, compression, and language SHALL be null.
						ED.mediaType SHALL be "text/xml". Translations SHALL be not applicable.
						The content SHALL conform to the w3c XML digital signature specification
						 ([<mif:a href="http://www.w3.org/Signature/"/>]).
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor DigitalSignature alias ED.SIGNATURE constrains ED;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ED.SIGNATURE x) where x.nonNull {
  x.reference.isNull;
  x.integrityCheck.isNull;
  x.thumbnail.isNull;
  x.description.isNull;
  x.compression.isNull;
  x.language.isNull;
  x.mediaType.equal("text/xml");
  x.translation.isEmpty;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="mediaType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="text/xml"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Media Type"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="MediaType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="language" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Language"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="HumanLanguage"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="compression" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Compression"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CompressionAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="reference" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Reference"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="TEL.URL"/>
      </mif:property>
      <mif:property name="integrityCheck" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Integrity Check"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="BIN"/>
      </mif:property>
      <mif:property name="integrityCheckAlgorithm" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="SHA-1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Integrity Check Algorithm"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="IntegrityCheckAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="description" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Description"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="thumbnail" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Thumbnail"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="translation" sortKey="09" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:businessName name="Translation"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="ED"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ED.IMAGE" title="Image" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="ED"/>
                  </mif:object> so that the contents are an 
						image. 
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						The mediaType SHALL start with "image/".
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor Image alias ED.IMAGE constrains ED;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ED.IMAGE x) where x.nonNull {
  x.mediaType.code.subList(0,6).equal("image/");
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="data" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Binary Data"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="BIN"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ED.STRUCTURED_TEXT" title="StructuredText" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="ED"/>
                  </mif:object> so that the contents are structured
						text. 
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						The mediaType SHALL be "text/x-hl7-text+xml". The contents of the ED SHALL be a valid
						structured text as described by CDA and SPL. No translations are allowed.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor StructuredText alias ED.STRUCTURED_TEXT constrains ED;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ED.STRUCTURED_TEXT x) where x.nonNull {
  x.mediaType.equal("text/x-hl7-text+xml");
  x.translation.isEmpty;
  x.description.notApplicable;
  x.thumbnail.notApplicable;
  x.compression.notApplicable;
  x.reference.notApplicable;
  x.integrityCheck.notApplicable;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="mediaType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="text/x-hl7-text+xml"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Media Type"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="MediaType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="description" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Description"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="thumbnail" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Thumbnail"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="translation" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:businessName name="Translation"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="ED"/>
         </mif:type>
      </mif:property>
      <mif:property name="compression" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Compression"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CompressionAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="reference" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Reference"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="TEL.URL"/>
      </mif:property>
      <mif:property name="integrityCheck" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Integrity Check"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="BIN"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ED.STRUCTURED_TITLE" title="StructuredTitle" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="ED"/>
                  </mif:object> so that the contents are a structured title. 
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						The mediaType SHALL be "text/x-hl7-title+xml". The contents of the ED SHALL be a valid
						title as described by CDA and SPL. No translations are allowed.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor StructuredTitle alias ED.STRUCTURED_TITLE constrains ED;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ED.STRUCTURED_TITLE x) where x.nonNull {
  x.mediaType.equal("text/x-hl7-title+xml");
  x.translation.isEmpty;
  x.description.notApplicable;
  x.thumbnail.notApplicable;
  x.compression.notApplicable;
  x.reference.notApplicable;
  x.integrityCheck.notApplicable;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="mediaType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="text/x-hl7-title+xml"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Media Type"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="MediaType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="description" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Description"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="thumbnail" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Thumbnail"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="translation" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:businessName name="Translation"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="ED"/>
         </mif:type>
      </mif:property>
      <mif:property name="compression" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Compression"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CompressionAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="reference" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Reference"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="TEL.URL"/>
      </mif:property>
      <mif:property name="integrityCheck" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Integrity Check"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="BIN"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ST.NT" title="StringNoTranslations" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ST"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="ST"/>
                  </mif:object> so that it there are no translations.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						Translations SHALL be empty.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor StringNoTranslations alias ST.NT constrains ST;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ST.NT x) where x.nonNull {
  x.translation.isEmpty;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="translation" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:businessName name="Translation"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="ED"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ST.SIMPLE" title="StringSimple" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ST.NT"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="ST.NT"/>
                  </mif:object> so that it does not specify a language.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						language SHALL be not applicable. 
					</mif:p>
                  <mif:p>
						The concept of language does not apply to these strings - they are always to be understood as a sequence of 
						characters that identify a concept in some language independent fashion.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor StringSimple alias ST.SIMPLE constrains ST.NT;
</mif:data>
            </mif:otherAnnotation>
            <mif:otherAnnotation type="ITS-Note">
               <mif:text>
                  <mif:p>
							This type corresponds to a simple string in most implementation technologies (i.e. xs:string in W3C Schema).
						</mif:p>
               </mif:text>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ST.SIMPLE x) where x.nonNull {
  x.language.notApplicable;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="language" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Language"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="HumanLanguage"/>
         </mif:vocabularySpecification>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="SC.NT" title="CodedStringNoTranslations" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="SC"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="SC"/>
                  </mif:object> so that it has no translations.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						Translations SHALL be empty.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor CodedStringNoTranslations alias SC.NT constrains SC;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (SC.NT x) where x.nonNull {
  x.translation.isEmpty;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="CV" title="CodedValue" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="CD"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="CD"/>
                  </mif:object> so that there is no translations,
						and only a single concept is allowed.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is used when any reasonable use case will require only a
						single code value. Thus, it should not be used in circumstances where
						multiple alternative codes for a given value are desired. Note that this 
						prevents graceful migration from one code system to another, so <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is not usually
						used outside the data types specification.
					</mif:p>
                  <mif:p>
						There SHALL be no translations, and there SHALL be no source.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor CodedValue alias CV constrains CD;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (CV x) where x.nonNull {
  x.translation.isEmpty;
  x.source.isNull;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="translation" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:businessName name="Translation"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="CD"/>
         </mif:type>
      </mif:property>
      <mif:property name="source" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Source"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="CD"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TEL.URL" title="LocatableResource" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TEL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="TEL"/>
                  </mif:object>  so that it points to a locatable resource that returns binary content.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						The URL scheme SHALL be "file", "ftp", "cid", "http", "https" or "nfs". Use "cid" is for soap attachments.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor LocatableResource alias TEL.URL constrains TEL;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TEL.URL x) where x.nonNull {
 x.use.isEmpty.and(
  x.scheme.equal("file").or(
   x.scheme.equal("ftp").or(
    x.scheme.equal("http").or(
     x.scheme.equal("https").or(
      x.scheme.equal("cid").or(
       x.scheme.equal("nfs")))))));
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="use" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:businessName name="Use Code"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="TEL"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="TelecommunicationAddressUse"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="scheme" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Scheme"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="URL"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="URLScheme"/>
         </mif:vocabularySpecification>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TEL.PHONE" title="TelephoneAddress" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TEL.PERSON"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="TEL.PERSON"/>
                  </mif:object>  so it refers to some telephone based
						communication system with a person or organisation.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						The URL scheme SHALL be "tel".
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor TelephoneAddress alias TEL.PHONE constrains TEL.PERSON;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TEL.PHONE x) where x.nonNull {
  x.scheme.equal("tel");
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="scheme" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Scheme"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="URL"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="URLScheme"/>
         </mif:vocabularySpecification>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TEL.EMAIL" title="EmailAddress" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TEL.PERSON"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains the <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="TEL.PERSON"/>
                  </mif:object>  type so that it is an SMTP email address.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						The URL scheme SHALL be "mailto:".
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor EmailAddress alias TEL.EMAIL constrains TEL.PERSON;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TEL.EMAIL x) where x.nonNull {
  x.scheme.equal("mailto");
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="scheme" sortKey="01" propertyKind="variableProperty" visibility="public"
                    fixedValue="mailto"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Scheme"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="URL"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="URLScheme"/>
         </mif:vocabularySpecification>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PNXP" title="PersonNamePart" datatypeKind="Flavor" visibility="protected">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ENXP"/>
      </mif:derivedFrom>
      <mif:property name="qualifier" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:businessName name="Qualifier"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ENXP"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="EntityNamePartQualifier"/>
         </mif:vocabularySpecification>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PN" title="PersonName" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="EN"/>
      </mif:derivedFrom>
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="PNXP"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="EN"/>
                  </mif:object> for use when the named Entity
						is a Person. 
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						It constrains <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ENXP"/>
                     </mif:object> used in the parts 
						so that only those entity name parts qualifiers applicable to person names
						are allowed. Since the structure of entity name is mostly determined by the
						requirements of person name, the restriction is very minor.
					</mif:p>
                  <mif:p>
						The qualifier on any part SHALL NOT include the code "LS".
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor PersonName alias PN constrains EN;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PN x) where x.nonNull {
   forall(ENXP part)
         where x.contains(part) {
      part.qualifier.contains(EntityPartNameQualifier.LS).not;
      }
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="ONXP" title="OrganizationNamePart" datatypeKind="Flavor"
                 visibility="protected">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ENXP"/>
      </mif:derivedFrom>
      <mif:property name="partType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Name Part Type"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ENXP"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="EntityNamePartType"/>
         </mif:vocabularySpecification>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ON" title="OrganizationName" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="EN"/>
      </mif:derivedFrom>
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="ONXP"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="EN"/>
                  </mif:object> for use when the named Entity
						is an Organization. 
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						It constrains <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="ENXP"/>
                     </mif:object> used in the parts 
						so that only those entity name part types and qualifiers applicable to organization names
						are allowed. 
						Organization names, such as "Health Level Seven, Inc." mostly consist only
						of untyped name parts, prefixes, suffixes, and delimiters.
					</mif:p>
                  <mif:p>
						The family and given name part types SHALL not be used in the name of an organisation.
					</mif:p>
                  <mif:p>
						The following qualifiers SHALL not be used in the parts of the name of an organisation: BR, AD, SP, MID, AC, PR, NB, HON. 
						The following codes SHALL not be used in the organisation name use: I, P, R, DN, M.
					</mif:p>
                  <mif:div title="Examples">ON-examples
							The following is the organization name, "Health Level Seven, Inc." in
							a simple string form:
						&lt;name&gt;Health Level Seven, Inc.&lt;/name&gt;
							And with the legal status "Inc." as a distinguished name part:
						&lt;name&gt;Health Level Seven, &lt;suffix qualifier="LS"&gt;Inc.&lt;/suffix&gt;&lt;/name&gt;</mif:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor OrganizationName alias ON constrains EN;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ON x) where x.nonNull {
  forall(ENXP part)
         where x.contains(part) {
      part.type.implies(EntityNamePartType.FAM).not;
      part.type.implies(EntityNamePartType.GIV).not;
      }
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="TNXP" title="TrivialNamePart" datatypeKind="Flavor"
                 visibility="protected">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ENXP"/>
      </mif:derivedFrom>
      <mif:property name="partType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Name Part Type"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ENXP"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="EntityNamePartType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="qualifier" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:businessName name="Qualifier"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ENXP"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="EntityNamePartQualifier"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="isNull" sortKey="03" propertyKind="variableProperty" visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Exceptional Value"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BN"/>
      </mif:property>
      <mif:property name="nonNull" sortKey="04" propertyKind="variableProperty" visibility="public"
                    fixedValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Proper Value"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BN"/>
      </mif:property>
      <mif:property name="other" sortKey="05" propertyKind="variableProperty" visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value Domain Exception"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="notApplicable" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Inapplicable Proper Value"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="unknown" sortKey="07" propertyKind="variableProperty" visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="unknown"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="nullFlavor" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Exceptional Value Detail"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="NullFlavor"/>
         </mif:vocabularySpecification>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TN" title="TrivialName" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="EN"/>
      </mif:derivedFrom>
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="TNXP"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="EN"/>
                  </mif:object>  so that it is effectively a simple string, suitable
						for use as a simple name for things and places.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> with its
						single name part is therefore equivalent to a simple character
						string.
					</mif:p>
                  <mif:p>
						There SHALL only be one part type, its type SHALL be unknown, and it SHALL have 
						no qualifiers. As a consequence of this, the formatted rendition of then name
						is exactly equal to the one part of the name itself.
					</mif:p>
                  <mif:p>
						Trivial names are typically used for places and things, such as
						<mif:b>Lake Erie</mif:b> or <mif:b>Washington-Reagan National Airport</mif:b>:
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor TrivialName alias TN constrains EN;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TN x) where x.nonNull {
   x.head.nonNull;
   x.head.partType.isNull;
   x.tail.isEmpty;
   x.formatted.equal(x.head);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
            <mif:staticExample itsName="XML">
               <mif:data>
                  <example>
&lt;name&gt;Lake Erie&lt;/name&gt;
&lt;name&gt;Washington-Reagan National Airport&lt;/name&gt;</example>
               </mif:data>
            </mif:staticExample>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="length" sortKey="01" propertyKind="variableProperty" visibility="public"
                    fixedValue="1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Length"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="LIST"/>
         </mif:derivedFrom>
         <mif:type name="INT"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="INT.NONNEG" title="IntegerNonNegative" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="INT"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="INT"/>
                  </mif:object>  so that it has a value of 0 or greater.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						The value of the INT SHALL be equal or greater than 0 if it is not null.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor IntegerNonNegative alias INT.NONNEG constrains INT;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (INT.NONNEG x) where x.nonNull {
  x.greaterOrEqual(0);
  x.nullFlavor.implies(NullFlavor.NINF).not;
  x.isNegative.not;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="isNegative" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Negative"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="INT"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="INT.POS" title="IntegerPositive" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="INT.NONNEG"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="INT.NONNEG"/>
                  </mif:object>  so that it has a value greater than 0.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						The value of the INT SHALL be greater than 0 if it is not null.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor IntegerPositive alias INT.POS constrains INT.NONNEG;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (INT.POS x) where x.nonNull {
  x.greaterThan(0);
  x.isZero.not;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="isZero" sortKey="01" propertyKind="variableProperty" visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="The Zero-Quantity"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTZ"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PQ.TIME" title="LengthOfTime" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="PQ"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constraints <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="PQ"/>
                  </mif:object> so that it has units that describe a period of time.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						The units SHALL be some UCUM code that refers to a measurement of time. Translations are not allowed.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor LengthOfTime alias PQ.TIME constrains PQ;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PQ.TIME x, PQ y) where x.nonNull.and(y.unit.equal("s")) {
  x.isComparableTo(y);
  x.translation.isEmpty;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="unit" sortKey="01" propertyKind="variableProperty" visibility="public"
                    defaultValue="1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Unit of Measure"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="PQ"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="UnitsOfMeasureCaseSensitive"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="translation" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:businessName name="Translation"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="PQ"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="PQR"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TS.DATE" title="Date" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TS"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="TS"/>
                  </mif:object>  so that it only contains a date value.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						If the value is not null, there SHALL be 8 or fewer digits, and there can be no timezone. This flavor is specific
						to the gregorian calendar.
					</mif:p>
                  <mif:p>
						The string literal representation of this form is YYYY[MM[DD]].
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor Date alias TS.DATE constrains TS;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.DATE x) where x.nonNull {
  x.timezone.isNull;
  x.precision.lessOrEqual(8);
  x.calendar.implies(Calendar.GREG);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="timezone" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Timezone Offset"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="TS"/>
         </mif:derivedFrom>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="precision" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:enumerationValue>4</mif:enumerationValue>
         <mif:enumerationValue>6</mif:enumerationValue>
         <mif:enumerationValue>8</mif:enumerationValue>
         <mif:businessName name="Precision of the Calendar Literal Form"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="TS"/>
         </mif:derivedFrom>
         <mif:type name="INT"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TS.DATE.FULL" title="FullDate" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TS.DATE"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="TS.DATE"/>
                  </mif:object>  so that it contains a reference to a particular day.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						If the value is not null, there SHALL be 8 digits in the literal form, with no timezone. This flavor is specific
						to the gregorian calendar.
					</mif:p>
                  <mif:p>
						The string literal representation of this form is YYYYMMDD.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor FullDate alias TS.DATE.FULL constrains TS.DATE;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.DATE.FULL x) where x.nonNull {
  x.precision.equal(8);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="precision" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="8"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Precision of the Calendar Literal Form"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="TS.DATE"/>
         </mif:derivedFrom>
         <mif:type name="INT"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TS.DATETIME" title="DateTime" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TS"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains a <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="TS"/>
                  </mif:object>  so that it is not more precise
						than seconds.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						If the value is not null, there SHALL be 14 or less digits, and there can be a timezone. This flavor is specific
						to the gregorian calendar.
					</mif:p>
                  <mif:p>
						The string literal representation of this form is YYYY[MM[DD[hh[mm[ss]]]]][+/-ZZZZ].
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor DateTime alias TS.DATETIME constrains TS;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.DATETIME x) where x.nonNull {
  x.precision.lessOrEqual(14);
  x.calendar.implies(Calendar.GREG);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="precision" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:enumerationValue>4</mif:enumerationValue>
         <mif:enumerationValue>6</mif:enumerationValue>
         <mif:enumerationValue>8</mif:enumerationValue>
         <mif:enumerationValue>10</mif:enumerationValue>
         <mif:enumerationValue>12</mif:enumerationValue>
         <mif:enumerationValue>14</mif:enumerationValue>
         <mif:businessName name="Precision of the Calendar Literal Form"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="TS"/>
         </mif:derivedFrom>
         <mif:type name="INT"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TS.DATETIME.FULL" title="FullDateTime" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TS.DATETIME"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="TS.DATETIME"/>
                  </mif:object> so that it contains a reference to a particular second with a timezone.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						If the value is not null, there SHALL be 14 digits in the literal form. There SHALL be a timezone. This flavor
						is specific to the gregorian calendar.
					</mif:p>
                  <mif:p>
						The string literal representation of this form is YYYYMMDDhhmmss+/-ZZZZ.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor FullDateTime alias TS.DATETIME.FULL constrains TS.DATETIME;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.DATETIME.FULL x) where x.nonNull {
  x.precision.equal(14);
  x.timezone.nonNull;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="precision" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="14"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Precision of the Calendar Literal Form"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="TS.DATETIME"/>
         </mif:derivedFrom>
         <mif:type name="INT"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TS.INSTANT" title="InstantInTime" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TS.DATETIME"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="TS.DATETIME"/>
                  </mif:object> so that it contains a reference to a particular millisecond with a timezone.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						If the value is not null, there SHALL be 17 digits in the literal form. There SHALL be a timezone. This flavor
						is specific to the gregorian calendar.
					</mif:p>
                  <mif:p>
						The string literal representation of this form is YYYYMMDDhhmmss.zzz+/-ZZZZ.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor InstantInTime alias TS.INSTANT constrains TS.DATETIME;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.DATETIME.FULL x) where x.nonNull {
  x.precision.equal(17);
  x.timezone.nonNull;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="precision" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="17"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Precision of the Calendar Literal Form"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="TS.DATETIME"/>
         </mif:derivedFrom>
         <mif:type name="INT"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="IVL.LOW" title="IntervalLow" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="IVL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="IVL"/>
                  </mif:object> so that low is provided and lowClosed is true.
						All other properties are prohibited.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						If the value is not null, low SHALL be provided and lowClosed SHALL be true. high and highClosed are prohibited.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor IntervalLow alias IVL.LOW constrains IVL&lt;T&gt;;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL.LOW x) where x.nonNull {
  x.low.nonNull;
  x.lowClosed;
  x.high.isNull;
  x.highClosed.isNull;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="low" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Low Boundary"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="lowClosed" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Low Boundary Closed"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="high" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="High Boundary"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="highClosed" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="High Boundary Closed"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="IVL.HIGH" title="IntervalHigh" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="IVL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="IVL"/>
                  </mif:object> so that high is provided and highClosed is true.
						All other properties are prohibited.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						If the value is not null, high SHALL be provided and highClosed SHALL be true. low and lowClosed SHALL be null.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor IntervalHigh alias IVL.HIGH constrains IVL&lt;T&gt;;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL.HIGH x) where x.nonNull {
  x.high.nonNull;
  x.highClosed;
  x.low.isNull;
  x.lowClosed.isNull;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="low" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Low Boundary"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="lowClosed" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Low Boundary Closed"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="high" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="High Boundary"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="highClosed" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="High Boundary Closed"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="IVL.WIDTH" title="IntervalWidth" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="IVL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="IVL"/>
                  </mif:object> so that width is mandatory and low, lowClosed, high and highClosed are prohibited.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						if the value is not null, Width SHALL be provided. low, lowClosed, high and highClosed  SHALL be null.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor IntervalWidth alias IVL.WIDTH constrains IVL&lt;T&gt;;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL.WIDTH x) where x.nonNull {
  x.width.nonNull;
  x.low.isNull;
  x.lowClosed.isNull;
  x.high.isNull;  /* strictly this is superfluous */
  x.highClosed.isNull;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="low" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Low Boundary"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="lowClosed" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="Low Boundary Closed"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="high" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="High Boundary"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="highClosed" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:businessName name="High Boundary Closed"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="width" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Width"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="QTY"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="URG.LOW" title="UncertainRangeLow" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="URG"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="URG"/>
                  </mif:object> so that low and lowClosed are required.
						high and highClosed are prohibited.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						If the value is not null, range.low SHALL be provided and range.lowClosed SHALL be true. range.high and range.highClosed SHALL be null.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor UncertainRangeLow alias URG.LOW constrains URG&lt;T&gt;;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (URG.LOW x) {
  exists(IVL.LOW r) {
    x.range.equal(r);
  }
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="range" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Range"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="URG"/>
         </mif:derivedFrom>
         <mif:type name="IVL.LOW">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="URG.HIGH" title="UncertainRangeHigh" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="URG"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="URG"/>
                  </mif:object> so that high and highClosed are required.
						low and lowClosed are prohibited.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						If the value is not null, high SHALL be provided and highClosed SHALL be true. low and lowClosed SHALL be null.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor UncertainRangeHigh alias URG.HIGH constrains URG&lt;T&gt;;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (URG.HIGH x) where x.unknown {
  exists(IVL.HIGH r) {
    x.range.equal(r);
  }
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="range" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Range"/>
         <mif:derivedFrom>
            <mif:targetDatatype name="URG"/>
         </mif:derivedFrom>
         <mif:type name="IVL.HIGH">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="GTS.BOUNDEDPIVL" title="BoundedPeriodicInterval" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="QSI">
            <mif:argumentDatatype name="TS"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <mif:object name="itemName">
                     <mif:param name="item" value="datatype"/>
                  </mif:object> constrains <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="QSI&lt;TS&gt;"/>
                  </mif:object> (GTS) so that it only allows an intersection of <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="IVL&lt;TS&gt;"/>
                  </mif:object>
						and <mif:object name="datatypeRef">
                     <mif:param name="datatypeName" value="PIVL&lt;TS&gt;"/>
                  </mif:object>. 
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
						This allows a system to capture a frequency together with an outer time boundary
						and is useful for things like dosage instructions.
					</mif:p>
                  <mif:p>
						The Bounded PIVL SHALL contain 2 terms. One of the terms SHALL be an <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="IVL&lt;TS&gt;"/>
                     </mif:object> and one
						SHALL be a <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PIVL&lt;TS&gt;"/>
                     </mif:object>.
					</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor BoundedPeriodicInterval alias GTS.BOUNDEDPIVL constrains QSI&lt;TS&gt;;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (GTS.BOUNDEDPIVL x) where x.nonNull {
  x.dataType.equals(QSI&lt;TS&gt;);
  ((QSI&lt;TS&gt;)x).terms.cardinality.equal(2);
  exists(IVL&lt;TS&gt; y) {((QSI&lt;TS&gt;)x).terms.contains(y)};
  exists(PIVL&lt;TS&gt; z) {((QSI&lt;TS&gt;)x).terms.contains(z)};  
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="PPD" title="ParametricProbabilityDistribution" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="T" qualifier="parameter"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A generic data type extension specifying uncertainty of quantitative
					data using a distribution function and its parameters. 
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					Aside from the 
					specific parameters of the distribution, a mean (expected value) and 
					standard deviation is always given to help maintain a minimum layer
					of interoperability if receiving applications cannot process a
					given probability distribution.
				</mif:p>
                  <mif:p>
					For example, the most common college entrance exam in the United
					States is the SAT, which includes three parts: reading, math and writing. 
					Each part has a minimum score of 400 (no questions answered
					correctly) and a perfect score of 800. In 1998, according to the
					College Board, 1,172,779 college-bound seniors took the test. The mean
					score for the math portion of the test was 512, and the standard
					deviation 112. These parameter values (512, 112), tagged as the normal
					distribution parameters, paint a pretty good picture of test score
					distribution. In most cases, there is no need to specify all
					1-million+ points of data when just 2 parameters will do!
				</mif:p>
                  <mif:img imageType="image/gif" hl7Id="PPD.example" src="DT-PPD-ex1.gif"
                           alt="Example for a parametric probability distribution"/>
                  <mif:p>
					Note that the normal distribution is only one of several distributions
					defined for HL7.
				</mif:p>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> SHALL only be applied to value domains that have a continuous distribution
					(<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="REAL"/>
                     </mif:object>, <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PQ"/>
                     </mif:object>, <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="MO"/>
                     </mif:object>, and
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="TS"/>
                     </mif:object>). Uncertainty (<mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>) MAY be applied to the numerator
					and denominator of a <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="RTO"/>
                     </mif:object> separately.
				</mif:p>
                  <mif:p>
					Since a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> specializes T, a simple T value is
					the mean (expected value or first moment) of the probability
					distribution. Applications that cannot deal with distributions will
					take the simple T value neglecting the uncertainty. That simple value
					of type T is also used to standardize the data for computing the
					distribution.
					</mif:p>
                  <mif:p>
					Where applicable, <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> conforms to
					the ISO <mif:b>Guide to the Expression of Uncertainty in
					Measurement</mif:b> (GUM) as reflected by NIST publication 1297
					<mif:b>Guidelines for Evaluating and Expressing the Uncertainty of NIST
					Measurement Results</mif:b>. <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> does not
					describe how uncertainty is to be evaluated but only how it is
					expressed. The concept of "standard uncertainty" as set forth by the
					ISO GUM corresponds to <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="standardDeviation"/>
                        <mif:param name="datatypeName" value="PPD"/>
                     </mif:object>.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type ParametricProbabilityDistribution&lt;T&gt; alias PPD&lt;T&gt; specializes T {
   T.diffType  standardDeviation;
   CS          distributionType;
   literal  ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PPD&lt;T&gt; x)  {
  x.datatype.implies(INT).not;
  x.datatype.implies(RTO).not;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="standardDeviation" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Standard Deviation"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							The root-mean-square deviation of the values from the mean
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							The <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is the primary measure of variance/uncertainty of the value,
							computed as the square
							root of the sum of the squares of the differences between the data
							points and the mean. <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is used to normalize the
							data for computing the distribution function. Applications that cannot
							deal with probability distributions can still get an idea about the
							confidence level by looking at <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object>.
						</mif:p>
                     <mif:p>
                        <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> is
							a specialization of <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="QTY"/>
                        </mif:object> (from T.diffType)
							that expresses differences between values of type T. If T is
							<mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object> or <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="INT"/>
                        </mif:object>,
							T.diffType is also <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object> or <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="INT"/>
                        </mif:object>
							respectively. However if T is <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="TS"/>
                        </mif:object>,
							T.diffType is a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object> in the dimension
							of time.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PPD x) {
   x.standardDeviation.dataType.implies(T.diffType);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="T" qualifier="parameterDiff"/>
      </mif:property>
      <mif:property name="distributionType" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Probability Distribution Type"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text>
							A code specifying the type of probability distribution. 
						</mif:text>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>	Possible
							values for <mif:object name="itemName">
                           <mif:param name="item" value="property"/>
                        </mif:object> are as shown in the attached table. The NULL value (unknown)
							for the type code indicates that the probability distribution type is
							unknown. In that case, <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="standardDeviation"/>
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object>
							has the meaning of an informal guess.
						</mif:p>
                     <mif:p>
                        <mif:object name="conceptDomainRef">
                           <mif:param name="domain" value="ProbabilityDistributionType"/>
                        </mif:object> 
							lists the 
							probability distributions defined for this specification. Many distribution types are defined in
							terms of special parameters (e.g., the parameters Î± and Î²
							for the Î³-distribution, number of degrees of freedom for the
							<mif:b>t</mif:b>-distribution, etc.).  For all distribution types,
							however, the mean and standard deviation are defined. 
							
							</mif:p>
                     <mif:p>
							The three distribution-types <mif:b>unknown</mif:b> (NULL),
							<mif:b>uniform</mif:b> and <mif:b>normal</mif:b> SHALL be supported by
							every system that claims to support <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>. All other distribution
							types are optional. When a system interpreting a <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>
							representation encounters a distribution type that it does not
							recognize, it SHOULD map this type to the unknown (NULL) distribution-type.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="ProbabilityDistributionType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="literal" sortKey="03" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
							 The general syntax of the literal form for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is as follows:
						</mif:p>
                     <mif:p>
							Examples: an example for a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PPD_REAL"/>
                        </mif:object>
							is "1.23(N0.005)" for a normal <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="distributionType"/>
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object>
							around 1.23 with a <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="standardDeviation"/>
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object> of 0.005.
							An example for a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PPD_PQ"/>
                        </mif:object> is "1.23 m (5 mm)" for
							an unknown <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="distributionType"/>
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object> around the
							length 1.23 meter with a <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="standardDeviation"/>
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object>
							of 5 millimeter. An example for a <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PPD_TS"/>
                        </mif:object>
							is "2000041113(U4 h)" for a	uniform
							<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="distributionType"/>
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object> around April 11, 2000
							at 1pm with <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="standardDeviation"/>
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object> of 4 hours.
						</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
PPD&lt;T&gt;.literal ST.SIMPLE {
   PPD&lt;T&gt;  : T "(" type QTY ")"  { ((T)$).equal($1);
                                   $.distributionType.equal($3);
                                   $.standardDeviation.equal($4); };
   CV type : ST                  { $.value.equal($1);
                                   $.codeSystem.equal(2.16.840.1.113883.5.1020); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PPD_REAL" title="ParametricProbabilityDistribution&lt;RealNumber&gt;"
                 datatypeKind="Binding"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text/>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
					The parametric probability distribution of real numbers is fully defined by
					the generic data type.
					However, there are some special considerations about literal representations
					and conversions of probability distributions over <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="REAL"/>
                     </mif:object>s, which are
					specified in this section.
				</mif:p>
                  <mif:div title="&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Converting a real number (REAL) to an uncertain real number&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(PPD&lt;REAL&gt;)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;">
						When converting a  into a ,
						 is calculated from the
						 value's order of magnitude and
						
						(number of significant digits).
						Let x be a  with
						Â n. We can
						determine the order of magnitude e of x as
						e = log10 |x| where e is rounded to
						the next integer that is closer to zero (special case: if x
						is zero, e is zero).  The value of the least significant digit
						l is then l = 10e-n
						and the  Ï = l /
						2.
					Examples of standard deviations computed from precision p and order of magnitude eRepresentationxepe - p + 1lÏ00(0)1010.51101010.52201010.59901010.5101012010.510010023010.51e+1101111051e+21002121005010e+11002211051.11.102-10.10.0510.110.113-10.10.051.1e+21102211051.1e-20.011-22-30.0010.00051.1e-40.00011-42-50.000010.00000510.1e-40.00101-33-50.000010.0000050.1e-10.01-21-20.010.0050.01e-10.001-31-30.0010.00050.01e-20.0001-41-40.00010.000050.000(0)3-20.010.005</mif:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type ParametricProbabilityDistribution&lt;RealNumber&gt; alias PPD&lt;REAL&gt; specializes PPD&lt;T&gt;;</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:binding>
         <mif:targetDatatype name="PPD"/>
         <mif:argumentDatatype name="REAL"/>
      </mif:binding>
      <mif:property name="literal" sortKey="01" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Concise Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						Besides the generic literal form of <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object>, a
						concise literal form is defined for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> over real
						numbers. This concise literal form is defined such that
						<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="standardDeviation"/>
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object> can be expressed
						in terms of the least significant digit in the mantissa.
						This literal is defined as an extension of the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object> literal:
					</mif:p>
                     <mif:p>
						Examples: "1.23e-3 (U5e-6)" is the uniform
						<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="distributionType"/>
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object> around 1.23
						Ã 10<mif:sup>-3</mif:sup> with 5 Ã 10<mif:sup>-6</mif:sup>
						Â <mif:object name="propertyRef">
                           <mif:param name="propertyName" value="standardDeviation"/>
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object> in generic
						literal form. "1.230(U5)e-3" is the same value in
						concise literal form.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
PPD&lt;REAL&gt;.literal ST.SIMPLE {
   PPD&lt;REAL&gt; mantissa
           : REAL.mantissa "(" type QTY ")"  { ((T)$).equal($1);
                                                   $.distributionType.equal($3);
                                                   $.standardDeviation.equal($4); }
           | REAL.mantissa                   { $.equal($1);
                                               $.distributionType.equal($3);
                                               $.standardDeviation.equal(
                                                  $1.leastSignificantDigit.times(0.5)); };
   CS type : ST                              { $.value.equal($1);
                                               $.system.equal(2.16.840.1.113883.5.1019); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="PPD"/>
         </mif:derivedFrom>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PPD_PQ" title="ParametricProbabilityDistribution&lt;PhysicalQuantity&gt;"
                 datatypeKind="Binding"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text/>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is constructed from <mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PPD"/>
                     </mif:object>. However,
					recognizing that the <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="unit"/>
                        <mif:param name="datatypeName" value="PQ"/>
                     </mif:object> can be factored
					from the boundaries, we add additional semantics and a
					separate literal form. The additional view of a <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object>
					is a probability distribution over real numbers with one unit.
				</mif:p>
                  <mif:p>
					The unit applies to both mean and <mif:object name="propertyRef">
                        <mif:param name="propertyName" value="standardDeviation"/>
                        <mif:param name="datatypeName" value="PPD"/>
                     </mif:object>.
				</mif:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type ParametricProbabilityDistribution&lt;PhysicalQuantity&gt; alias PPD&lt;PQ&gt; specializes PPD&lt;T&gt; {
   PPD&lt;REAL&gt; value;
   CS  unit;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PPD&lt;PQ&gt; x)
      where x.nonNull {
   x.value.nonNull;
   ((REAL)x.value).equal(((PQ)x).value);
   x.unit.equal(((PQ)x).unit);
   x.value.standardDeviation.equal(x.standardDeviation.value);
   x.standardDeviation.unit.equal(x.unit);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:binding>
         <mif:targetDatatype name="PPD"/>
         <mif:argumentDatatype name="PQ"/>
      </mif:binding>
      <mif:property name="value" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Value"/>
         <mif:type name="PPD">
            <mif:argumentDatatype name="REAL"/>
         </mif:type>
      </mif:property>
      <mif:property name="unit" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Unit"/>
         <mif:type name="CS"/>
      </mif:property>
      <mif:property name="literal" sortKey="03" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:businessName name="Concise Literal Form"/>
         <mif:annotations>
            <mif:documentation>
               <mif:definition>
                  <mif:text/>
               </mif:definition>
               <mif:designComments>
                  <mif:text>
                     <mif:p>
						A concise literal form for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> is defined based on
						the concise literal form of <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PPD_REAL"/>
                        </mif:object>
						where <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="REAL"/>
                        </mif:object> is the value. This
						literal is defined as an extension of the <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PQ"/>
                        </mif:object> literal.
					</mif:p>
                     <mif:p>
						Examples: "1.23e-3 m (N5e-6 m)" is the normal-distributed length of
						1.23 Ã 10<mif:sup>-3</mif:sup> m with 5 Ã 10<mif:sup>-6</mif:sup> m
						<mif:object name="propertyRef">
                           <mif:param name="propertyName" value="standardDeviation"/>
                           <mif:param name="datatypeName" value="PPD"/>
                        </mif:object> in generic literal
						form. "1.230(N5)e-3 m" is the same value in concise literal
						form. "1.23e-3(N0.005e-3) m " is also valid; it is the concise literal
						form for <mif:object name="itemName">
                           <mif:param name="item" value="datatype"/>
                        </mif:object> combined with the
						generic literal form for <mif:object name="datatypeRef">
                           <mif:param name="datatypeName" value="PPD_REAL"/>
                        </mif:object>.
					</mif:p>
                  </mif:text>
               </mif:designComments>
            </mif:documentation>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
PPD&lt;PQ&gt;.literal ST.SIMPLE {
   PPD&lt;PQ&gt; : PPD&lt;REAL&gt; " " unit  { $.value.equal($1);
                                   $.unit.equal($3); }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="PPD"/>
         </mif:derivedFrom>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PPD_TS" title="ParametricProbabilityDistribution&lt;PointInTime&gt;"
                 datatypeKind="Binding"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text/>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <mif:p>
                     <mif:object name="itemName">
                        <mif:param name="item" value="datatype"/>
                     </mif:object> is fully defined by the generic data type.
					<mif:object name="propertyRef">
                        <mif:param name="propertyName" value="standardDeviation"/>
                        <mif:param name="datatypeName" value="PPD"/>
                     </mif:object> is of type TS.diffType, which is a duration (a
					<mif:object name="datatypeRef">
                        <mif:param name="datatypeName" value="PQ"/>
                     </mif:object> in the dimension of time).
				</mif:p>
                  <mif:div title="Converting  to ">
						When converting a  into a ,
						 is
						calculated from the  value's order of magnitude
						and precision (number of significant digits) such that two
						s span the maximal time range of the digits not
						specified. For example, in 20000609 the unspecified digits are hour of
						the day and lower. All these digits together span a duration of 24
						hours, and thus,  is 12 h, or half the span from
						20000609000000.0000... up to 20000609999999.9999... (= 20000610).
					
						This rule is different from that specified for 
						in that the range of uncertainty lies 
						above the time value specified. This is to go with the common sense judgment 
						that June 9th spans all day of June 9th with noon as the center, not midnight.
					</mif:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type ParametricProbabilityDistribution&lt;PointInTime&gt; alias PPD&lt;TS&gt; specializes PPD&lt;T&gt;;</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:binding>
         <mif:targetDatatype name="PPD"/>
         <mif:argumentDatatype name="TS"/>
      </mif:binding>
   </mif:datatype>
</mif:datatypeModelLibrary>