<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MARC.Everest.Formatters.XML.ITS1</name>
    </assembly>
    <members>
        <member name="T:MARC.Everest.Formatters.XML.ITS1.CodeGen.CreateTypeFormatterCompletedDelegate">
            <summary>
            Delegate for the create type formatter
            </summary>
        </member>
        <member name="T:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx">
            <summary>
            Represents a utility class that can create a code dom formatter
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.IsTraversable(System.Reflection.PropertyInfo)">
            <summary>
            Returns true if the property is traversable
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.IsNonStructural(System.Reflection.PropertyInfo)">
            <summary>
            Returns true if the property is traversable
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.CreateUtilConvertMethodInvoke(System.Type,System.CodeDom.CodeExpression)">
            <summary>
            Creates a code method invokation expression
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.GetBuildProperties(System.Type)">
            <summary>
            Get build properties
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.CreateCastTryCatch(System.Type,System.CodeDom.CodeExpression,System.CodeDom.CodeExpression,System.CodeDom.CodeExpression,System.CodeDom.CodeExpression,System.CodeDom.CodeMethodReferenceExpression)">
            <summary>
            Create a instance cast expression
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.CreateStringFormatExpression(System.String,System.CodeDom.CodeExpression[])">
            <summary>
            Creates a String.Format() expression
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.CreateSimpleMethodCallExpression(System.CodeDom.CodeExpression,System.String,System.Object[])">
            <summary>
            Create a simaple method call expression
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.CreateResultDetailExpression(System.Type,System.CodeDom.CodeExpression[])">
            <summary>
            Create a add result detail expression
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.CreateConvertExpression(System.String,System.CodeDom.CodeExpression)">
            <summary>
            Create ConvertExpression
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.CreateTypeFormatter(System.Object)">
            <summary>
            Create the type formatter declaration
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.CreateValidateMethod(System.Type,System.Collections.Generic.List{MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.BuildProperty})">
            <summary>
            Create the validation method
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.CreateParseElementsMethod(System.Type,System.Collections.Generic.List{MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.BuildProperty})">
            <summary>
            Create the parse elements method
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.CreateGraphMethod(System.Type,System.Collections.Generic.List{MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.BuildProperty})">
            <summary>
            Create the graph method for the formatter
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.CreateParseMethod(System.Type,System.Collections.Generic.List{MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.BuildProperty})">
            <summary>
            Create the parse method
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.CreateHandlesTypeProperty(System.Type)">
            <summary>
            Create the handles type property
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.CreateHostProperty">
            <summary>
            Create the host property for the specified type
            </summary>
        </member>
        <member name="P:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.ResetEvent">
            <summary>
            Gets or sets the reset event which signals the end of creation
            </summary>
        </member>
        <member name="E:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.CodeTypeDeclarationCompleted">
            <summary>
            Code type declaration has been completed
            </summary>
        </member>
        <member name="T:MARC.Everest.Formatters.XML.ITS1.CodeGen.TypeFormatterCreatorEx.BuildProperty">
            <summary>
            Build property context info
            </summary>
        </member>
        <member name="T:MARC.Everest.Formatters.XML.ITS1.CodeGen.CodeGenFormatter">
            <summary>
            This class handles the code generation method of formatting 
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.CodeGenFormatter.GetFormatter(System.Type)">
            <summary>
            Get the formatter for the specified type
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.CodeGenFormatter.GetUniqueTypes(System.Type,System.Collections.Generic.List{System.Type},System.Boolean)">
            <summary>
            Get unique types that <paramref name="rmimTypes"/> references
            </summary>
            <param name="rmimType">The rmim type to scan</param>
            <param name="current">The list of currently processed types</param>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.CodeGenFormatter.CreateFormatterAssembly(System.Type[],System.Collections.Generic.List{MARC.Everest.Connectors.IStructureFormatter},System.Boolean)">
            <summary>
            Creates the formatter assembly for the specified types
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.CodeGen.CodeGenFormatter.AddFormatterAssembly(System.Reflection.Assembly)">
            <summary>
            Add a formatter assembly to the dict formatters
            </summary>
        </member>
        <member name="T:MARC.Everest.Formatters.XML.ITS1.Formatter">
            <summary>
            A linked class to <see cref="T:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter"/> that
            exists to retain backwards compatibility with pre 1.0 versions of Everest
            </summary>
        </member>
        <member name="T:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter">
             <summary>
             This is a generic formatter that reflects a type(s) and writes methods for 
             graphing RMIM objects using the ITS1.0 formatting rules.
             </summary>
             <remarks>
             <para>
             The XML ITS 1.0 formatter is designed to use two different methods of formatting
             in order to speed up the Parse and Graph operations.
             </para>
             <para>
             Whenever the formatter encounters an RMIM structure which does not have a graph aide,
             it will check its type cache to determine if formatting can be done via generated code
             (provided via code-dom). If there is a cache miss, the formatter will branch a new 
             thread to "learn" the message and will continue formatting operations using Reflection.
             </para>
             <para>
             This type of algorithm allows the formatter to become faster and more efficient the 
             longer it runs in memory. The algorithms used in memory are controlled via the <see cref="P:Settings"/>
             property. By default the Formatter will select the following settings:
             </para>
             <list type="table">
                 <listheader>
                     <term>Condition</term>
                     <description>Setting</description>
                 </listheader>
                 <item>
                     <term>Single Processor</term>    
                     <description>This setting will not use code-dom and will opt for reflection only formatting</description>
                 </item>
                 <item>
                     <term>Multi Processor</term>
                     <description>This setting will use generated formatter classes when available. If no generated class is available, code-dom is used to "learn" the message type and reflection is used to serialize</description>
                 </item>
             </list>
             <para>
             Furthermore, this formatter can be optimized during initialization using the <see cref="F:BuildCache"/> and 
             <see cref="F:AddFormatterAssembly"/> methods. These methods force the formatter to "learn" structure prior
             actually serializing them. In the case of <see cref="F:AddFormatterAssembly"/>, it is possible to load an 
             assembly that was previously generated by the formatter into memory and add the data to its cache.
             </para>
             </remarks>
             <example>
             <code title="Creating and using Formatters" lang="cs">
             <![CDATA[
             using System; 
             using MARC.Everest.RMIM.CA.R020402.Interactions; 
             using MARC.Everest.RMIM.CA.R020402.Vocabulary; 
             using System.IO; using System.Xml; 
             using MARC.Everest.RMIM.CA.R020402.MCCI_MT002100CA; 
             using MARC.Everest.Formatters.XML.ITS1; 
             using MARC.Everest.Xml; 
             namespace EverestConsoleApplication1 { 
                class Program { 
                    static void Main(string[] args) 
                    {
                        // Memory stream, used to store the data in memory.
                        MemoryStream memstream = null;
            
                        // File stream, used to store the data in a file.
                        FileStream fs = null;
            
                        // Create an XML Writer that will write to the memory stream (when flushed) 
                        // and will indent the output text.
                        XmlStateWriter writer = null;
            
                        //declaring the XML Formattter. 
                        XmlIts1Formatter xmlF = new XmlIts1Formatter(); 
            
            
                        //Instance to graph to XML, only contains the mandatory values. 
                        PRPA_IN101103CA data = new PRPA_IN101103CA(
                            Guid.NewGuid(),
                            DateTime.Now,
                            ResponseMode.Immediate,
                            PRPA_IN101103CA.GetInteractionId(),
                            PRPA_IN101103CA.GetProfileId(),
                            ProcessingID.Production,
                            AcknowledgementCondition.Always,
                            new Receiver(new Device2(Guid.NewGuid())),
                            new Sender(new Device1(Guid.NewGuid()))
                        );
            
                        // Populate the Control Act Event with mandatory values. 
                        data.controlActEvent = PRPA_IN101103CA.CreateControlActEvent(
                            Guid.NewGuid(),
                            PRPA_IN101103CA.GetTriggerEvent(),
                            new MARC.Everest.Core.MR2009.MFMI_MT700751CA.Author(DateTime.Now),
                            new MARC.Everest.Core.MR2009.MFMI_MT700751CA.QueryByParameter<MARC.Everest.Core.MR2009.PRPA_MT101103CA.ParameterList>
                                (Guid.NewGuid(),
                                new MARC.Everest.Core.MR2009.PRPA_MT101103CA.ParameterList()
                            )
                        );
            
                        // Add the R1 format graphaides to the formatter. Lets us know how to translate the datatypes
                        xmlF.GraphAides.Add(new DatatypeFormatter());
            
                        try
                        {
                            // changes the size in memory dynamically and it has a memory location.
                            memstream = new MemoryStream();
            
                            // writer is going to be used as a holding area for the XML data, and when flushed,
                            // will be transferred to the MemoryStream(memstream). We go through this trouble 
                            // so that we can indent the XML code in the console and in the file.
                            writer = new XmlStateWriter(
                                XmlWriter.Create(memstream, new XmlWriterSettings { Indent = true })
                            );
            
                            // Translate the message object, data, into XML and stores it in the XmlStateWriter(writer)
                            var result = xmlF.Graph(writer, data);
            
                            // Dumps the contents of the XML Writer buffer to the memory stream. 
                            writer.Flush();
            
                            // Declare file to write to. 
                            fs = new FileStream(@"C:\temp\test43.xml", FileMode.OpenOrCreate);
            
                            Console.WriteLine("XML\r\n");
            
                            //Set to false to disable validation. 
                            xmlF.ValidateConformance = false; 
            
                            // writes to Console
                            memstream.WriteTo(Console.OpenStandardOutput());
            
                            // writes to file.
                            memstream.WriteTo(fs);
            
            
                        }
                        catch (Exception)
                        {
            
                            throw;
                        }
                        finally
                        {
            
                            if (null != fs)
                            {
                                Console.WriteLine("\r\nClosing File Stream now...");
                                fs.Close();
                                fs.Dispose();
                            }
                            if (null != writer)
                            {
                                Console.WriteLine("Closing XML State Writer now...");
                                writer.Close();
                            }
                            if (null != memstream)
                            {
                                Console.WriteLine("Closing memory stream now...");
                                memstream.Close();
                                memstream.Dispose();
                            }
                            xmlF.Dispose();
                        }
                        Console.ReadKey(); 
                    } 
                } 
            } 
             ]]>
             </code>
             </example>
        </member>
        <member name="F:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.NS_XSI">
            <summary>
            XSI
            </summary>
        </member>
        <member name="F:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.NS_HL7">
            <summary>
            HL7
            </summary>
        </member>
        <member name="F:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.m_syncRoot">
            <summary>
            The root of synchronization
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.#ctor">
            <summary>
            Creates a new instance of the Formatter class
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.Finalize">
            <summary>
            Destroys the instance of the formatter class
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.Graph(System.Xml.XmlWriter,MARC.Everest.Interfaces.IGraphable)">
            <summary>
            Graphs <paramref name="o"/> onto the <see cref="T:System.Xml.XmlWriter"/> <paramref name="s"/>
            </summary>
            <param name="s">The <see cref="T:System.Xml.XmlWriter"/> that should be used to graph the object</param>
            <param name="o">The <see cref="T:MARC.Everest.Interfaces.IGraphable"/> that should be graphed</param>
            <returns>A <see cref="T:MARC.Everest.Formatters.XML.ITS1.Its1FormatterGraphResult"/> containing the results of the graph</returns>
            <remarks>
            <para>
            This particular overload of the Graph method can be used to graph objects into a <see cref="T:System.Xml.XmlWriter"/> and can provide
            an opportunity to use Everest as an assistant (or XmlSerializerSurrogate) for more complex systems like WCF.
            </para>
            <example>
            <code lang="cs" title="Using Everest as a Serializer Assistant">
            <![CDATA[
            StringWriter sw = new StringWriter();
            XmlWriter writer = XmlWriter.Create(sw);
            writer.WriteStartElement("hello", "urn:my-org");
            
            Formatter f = new Formatter();
            f.GraphAides.Add(typeof(MARC.Everest.Formatters.XML.DataTypes.R1.Formatter));
            f.ValidateConformance = false;
            f.Graph(writer, new MCCI_IN000002CA());
            
            writer.WriteEndElement();
            writer.Close();
            Console.WriteLine(sw.ToString());
            
            ]]>
            </code>
            outputs
            <code lang="xml" title="Output of example">
            <![CDATA[
            <hello xmlns="urn:my-org">
                <MCCI_IN000002CA xmlns="urn:hl7-org:v3"/>
            </hello>
            ]]>
            </code>
            </example>
            <para>
            When using this method, it is recommended that you pass a <see cref="T:MARC.Everest.Xml.XmlStateWriter"/> as it 
            will allow the formatter to give additional location information when reporting issues.
            </para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.CalculateResultCode(System.Collections.Generic.IEnumerable{MARC.Everest.Connectors.IResultDetail})">
            <summary>
            Set an appropriate result code
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.Parse(System.Xml.XmlReader)">
            <summary>
            Parse an object from <see cref="T:System.Xml.XmlReader"/> <paramref name="r"/>
            </summary>
            <param name="r">The <see cref="T:System.Xml.XmlReader"/> to parse an object from</param>
            <returns>A <see cref="T:MARC.Everest.Formatters.XML.ITS1.Its1FormatterParseResult"/> containing the formatted instance</returns>
            <remarks>
            <para>
            This particular overload of the Graph method can be used to graph objects into a <see cref="T:System.Xml.XmlWriter"/> and can provide
            an opportunity to use Everest as an assistant (or XmlSerializerSurrogate) for more complex systems like WCF.
            </para>
            <example>
            <code lang="cs" title="Using Everest as a Serializer Assistant">
            <![CDATA[
            StringWriter sw = new StringWriter("<hello><MCCI_IN000002CA xmlns=\"urn:hl7-org:v3\"/></hello>");
            XmlReader reader = XmlReader.Create(sw);
            reader.Read(); // Read <hello>
            
            Formatter f = new Formatter();
            f.GraphAides.Add(typeof(MARC.Everest.Formatters.XML.DataTypes.R1.Formatter));
            f.ValidateConformance = false;
            var result = f.Parse(reader);
            
            reader.Read();
            reader.Close();
            Console.WriteLine(result.Code); 
            
            ]]>
            </code>
            </example>
            <para>
            When using this method, it is recommended that you pass a <see cref="T:MARC.Everest.Xml.XmlStateReader"/> as it 
            will allow the formatter to give additional location information when reporting issues.
            </para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.Parse(System.Xml.XmlReader,System.Type)">
            <summary>
            Parse an object from <see cref="T:System.Xml.XmlReader"/> <paramref name="r"/> using the type
            hint <param name="t"/>
            </summary>
            <param name="r">The <see cref="T:System.Xml.XmlReader"/> to parse an object from</param>
            <param name="t">The type hint to parse the object</param>
            <returns>A <see cref="T:MARC.Everest.Formatters.XML.ITS1.Its1FormatterParseResult"/> containing the formatted instance</returns>
            <remarks>
            <para>
            This particular overload of the Graph method can be used to graph objects into a <see cref="T:System.Xml.XmlWriter"/> and can provide
            an opportunity to use Everest as an assistant (or XmlSerializerSurrogate) for more complex systems like WCF.
            </para>
            <example>
            <code lang="cs" title="Using Everest as a Serializer Assistant">
            <![CDATA[
            StringWriter sw = new StringWriter("<hello><MCCI_IN000002CA xmlns=\"urn:hl7-org:v3\"/></hello>");
            XmlReader reader = XmlReader.Create(sw);
            reader.Read(); // Read <hello>
            
            Formatter f = new Formatter();
            f.GraphAides.Add(typeof(MARC.Everest.Formatters.XML.DataTypes.R1.Formatter));
            f.ValidateConformance = false;
            var result = f.Parse(reader, typeof(MCCI_IN000002CA));
            
            reader.Read();
            reader.Close();
            Console.WriteLine(result.Code); 
            
            ]]>
            </code>
            </example>
            <para>
            When using this method, it is recommended that you pass a <see cref="T:MARC.Everest.Xml.XmlStateReader"/> as it 
            will allow the formatter to give additional location information when reporting issues.
            </para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.Graph(System.IO.Stream,MARC.Everest.Interfaces.IGraphable)">
            <summary>
            Graphs object <paramref name="o"/> onto stream <paramref name="s"/>
            </summary>
            <param name="s">The stream to which <paramref name="o"/> is to be graphed</param>
            <param name="o">The object to be graphed</param>
            <returns>A <see cref="T:MARC.Everest.Formatters.XML.ITS1.Its1FormatterGraphResult"/> structure contianing the 
            results of formatting</returns>
            <seealso cref="F:Graph(System.Xml.XmlWriter,MARC.Everest.Interfaces.IGraphable)"/>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.RemoveXSITypeName(System.String)">
            <summary>
            Removes an XSI type from the registry
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.RegisterXSITypeName(System.String,System.Type)">
            <summary>
            Registers a specific xsi:type name for the specified type
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.Parse(System.IO.Stream)">
            <summary>
            Parse an object from <paramref name="s"/>
            </summary>
            <param name="s">The stream from which to parse an object</param>
            <returns>An <see cref="T:MARC.Everest.Formatters.XML.ITS1.Its1FormatterParseResult"/> structure containing the parsed information</returns>
            <remarks>
            <para>
            The parse method will attempt to search any of the already known types (ie: types already learned) for a serialization start point. If
            one is not found, the method will search the current AppDomain to find <see cref="T:MARC.Everest.Interfaces.IGraphable"/> classes
            which can be used to interpret the data within the stream. For this, the root element is used to find 
            which of the types can start serialization.
            </para>
            <para>
            While this method will work fine when dealing with one RMIM assembly, it is recommended that you use the 
            <seealso cref="F:Graph(System.IO.Stream,System.Reflection.Assembly)"/> method when more than one RMIM assembly
            is loaded in memory.
            </para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.Clone">
            <summary>
            Clones this formatter 
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.Parse(System.IO.Stream,System.Reflection.Assembly)">
            <summary>
            Parses an object from <paramref name="s"/> using <paramref name="a"/> to locate
            a suitable class definition to populate.
            </summary>
            <param name="s">The stream from which to parse the object</param>
            <param name="a"><paramref name="s"/> in object form</param>
            <returns>A <see cref="!:MARC.Everest.Formatters.XML.ITS1.Its1FormatterParseResult"/> containing the results of the parse</returns>
            <remarks>
            <para>This method differs from the <seealso cref="F:Parse(System.IO.Stream)"/> method in that it
            will only look within the specified assembly for a suitable class to populate.</para>
            <para>
            This method will not check the current learned type repository for a class to serialize (ie: it will always 
            check the assembly regardless of what has been formatted prior)
            </para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.Parse(System.Xml.XmlReader,System.Reflection.Assembly)">
            <summary>
            Parses an object from <paramref name="r"/> using <paramref name="a"/> to locate
            a suitable class definition to populate.
            </summary>
            <param name="r">The <see cref="T:System.Xml.XmlReader"/> from which to parse the object</param>
            <param name="a"><paramref name="s"/> in object form</param>
            <returns>A <see cref="!:MARC.Everest.Formatters.XML.ITS1.Its1FormatterParseResult"/> containing the results of the parse</returns>
            <remarks>
            <para>This method differs from the <seealso cref="F:Parse(System.Xml.XmlReader)"/> method in that it
            will only look within the specified assembly for a suitable class to populate.</para>
            <para>
            This method will not check the current learned type repository for a class to serialize (ie: it will always 
            check the assembly regardless of what has been formatted prior)
            </para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.BuildCache(System.Type[])">
            <summary>
            Builds a type cache for the specified list of types
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.GetAdjustedFormatter(System.String)">
            <summary>
            Get formatter from xsi type
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.WriteElementUtil(System.Xml.XmlWriter,System.String,System.String,MARC.Everest.Interfaces.IGraphable,System.Type,MARC.Everest.Interfaces.IGraphable,MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterGraphResult)">
            <summary>
            Utility function for helper formatters
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.WriteNullFlavorUtil(System.Xml.XmlWriter,MARC.Everest.Interfaces.IGraphable)">
            <summary>
            Write the nullflavor
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.AddFormatterAssembly(System.Reflection.Assembly)" -->
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.AddRootNameMaps(System.Type[])">
            <summary>
            Adds a cached formatter assembly to this type
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.ParseElementContent(System.Xml.XmlReader,System.Object,System.String,System.Int32,System.Type,MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterParseResult)">
            <summary>
            Parse elements from the specified type
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.ParseObject(System.Xml.XmlReader,System.Type,System.Type,MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterParseResult)">
            <summary>
            Parse the object
            </summary>
            <param name="r">The reader to read from</param>
            <param name="useType">The type to use to parse</param>
            <param name="interactionContext">The current interaction being parsed</param>
            <returns>The parsed object</returns>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.GetFormatter(System.Type)">
            <summary>
            Gets a formatter that is appropriate for the specified type
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.ParseXSITypeName(System.String)">
            <summary>
            Parse XSI type name
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.ParseXSITypeName(System.String,System.Xml.IXmlNamespaceResolver)">
            <summary>
            Parse an xsi:type name
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.CreateXSITypeName(System.Type)">
            <summary>
            Creates an XSI:TYPE attribute that is friendly for RMIM structures
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.CreateXSITypeName(System.Type,System.Type,System.Xml.IXmlNamespaceResolver)">
            <summary>
            Creates an XSI:TYPE attribute that is friendly for RMIM structures
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.GraphObject(System.Xml.XmlWriter,MARC.Everest.Interfaces.IGraphable,System.Type,MARC.Everest.Interfaces.IGraphable,MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterGraphResult)">
            <summary>
            Graph object onto xml writer
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.ValidateHelper(System.Xml.XmlWriter,MARC.Everest.Interfaces.IGraphable,MARC.Everest.Formatters.XML.ITS1.ITypeFormatter,MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterGraphResult)">
            <summary>
            Validation helper
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.GetModelName(System.Type)">
            <summary>
            Gets structure name
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.GetStructureName(System.Type)">
            <summary>
            Gets structure name
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.ThrowIfDisposed">
            <summary>
            Throw an exception if the object is disposed
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.Dispose">
            <summary>
            Dispose this object
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.CorrectInstance(System.Object)">
            <summary>
            Gives the formatter a chance to correct the instance based on new knowledge gained by the formatter, should return an instance of the same type
            </summary>
        </member>
        <member name="P:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.CreateRequiredElements">
             <summary>
             Gets or sets a value that indicates whether the formatter should
             format all required elements with nullFlavor of NI
             </summary>
             <example>
             <code lang="cs" title="Generating Required Elements Setting">
             <![CDATA[
            XmlWriter xw = null;
            
            try
            {
            
                // Setup the formatter
                var its1Formatter = new XmlIts1Formatter()
                {
                    CreateRequiredElements = true
                };
                its1Formatter.GraphAides.Add(new DatatypeFormatter());
            
                // Initialize the XmlWriter & State writer
                xw = XmlWriter.Create("mydata.xml", new XmlWriterSettings() 
            { Indent = true });
             
                // State writer should always be used
                XmlStateWriter xsw = new XmlStateWriter(xw);
            
                // Create an instance
                REPC_IN000076CA instance = new REPC_IN000076CA(
                    Guid.NewGuid(),
                    DateTime.Now,
                    ResponseMode.Immediate,
                    REPC_IN000076CA.GetInteractionId(),
                    REPC_IN000076CA.GetProfileId(),
                    ProcessingID.Production,
                    AcknowledgementCondition.Always,
                    null,
                    null);
                instance.controlActEvent = new MARC.Everest.RMIM.CA.R020402.MCAI_MT700210CA.ControlActEvent<MARC.Everest.RMIM.CA.R020402.REPC_MT220001CA.Document>();
            
                // Format
                var result = its1Formatter.Graph(xsw, instance);
            
                // Flush the xml state writer
                xsw.Flush();
            
            }
            finally
            {
                if (xw != null)
                    xw.Close();
            }
             ]]>
             </code>
             <code lang="xml" title="Sample with CreateRequiredElements = false">
             <![CDATA[
            <REPC_IN000076CA ITSVersion="XML_1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:hl7-org:v3">
              <id root="54CC5226-2875-4573-BCFC-114737D89438" />
              <creationTime value="20111220222435.974-0500" />
              <responseModeCode code="I" />
              <versionCode code="V3-2008N" />
              <interactionId root="2.16.840.1.113883.1.18" extension="REPC_IN000076CA" />
              <profileId root="2.16.840.1.113883.2.20.2" extension="R02.04.02" />
              <processingCode code="P" />
              <processingModeCode code="T" />
              <acceptAckCode code="AL" />
              <controlActEvent classCode="CACT" moodCode="EVN">
                <statusCode code="completed" />
              </controlActEvent>
            </REPC_IN000076CA>
             ]]>
             </code>
             <code lang="xml" title="Sample with CreateRequiredElements = true">
             <![CDATA[
            <REPC_IN000076CA ITSVersion="XML_1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:hl7-org:v3">
              <id root="504F61EC-A66E-43E0-ADB4-63D7B27AAE4E" />
              <creationTime value="20111220222511.788-0500" />
              <responseModeCode code="I" />
              <versionCode code="V3-2008N" />
              <interactionId root="2.16.840.1.113883.1.18" extension="REPC_IN000076CA" />
              <profileId root="2.16.840.1.113883.2.20.2" extension="R02.04.02" />
              <processingCode code="P" />
              <processingModeCode code="T" />
              <acceptAckCode code="AL" />
              <controlActEvent classCode="CACT" moodCode="EVN">
                <statusCode code="completed" />
                <effectiveTime nullFlavor="NI" />
                <reasonCode nullFlavor="NI" />
                <languageCode nullFlavor="NI" />
                <subjectOf1 xsi:nil="true" nullFlavor="NI" />
              </controlActEvent>
            </REPC_IN000076CA>
             ]]>
             </code>
             </example>
        </member>
        <member name="P:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.Settings">
             <summary>
             Gets or sets the formatting setting for this formatter instance.
             </summary>
             <example>
             <code lang="cs" title="Setting XML ITS 1.0 Formatter Settings">
             <![CDATA[
             // Create the formatter and setup the graph aides
            var formatter = new XmlIts1Formatter();
            formatter.GraphAides.Add(new DatatypeFormatter() { CompatibilityMode = DatatypeFormatterCompatibilityMode.ClinicalDocumentArchitecture });
            
             // Disable validation
            formatter.ValidateConformance = false;
            
             // Create settings
            formatter.Settings = SettingsType.UseReflectionFormat | SettingsType.AllowFlavorImposing;
             ]]>
             </code>
             </example>
        </member>
        <member name="P:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.GraphAides">
            <summary>
            Gets or sets a list of aide formatters that can be instantiated 
            to assist in the formatting of this instance.
            </summary>
        </member>
        <member name="P:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.Host">
            <summary>
            Gets or sets the host formatter of this structure formatter
            </summary>
        </member>
        <member name="P:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.HandleStructure">
            <summary>
            Returns a list of structures that this formatter can "handle"
            </summary>
        </member>
        <member name="P:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.GenerateInMemory">
            <summary>
            Sets a value that indicates whether this formatter should generate
            assemblies in memory or on disk
            </summary>
        </member>
        <member name="P:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.GeneratedAssemblies">
            <summary>
            Gets a list of assemblies that have been generated by this formatter
            </summary>
        </member>
        <member name="P:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter.ValidateConformance">
            <summary>
            Gets or sets a value that indicates whether this formatter will validate conformance
            </summary>
            <remarks>When set to true, the formatter will not produce output when
            an invalid message is encountered</remarks>
        </member>
        <member name="T:MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterGraphResult">
            <summary>
            Represents a formatting result from an ITS 1 formatter
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterGraphResult.AddResultDetail(MARC.Everest.Connectors.IResultDetail)">
            <summary>
            Add a result detail item
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterGraphResult.AddResultDetail(System.Collections.Generic.IEnumerable{MARC.Everest.Connectors.IResultDetail})">
            <summary>
            Add result details from an array
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterGraphResult.#ctor">
            <summary>
            Datatype formatter graph result
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterGraphResult.#ctor(MARC.Everest.Connectors.ResultCode,MARC.Everest.Connectors.IResultDetail[])">
            <summary>
            Datatype formatter graph result
            </summary>
        </member>
        <member name="P:MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterGraphResult.Details">
            <summary>
            Gets the details of the parse
            </summary>
        </member>
        <member name="P:MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterGraphResult.Code">
            <summary>
            Gets the result code of the formatting result
            </summary>
        </member>
        <member name="T:MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterParseResult">
            <summary>
            Formatter parse result for ITS1 structures
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterParseResult.AddResultDetail(MARC.Everest.Connectors.IResultDetail)">
            <summary>
            Add a result detail item
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterParseResult.AddResultDetail(System.Collections.Generic.IEnumerable{MARC.Everest.Connectors.IResultDetail})">
            <summary>
            Add result details from an array
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterParseResult.#ctor">
            <summary>
            Datatype formatter parse result
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterParseResult.#ctor(MARC.Everest.Connectors.ResultCode,MARC.Everest.Connectors.IResultDetail[])">
            <summary>
            Datatype formatter parse result
            </summary>
        </member>
        <member name="P:MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterParseResult.Details">
            <summary>
            Gets the details of the parse
            </summary>
        </member>
        <member name="P:MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterParseResult.Code">
            <summary>
            Gets the result code of the formatting result
            </summary>
        </member>
        <member name="T:MARC.Everest.Formatters.XML.ITS1.ITypeFormatter">
            <summary>
            Summary of DatatypeFormatter
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.ITypeFormatter.Graph(System.Xml.XmlWriter,System.Object,MARC.Everest.Interfaces.IGraphable,MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterGraphResult)">
            <summary>
            Graph object <paramref name="o"/> to stream <paramref name="s"/>
            </summary>
            <param name="s">The stream to graph to</param>
            <param name="o">The object to graph</param>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.ITypeFormatter.Parse(System.Xml.XmlReader,System.Type,System.Type,MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterParseResult)">
            <summary>
            Parse object from <paramref name="s"/>
            </summary>
            <param name="s">The stream to parse from</param>
            <returns>The parsed object</returns>
            <param name="currentInteractionType">The current interaction that is being rendered. This is used for interaction cases of traversal names</param>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.ITypeFormatter.Validate(MARC.Everest.Interfaces.IGraphable,System.String)">
            <summary>
            Validate all mandatory elements are populated
            </summary>
            <param name="o">The object to check</param>
            <returns>True if the object is valid, false otherwise</returns>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.ITypeFormatter.ParseElementContent(System.Xml.XmlReader,System.Object,System.String,System.Int32,System.Type,MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterParseResult)">
            <summary>
            Parse element content from the current position
            </summary>
            <remarks>This method is used to process the elements from the current position into the specified instance</remarks>
        </member>
        <member name="P:MARC.Everest.Formatters.XML.ITS1.ITypeFormatter.Host">
            <summary>
            The host of the formatter
            </summary>
        </member>
        <member name="P:MARC.Everest.Formatters.XML.ITS1.ITypeFormatter.HandlesType">
            <summary>
            The type this formatter handles
            </summary>
        </member>
        <member name="T:MARC.Everest.Formatters.XML.ITS1.Reflector.ReflectFormatter">
            <summary>
            Handles reflection method of formatting
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.Reflector.ReflectFormatter.Graph(System.Xml.XmlWriter,System.Object,MARC.Everest.Interfaces.IGraphable,MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterGraphResult)">
            <summary>
            Graphs an object to the specified stream
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.Reflector.ReflectFormatter.GetBuildProperties(System.Type)">
            <summary>
            Get build properties
            </summary>
            <remarks>
            This ensures that the properties in the <paramref name="instanceType"/> 
            </remarks>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.Reflector.ReflectFormatter.IsTraversable(System.Reflection.PropertyInfo)">
            <summary>
            Returns true if the property is traversable
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.Reflector.ReflectFormatter.IsNonStructural(System.Reflection.PropertyInfo)">
            <summary>
            Returns true if the property is traversable
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.Reflector.ReflectFormatter.Parse(System.Xml.XmlReader,System.Type,System.Type,MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterParseResult)">
            <summary>
            Parses an instance of the specified type from the specified stream
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.Reflector.ReflectFormatter.Validate(MARC.Everest.Interfaces.IGraphable,System.String)">
            <summary>
            Validates the specified object
            </summary>
        </member>
        <member name="M:MARC.Everest.Formatters.XML.ITS1.Reflector.ReflectFormatter.ParseElementContent(System.Xml.XmlReader,System.Object,System.String,System.Int32,System.Type,MARC.Everest.Formatters.XML.ITS1.XmlIts1FormatterParseResult)">
            <summary>
            Parse element contents
            </summary>
        </member>
        <member name="P:MARC.Everest.Formatters.XML.ITS1.Reflector.ReflectFormatter.Host">
            <summary>
            Gets or sets the host of the formatter
            </summary>
        </member>
        <member name="P:MARC.Everest.Formatters.XML.ITS1.Reflector.ReflectFormatter.HandlesType">
            <summary>
            Gets the type that this formatter handles
            </summary>
        </member>
        <member name="T:MARC.Everest.Formatters.XML.ITS1.SettingsType">
            <summary>
            Types of settings on the type formatter
            </summary>
        </member>
        <member name="F:MARC.Everest.Formatters.XML.ITS1.SettingsType.AllowFlavorImposing">
            <summary>
            Permits RMIM based classes to impose a Flavor on rendered datatypes
            </summary>
        </member>
        <member name="F:MARC.Everest.Formatters.XML.ITS1.SettingsType.AllowSupplierDomainImposing">
            <summary>
            Permits RMIM based classes to impose a default SupplierDomain on rendered datatypes
            </summary>
        </member>
        <member name="F:MARC.Everest.Formatters.XML.ITS1.SettingsType.AllowUpdateModeImposing">
            <summary>
            Permits RMIM based classes to impose a default UpdateMode on rendered datatypes
            </summary>
        </member>
        <member name="F:MARC.Everest.Formatters.XML.ITS1.SettingsType.SuppressXsiNil">
            <summary>
            When set prevents the formatter from emitting xsi:nil
            </summary>
        </member>
        <member name="F:MARC.Everest.Formatters.XML.ITS1.SettingsType.SuppressNullEnforcement">
            <summary>
            When set; does not enforce strict NullFlavor rules
            </summary>
        </member>
        <member name="F:MARC.Everest.Formatters.XML.ITS1.SettingsType.AlwaysCheckForOverrides">
            <summary>
            When set the formatter will always check for overridden classes
            </summary>
        </member>
        <member name="F:MARC.Everest.Formatters.XML.ITS1.SettingsType.UseReflectionFormat">
            <summary>
            Signals that the formatter should use the reflection method of formatting
            rather than code-dom
            </summary>
        </member>
        <member name="F:MARC.Everest.Formatters.XML.ITS1.SettingsType.UseGeneratorFormat">
            <summary>
            Signals that the formatter should use the generator (creating of code in memory)
            method of formatting
            </summary>
        </member>
        <member name="F:MARC.Everest.Formatters.XML.ITS1.SettingsType.EnableDeepLearning">
            <summary>
            Optimizes the formatter for long running applications where first serialization of 
            messages is not an issue
            </summary>
        </member>
        <member name="F:MARC.Everest.Formatters.XML.ITS1.SettingsType.DefaultUniprocessor">
            <summary>
            The default settings for a uniprocessor machine
            </summary>
            <remarks>
            Sets AllowFlavorImposing, AllowUpdateModeImposing, AllowSupplierDomainImposing, and UseReflectionFormat
            </remarks>
        </member>
        <member name="F:MARC.Everest.Formatters.XML.ITS1.SettingsType.DefaultMultiprocessor">
            <summary>
            The default settings for a multi processor machine
            </summary>
            <remarks>
            Sets all options from DefaultUniprocessor plus UseGeneratorFormat
            </remarks>
        </member>
        <member name="F:MARC.Everest.Formatters.XML.ITS1.SettingsType.DefaultLegacy">
            <summary>
            Default settings for older versions of everest
            </summary>
        </member>
    </members>
</doc>
