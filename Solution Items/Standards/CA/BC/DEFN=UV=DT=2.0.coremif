<?xml version="1.0" encoding="UTF-8"?>
<!--
/*******************************************************************************
 * Copyright (c) 2010 Health Level Seven, Inc.
 * All rights reserved. This file and the model designs it contains 
 * are made available under terms of a proprietary license implicitly 
 * established by the terms expressed in the Bylaws of Health 
 * Level Seven, Inc. (HL7), in combination with the agreements under 
 * which individual and organizational memberships are established with HL7.
 * Links to the HL7 Bylaws may be found at http://www.hl7.org 
 *******************************************************************************/ 
				--><mif:datatypeModelLibrary xmlns:mif="urn:hl7-org:v3/mif2" xmlns:xhtml="http://www.w3.org/1999/xhtml"
                          packageKind="version"
                          name="2.0"
                          title="Data Types - Abstract Specification"
                          schemaVersion="2.1.3">
   <mif:packageLocation combinedId="DEFN=UV=DT=2.0" root="DEFN" artifact="DT" realmNamespace="UV"
                        version="2.0"/>
   <mif:header>
      <mif:contributor>
         <mif:role>Primary Contributer &amp; Co-Chair of Modelling &amp; Methodology</mif:role>
         <mif:name name="Grahame Grieve"/>
         <mif:affiliation>Kestral Computing Pty. Ltd.</mif:affiliation>
         <mif:email>mailto://grahame@kestral.com.au</mif:email>
      </mif:contributor>
      <mif:contributor>
         <mif:role>Primary Contributer</mif:role>
         <mif:name name="Gunther Schadow"/>
         <mif:affiliation>Indiana School of Medicine</mif:affiliation>
         <mif:email>mailto://gschadow@regenstrief.org</mif:email>
      </mif:contributor>
      <mif:contributor>
         <mif:role>Primary Contributer (R1)</mif:role>
         <mif:name name="Paul Biron"/>
         <mif:affiliation>Sparrow Hawk Photography</mif:affiliation>
         <mif:email>mailto://paul@sparrow-hawk.org</mif:email>
      </mif:contributor>
      <mif:contributor>
         <mif:role>Primary Contributer &amp; Co-Chair of Modelling &amp; Methodology</mif:role>
         <mif:name name="Lloyd McKenzie"/>
         <mif:affiliation>Lloyd Mackenzie and Associates</mif:affiliation>
         <mif:email>mailto://lloyd@lmckenzie.com</mif:email>
      </mif:contributor>
      <mif:contributor>
         <mif:role>Co-Chair of Modelling &amp; Methodology</mif:role>
         <mif:name name="George (Woody) Beeler"/>
         <mif:affiliation>Beeler Consulting LLC</mif:affiliation>
         <mif:email>mailto://woody@beelers.com</mif:email>
      </mif:contributor>
      <mif:contributor>
         <mif:role>Co-Chair of Modelling &amp; Methodology</mif:role>
         <mif:name name="Dale Nelson"/>
         <mif:affiliation>II4SM</mif:affiliation>
         <mif:email>mailto://dale@zed-logic.com</mif:email>
      </mif:contributor>
      <mif:contributor>
         <mif:role>Co-Chair of Modelling &amp; Methodology</mif:role>
         <mif:name name="Craig Parker"/>
         <mif:affiliation>Arizona State University</mif:affiliation>
         <mif:email>mailto://craigparkermd@gmail.com</mif:email>
      </mif:contributor>
      <mif:contributor>
         <mif:role>Co-Chair of Modelling &amp; Methodology</mif:role>
         <mif:name name="Ioana Singureanu"/>
         <mif:affiliation>Eversolve, LLC</mif:affiliation>
         <mif:email>mailto://ioana.singureanu@gmail.com</mif:email>
      </mif:contributor>
      <mif:approvalInfo approvalStatus="Membership Ballot - Normative" ballotOccurrence="4"/>
   </mif:header>
   <mif:importedVocabularyModelPackage combinedId="DEFN=UV=VO" root="DEFN" realmNamespace="UV" artifact="VO"/>
   <mif:datatype name="ANY" title="DataValue" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An abstract type that defines the basic properties common to all data values defined in this specification. 
					Data Value is an abstract type, meaning that no proper value
					can be just a data value without belonging to any concrete type. Every concrete
					type is a specialization of this general abstract DataValue type.
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
abstract type DataValue alias ANY {
   TYPE  dataType;
   CS    nullFlavor;
   BN    nonNull;
   BN    isNull;
   BL    notApplicable;
   BL    unknown;
   BL    other;
   BL    equal(ANY x);
   protected  BN    identical(ANY x);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="TYPE" title="DataType" datatypeKind="Definition" visibility="private">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					The data type of a data element or property.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>					
					This property is a meta-type declared in order to allow the formal definitions to make
					invariants about the data type of a value. Any data type defined in this
					specification is a value of the type DataType.
				</xhtml:p>
                  <xhtml:p>
					Note that the type of a flavor is always the underlying type. For instance, the type of a 
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="ED.IMAGE"/>
                     </xhtml:object> is always <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="ED"/>
                     </xhtml:object>. The kind of flavor will be 
					identified in the flavorId property. See <xhtml:a href="#RepresentationalProperties"/> for
					further information.					
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
private type DataType alias TYPE specializes ANY {
   ST  shortName;
   ST  longName;
   BL  implies(TYPE that);
   BL  isComparableTo(TYPE that);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="BL" title="Boolean" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A binary value for use in boolean logic. A <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object>
					value can be either <xhtml:b>true</xhtml:b> or <xhtml:b>false</xhtml:b>, or, as
					any other value, MAY be NULL.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					With any data value potentially being NULL, the two-valued logic is
					effectively extended to a three-valued logic as shown in the following
					truth tables:
				</xhtml:p>
                  <xhtml:div title="Truth tables for Boolean logic with NULL values">Truth Table: NOTNOT truefalsefalsetrueNULLNULLTruth Table: ANDANDtruefalseNULLtruetruefalseNULLfalsefalsefalsefalseNULLNULLfalseNULLTruth Table: ORORtruefalseNULLtruetruetruetruefalsetruefalseNULLNULLtrueNULLNULL</xhtml:div>
                  <xhtml:p>
					Where a boolean operation is performed upon 2 data types with different
					nullFlavors, the nullFlavor of the result SHALL be any common ancestor
					of the 2 different nullFlavors. The result SHOULD be the first common ancestor.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type Boolean alias BL specializes ANY
   values(true, false) {
            BL  not;
            BL  and(BL x);
            BL  or(BL x);
            BL  xor(BL x);
            BL  implies(BL x);
   literal  ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:enumerationValue>true</mif:enumerationValue>
      <mif:enumerationValue>false</mif:enumerationValue>
   </mif:datatype>
   <mif:datatype name="COLL" title="Collection" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A collection of values which can be enumerated using an iterator.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is introduced to represent the concept of an enumerable collection.
					Collections that are enumerable are inherently countable, though some collections
					may have an infinite number of items in the collection.
				</xhtml:p>
                  <xhtml:p>
					RIM attributes with a collection type MAY be assigned a cardinality by the constraining
					model. In these cases, the cardinality is understood to refer to the number of items 
					in the collection. To require that a collection have at least one item, the minimum 
					multiplicity of the attribute must be constrained to 1 or more
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
abstract type Collection&lt;T&gt; alias COLL&lt;T&gt; specializes ANY {
  BL      isEmpty;
  BL      notEmpty;
  INT     count;
  BL      contains(T item);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="BAG" title="Bag" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="COLL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An unordered collection of values, where any value can occur
					more than once.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					A bag MAY contain NULL values as items.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type Bag&lt;T&gt; alias BAG&lt;T&gt; specializes COLL&lt;T&gt; {
              INT     count(T item);
              BAG&lt;T&gt;  plus(BAG&lt;T&gt; x);
              BAG&lt;T&gt;  minus(BAG&lt;T&gt; x);
   literal    ST.SIMPLE;
   promotion  BAG&lt;T&gt;  (T x);
   promotion  BAG&lt;T&gt;  (DSET&lt;T&gt; x);
};</mif:data>
            </mif:otherAnnotation>
            <mif:otherAnnotation type="ITS-Note">
               <mif:text>
                  <xhtml:p>
						A <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> can be represented in two ways: either as a simple enumeration
						of elements, including repeated elements, or as a "compressed bag"
						whereby the content of the <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is listed in pairs of element value and
						count. A histogram showing absolute frequencies is a <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> represented
						in compressed form. <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is therefore useful to communicate raw
						statistical data samples.
						</xhtml:p>
               </mif:text>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="LIST" title="Sequence" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="COLL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An ordered collection of discrete (but not necessarily distinct) values.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					A sequence MAY contain NULL values as items.
				</xhtml:p>
                  <xhtml:p>
					The sequence is an ordered collection of values, but no particular
					order is associated with the sequence in the definition of <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>.
					The meaning of the order of the items SHALL be defined where a 
					<xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is used. Note that in some cases, the order is fixed ( 
					e.g. <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="HIST"/>
                     </xhtml:object>), but in other cases, the order
					is not fixed: only the meaning associated with the order in the instance
					is defined (e.g. <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="EN"/>
                     </xhtml:object>, <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="AD"/>
                     </xhtml:object>).
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type Sequence&lt;T&gt; alias LIST&lt;T&gt; specializes COLL&lt;T&gt; {
             T        head;
             LIST&lt;T&gt;  tail;
             T        item(INT index);
             INT      length;
             LIST&lt;T&gt;  subList(INT start, INT end);
             LIST&lt;T&gt;  subList(INT start);
  literal    ST.SIMPLE;
  promotion  LIST&lt;T&gt;  (T x);
  demotion   BAG&lt;T&gt;;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="SET" title="Set" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A value that contains distinct values in no particular order.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					A set SHALL NOT contain items that the comparator does not differentiate. When the default 
					equals based comparator applies, a set SHALL NOT contain NULL values as items.
				</xhtml:p>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is an abstract type. There are two specializations of <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> that are actually used 
					in models and instances, <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="DSET"/>
                     </xhtml:object> (Discrete Sets) and 
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSET"/>
                     </xhtml:object> (Quantity Sets). <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="DSET"/>
                     </xhtml:object>
					is for collection based sets that are composed of a series of discrete elements, and corresponds
					to general computationally friendly list found in most implementation environments. <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSET"/>
                     </xhtml:object>
					is for quantity based sets where it makes sense to build complex sets using expressions and ranges of values. <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSET"/>
                     </xhtml:object>s
					correspond to the mathematical notion of a set. Both types of sets support the common operations defined
					in <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> that relate to the notion of set membership and related operations. <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="DSET"/>
                     </xhtml:object>
					extends this notion to include some collection specific operations. <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSET"/>
                     </xhtml:object> extends the
					notion to support a number of different methods for specifying set ranges and building complex sets
					based on set operations which are not possible for non-quantity based sets.
				</xhtml:p>
                  <xhtml:p>
					There are some complex relationships between <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="DSET"/>
                     </xhtml:object> and <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSET"/>
                     </xhtml:object>. For example, 
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="IVL"/>
                     </xhtml:object>&lt;<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="INT"/>
                     </xhtml:object>&gt;
					is a type that conforms to the semantics expressed in both a <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="DSET"/>
                     </xhtml:object> and a <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSET"/>
                     </xhtml:object>, though for
					purposes of definition, this specification defines an <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="IVL"/>
                     </xhtml:object> as a specialization of <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSET"/>
                     </xhtml:object>
					and not <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="DSET"/>
                     </xhtml:object>, since all types of <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="IVL"/>
                     </xhtml:object>s are also <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSET"/>
                     </xhtml:object>s. 
					The situation for <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TS"/>
                     </xhtml:object> is a little more complicated. <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="IVL"/>
                     </xhtml:object>&lt;<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TS"/>
                     </xhtml:object>&gt;
					is not a <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="DSET"/>
                     </xhtml:object>&lt;<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TS"/>
                     </xhtml:object>&gt;, but a <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="DSET"/>
                     </xhtml:object>&lt;<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TS"/>
                     </xhtml:object>&gt; may make sense in 
					some circumstances, and if a <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="DSET"/>
                     </xhtml:object>&lt;<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TS"/>
                     </xhtml:object>&gt; is defined, it also conforms to
					the semantics expressed in <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSET"/>
                     </xhtml:object>&lt;<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TS"/>
                     </xhtml:object>&gt;. 
					A <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="DSET"/>
                     </xhtml:object>&lt;<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PQ"/>
                     </xhtml:object>&gt; may also be a <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSET"/>
                     </xhtml:object>&lt;<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PQ"/>
                     </xhtml:object>&gt; but
					only if all the values are comparable (this relationship is true for all
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="DSET"/>
                     </xhtml:object>&lt;<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QTY"/>
                     </xhtml:object>&gt;). 
				</xhtml:p>
                  <xhtml:p>	
					Generally, if T is a specialization of <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QTY"/>
                     </xhtml:object>, then a <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSET"/>
                     </xhtml:object>
					would be the appropriate type of <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="SET"/>
                     </xhtml:object> to specify in a model or use in an instance. 
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T, COMP C = CEQ&gt;
abstract type Set&lt;T, C&lt;T&gt;&gt; alias SET&lt;T, C&lt;T&gt;&gt; specializes ANY {
   C&lt;T&gt;    comparator;
   BL      contains(T element);
   BL      contains(SET&lt;T&gt; subset);
   BL      isEmpty;
   BL      notEmpty;
   INT     cardinality;
   SET&lt;T&gt;  union(SET&lt;T&gt; otherset);
   SET&lt;T&gt;  union(T element);
   SET&lt;T&gt;  except(SET&lt;T&gt; otherset);
   SET&lt;T&gt;  except(T element);
   SET&lt;T&gt;  intersection(SET&lt;T&gt; otherset);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:parameter name="C" sortKey="2">
         <mif:type name="COMP"/>
         <mif:defaultValue name="CEQ"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="COMP" title="Comparator" isAbstract="true" datatypeKind="Definition"
                 visibility="protected">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An abstract type that defines a comparison between two values of the same type.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					Although every type has a clear definition of the meaning of semantic equality, this
					definition does not always fit a particular use: in these cases, a specialization of
					<xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> that expresses the criteria for the comparison relationship may be used.
					The comparator type is defined to allow custom definitions of the meaning of equality
					between types. This is most useful in defining the criteria for uniqueness in a
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="SET"/>
                     </xhtml:object> but may find other applications in implementation environments.
				</xhtml:p>
                  <xhtml:p>
				  COMP is an abstract type, and no actual comparator is defined.
				</xhtml:p>
                  <xhtml:p>
					Because <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> never appears in the instance, new specializations of <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>
					MAY be defined outside of this specification. All new specializations SHALL
					be approved at harmonisation prior to being included in a normative specification.
				</xhtml:p>
                  <xhtml:p>
					An example of a custom comparator might be to specify that a particular <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="SET"/>
                     </xhtml:object>
					of <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TEL"/>
                     </xhtml:object> is allowed to contain the same telecommunication address more than once if
					it has different useablePeriod properties. In this case, compare should return false if only
					one of the two <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TEL"/>
                     </xhtml:object>s has a useablePeriod, or if they both do and they are
					different. Here is how to define such a comparator:
				</xhtml:p>
                  <xhtml:p>
					A set that used this comparator would be defined as 
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="DSET"/>
                     </xhtml:object>&lt;<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TEL"/>
                     </xhtml:object>, MYTELCOMP&gt;.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
abstract protected type Comparator&lt;T&gt; alias COMP&lt;T&gt; {
   TYPE  dataType;
    BL      compare(T element1, T element2);
};</mif:data>
            </mif:otherAnnotation>
            <mif:otherAnnotation type="ITS-Note">
               <mif:text>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> and its descendants never appear in an instance, and an ITS should not
						create a representation for them.
					</xhtml:p>
               </mif:text>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
type MyTelephoneComparator alias MYTELCOMP specializes COMP&lt;TEL&gt;{
    BL      compare(T element1, T element2);
};

invariant(MYTELCOMP c, TEL x, y)
      where x.equal(y).nonNull {
   c.compare(x, y).equal(
     x.equal(y)
      .and(x.useablePeriod.isNull.xor(y.useablePeriod.isNull)).not
	  .or(x.useablePeriod.nonNull.implies(
	     x.useablePeriod.equals(y.useablePeriod))));
};
</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="CEQ" title="EqualComparator" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="COMP"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A comparator based on the equality relationship defined for all types.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					This is the default concrete comparator that compares the two values based on the 
					equality relationship defined for all types.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type EqualComparator&lt;T&gt; alias CEQ&lt;T&gt; specializes COMP&lt;T&gt; {
    BL      compare(T element1, T element2);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="DSET" title="DiscreteSet" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SET"/>
      </mif:derivedFrom>
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="COLL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An unordered collection of values that contains discrete distinct values.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					A <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> differs from the general <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="SET"/>
                     </xhtml:object> because it is constrained to
					contain only discrete items. The practical consequence of this is that a <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> can
					be iterated, like bag, but unlike <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSET"/>
                     </xhtml:object>.  
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T, COMP C = CEQ&gt;
type DiscreteSet&lt;T, C&lt;T&gt;&gt; alias DSET&lt;T, C&lt;T&gt;&gt; specializes SET&lt;T, C&lt;T&gt;&gt;, COLL&lt;T&gt; {
   literal    ST.SIMPLE;
   promotion  DSET&lt;T&gt;  (T x);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:parameter name="C" sortKey="2">
         <mif:type name="COMP"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="HXIT" title="HistoryItem" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="T" qualifier="parameter"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A generic data type extension that adds a time range and/or link to the ControlAct 
					associated with the creation of the data on any data value whatever its data type. 
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
                     <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="HXIT"/>
                     </xhtml:object> adds the controlActIdRef property to the the base type T.
					In addition, if the base type T does not possess a validTime property, the
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="HXIT"/>
                     </xhtml:object> adds that property to the base type. If, however,
					the base type T does have a valid time property (currently only <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="EN"/>
                     </xhtml:object>),
					that property is mapped to the valid time property of the
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="HXIT"/>
                     </xhtml:object> and the <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> constraints on validTime apply.<xhtml:object name="footnote">.
						
							Note that data types are specifications of abstract properties of
							values. This specification does not mandate how these values are
							represented in an ITS or implemented in an application. Specifically,
							it does not mandate how the represented components are named or
							positioned. In addition, the semantic generalization hierarchy may be
							different from a class hierarchy chosen for implementation (if the
							implementation technology has inheritance).  Keep the distinction
							between a type (interface) and an implementation (concrete data
							structure, class) in mind. The ITS SHALL contain a mapping of ITS
							defined features of any data type to the semantic properties defined
							here.
						</xhtml:object>
                  </xhtml:p>
                  <xhtml:p>
					The time range is the time in which the information	represented by the value is (or was) valid.
					The ControlAct id reference indicates the event responsible for the value of the data type.
					The time range is not the time during which any particular system considered this 
					information valid (as in, an audit trail), though the link to the control act may
					provide some information of relevance in this regard.				  
				  </xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type HistoryItem&lt;T&gt; alias HXIT&lt;T&gt; specializes T {
   IVL&lt;TS&gt; validTime;
   BL comesBefore(HXIT&lt;T&gt;);
   II controlActIdRef;  
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="HIST" title="History" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="HXIT">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:argumentDatatype>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A list of data values that have a valid-time property.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					The intent of <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is to capture the true historical
					(and future) values of an item, rather than the audit trail of
					values any given system has held for the item.
					The history information is not limited to the past; expected future
					values MAY also appear.
				</xhtml:p>
                  <xhtml:p>
					All items in the list SHALL have a non-null validTime property. 
					The validTime periods on the list SHALL NOT overlap.
					The contents of <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> SHALL be ordered in ascending chronological order.
				</xhtml:p>
                  <xhtml:p>
						If a list of historical items should allow multiple items and/or overlapping
						ranges, then the type of the attribute should be <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="BAG"/>
                     </xhtml:object>&lt;<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="HXIT"/>
                     </xhtml:object>&lt;T&gt;&gt;.
						The type <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="HIST"/>
                     </xhtml:object>&lt;<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="SET"/>
                     </xhtml:object>&lt;T&gt;&gt; actually denotes a history of the set
						values themselves. The semantics of <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="SET"/>
                     </xhtml:object>&lt;<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="HXIT"/>
                     </xhtml:object>&lt;T&gt;&gt; become
						very complicated; given that validTime is usually excluded from the equality test, this type should not be used. 
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type History&lt;T&gt; alias HIST&lt;T&gt; specializes LIST&lt;HXIT&lt;T&gt;&gt; {
            HXIT&lt;T&gt;  current;
            HXIT&lt;T&gt;  earliest;
            HIST&lt;T&gt;  exceptEarliest;
            HXIT&lt;T&gt;  latest;
            HIST&lt;T&gt;  exceptLatest;
  demotion  HXIT&lt;T&gt;;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(HIST x; HXIT&lt;T&gt; e)
      where x.nonNull {
  x.contains(e).implies(e.validTime.nonNull);

  forall(INT.POSITIVE i) where i.lessThan(x.length) {
      x.item(i.predecessor).comesBefore(x.item(i));
  };
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="BIN" title="BinaryData" datatypeKind="Definition" visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="BN"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A raw block of bits. 
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is a protected type that SHALL NOT be assigned to any property outside the data type specification.
				</xhtml:p>
                  <xhtml:p>
					A bit is semantically identical with a non-null <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="BL"/>
                     </xhtml:object> value. Thus,
					all binary data is — semantically — a sequence of non-null
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="BL"/>
                     </xhtml:object> values.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type BinaryData alias BIN specializes LIST&lt;BN&gt;;</mif:data>
            </mif:otherAnnotation>
            <mif:otherAnnotation type="ITS-Note">
               <mif:text>
                  <xhtml:p>
						The representation of arbitrary binary data is the responsibility of
						an ITS. How the ITS accomplishes this depends on the underlying
						Implementation Technology (whether it is character-based or binary)
						and on the represented data. Character data MAY be
						represented as binary data; however, a character-based ITS SHOULD NOT
						convert character data into arbitrary binary data and then represent
						binary data in a character encoding.  E.g., the letter "J" might be 
						encoded as ASCII "74" (or hexadecimal "4A"): these character 
						representations of numerical data should not be represented in 
						lieu of the original "J."
					</xhtml:p>
               </mif:text>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text>
						An empty sequence is not considered binary data but counts as a
						NULL-value. In other words, non-NULL binary data contains at least one
						bit. All bits in a non-NULL binary data value SHALL NOT be NULL.
					</mif:text>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BIN x)
      where x.nonNull {
   x.notEmpty;
   x.length.greaterThan(0);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="ED" title="EncapsulatedData" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					Data that is primarily intended for human interpretation or for
					further machine processing outside the scope of HL7. 
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					This includes unformatted or formatted written language, multimedia data, or
					structured information as defined by a different standard (e.g.,
					XML-signatures).  Instead of the data, an <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>
					may contain only a reference (see <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TEL"/>
                     </xhtml:object>). Note that
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="ST"/>
                     </xhtml:object> is a specialization of 
					<xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> where the <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="mediaType"/>
                        <xhtml:param name="datatypeName" value="ED"/>
                     </xhtml:object> is fixed to text/plain 
					and several other properties are constrained to null.
				</xhtml:p>
                  <xhtml:p>   
					Encapsulated data can be present in two forms, inline or by
					reference. Inline data is communicated or moved as part of the
					encapsulated data value, whereas by-reference data may reside at a
					different (remote) location. The data is the same whether it is
					located inline or remote.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type EncapsulatedData alias ED specializes ANY {
   BIN     data;
   CS      mediaType;
   CS      charset;
   CS      language;
   CS      compression;
   TEL.URL reference;
   BIN     integrityCheck;
   CS      integrityCheckAlgorithm;
   ST      description;
   ED      thumbnail;
   DSET&lt;ED&gt; translation;

   INT     length;
   ED      subPart(INT start, INT end);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="ST" title="CharacterString" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					Text data, primarily
					intended for machine processing (e.g., sorting, querying, indexing, presentation,
					etc.). 
				</mif:text>
            </mif:definition>
            <mif:requirements>
               <mif:text>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is a specialization of <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="ED"/>
                     </xhtml:object> so that any RIM attribute which has the type
						<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="ED"/>
                     </xhtml:object> can be constrained to a <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>. The most important case is Act.text, which is
						an <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="ED"/>
                     </xhtml:object> to cater for the use of references and multimedia data, but is often
						constrained to plain text.
					</xhtml:p>
               </mif:text>
            </mif:requirements>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
                     <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="ST"/>
                     </xhtml:object> is primarily used for names, symbols, and formal expressions.
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="ST"/>
                     </xhtml:object> is a restricted <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="ED"/>
                     </xhtml:object>,
					whose <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="mediaType"/>
                        <xhtml:param name="datatypeName" value="ED"/>
                     </xhtml:object> property is fixed to <xhtml:b>text/plain</xhtml:b>,
					and whose data SHALL be inlined and not compressed. Thus, the properties compression, reference,
					integrity check, algorithm, and thumbnail are not applicable. The character
					string data type is used when the visual presentation of text does not affect its meaning,
					which is true for formalized text and all kinds of names.
				</xhtml:p>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> data type interprets the encapsulated data
					as character data (as opposed to bits), depending on the charset
					property of the encapsulated data type.
				</xhtml:p>
                  <xhtml:p>
					The headCharacter and tailString properties define <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> as a sequence
					of entities each of which uniquely identifies one character from the
					joint set of all characters known by any language of the world.<xhtml:object name="footnote">
							ISO/IEC 10646-1: 1993 defines a character as "A member of a set of
							elements used for the organization, control, or representation of
							data."  ISO/IEC TR 15285 - An operational model for characters and
							glyphs. Discusses the problems involved in defining
							characters. Notably, characters are abstract entities of information,
							independent of type font or language. The ISO 10646 (UNICODE
							[http://www.unicode.org]) - or in Japan, JIS X0221 - is a globally
							applicable character set that uniquely identifies all characters of
							any language in the world.
						
							In this specification, ISO 10646 serves as a semantic model for
							character strings. The important point is that for semantic purposes,
							there is no notion of separate character sets and switching between
							character sets. Character set and character encoding are ITS layer
							considerations. The formal definition gives indication to this effect
							because each character is by itself an  value that
							has a charset property. Thus, the binary encoding of each character is
							always understood in the context of a certain character set. This does
							not mean that the ITS should represent a character string as a
							sequence of full blown  values. What it means is that
							on the application layer the notion of character encoding is
							irrelevant when we deal with character strings.
						</xhtml:object>
                  </xhtml:p>
                  <xhtml:p>
					The length of an <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is the number of characters, not the number of
					encoded bytes, in the string. Byte encoding is an ITS issue and is not relevant on
					the application layer.
				</xhtml:p>
                  <xhtml:p>
					The following rules apply to whitespace contained within values of type <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>:
				</xhtml:p>
                  <xhtml:ul>
                     <xhtml:li/>
                     <xhtml:li/>
                     <xhtml:li/>
                     <xhtml:li>
                        <xhtml:a href="http://www.w3.org/TR/2000/REC-xml-20001006#sec-line-ends"/>
                     </xhtml:li>
                     <xhtml:li/>
                  </xhtml:ul>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type CharacterString alias ST specializes ED {
   ST.NT     headCharacter;
   ST.NT     tailString;
   DSET&lt;ST.NT&gt; translation;
   literal  ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
            <mif:otherAnnotation type="ITS-Note">
               <mif:text>
                  <xhtml:p>
						Because many of the properties of the encapsulated data are bound to a
						default value, an ITS need not represent these properties at all. In
						fact, if the character encoding is also fixed, the ITS only represents
						the encoded character data and language.
					</xhtml:p>
               </mif:text>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text>
					The head of an <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> is a string of only one character. An <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object>
					SHALL have at least one character or else be NULL. A
					zero-length <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> is an exceptional value (NULL), not a proper
					value.
				</mif:text>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.headCharacter.notEmpty;
   x.headCharacter.length.equal(1);
   x.headCharacter.tailString.isEmpty;
   x.tailString.isEmpty.implies(x.length.equal(1));
   x.tailString.notEmpty.implies(x.length.equal(x.tailString.length.successor));
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="SC" title="CharacterStringWithCode" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ST"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A character string that optionally may have a code attached.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					The text SHALL always be present if a code is present.  The code is often a
					local code.
				</xhtml:p>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is used in cases where coding is exceptional (e.g.,
					user text messages are essentially text messages, and a printable
					message is the important content. Yet sometimes messages come from a
					catalog of canned messages, which <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> allows to reference.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type CharacterStringWithCode alias SC specializes ST {
   CV code;
   
  promotion  SC (ST x);
   
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text>
						Any non-null <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> value MAY have a code, however, a code SHALL NOT be
						given without the text.
					</mif:text>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SC x)
      where x.nonNull {
   x.code.nonNull.implies(x.notEmpty);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
            <mif:formalConstraint>
               <mif:text>
						The original text of the code, if provided, is the content of the string.<xhtml:object name="footnote">Implementations will generally not have duplication between the content of the SC and the originalText of the code property.</xhtml:object>
               </mif:text>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SC x)
      where x.nonNull {
   x.code.nonNull.implies(x.code.originalText.equals(x));
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="CD" title="ConceptDescriptor" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A reference to a concept defined in a code system
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					A <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> may contain a simple code - that is, a reference to a
					concept defined directly by the referenced code system, or it may
					contain an expression in some syntax defined by the referenced
					code system that can be meaningfully evaluated. e.g., the
					concept of a "left foot" as a postcoordinated term built from the
					primary code "FOOT" and the qualifier "LEFT".
				</xhtml:p>
                  <xhtml:p>
					A <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> may also contain an original text or phrase that
					served as the basis of the coding. This is preserved to allow for validation of the representation
					of the concept in various fashions. 
				</xhtml:p>
                  <xhtml:p>
					A <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> can contain one or more translations into multiple coding systems.
					The translations are all representations of the same concept in various
					code systems (note that there may be more than on representation in a single 
					code system where code systems allow multiple representations, such as Snomed-CT). 
					There is only one concept, and only the first <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> may
					contain an original text. It is possible to represent the translation
					chain - which <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> was translated from which - if desired, using 
					the source attribute. Each <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> may also carry a rationale to indicate why it is represented.
				</xhtml:p>
                  <xhtml:p>
					Attributes with type <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> are generally bound to a domain that is used to constrain
					the coded concepts to which a <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> may refer. Domains are bound to value sets that 
					define the codes and code systems that may be used in the <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>. The binding process is discussed
					in depth in the "Core Principles of V3 Models" specification under "Vocabulary Binding" 
					([<xhtml:a href="../coreprinciples/coreprinciples.htm#coreP_V3_Conformance-Vocabulary-Binding"/>]). 
					Domains are bound with a qualifier that specifies with the
					domains are extensible or not. If a domain is not extensible (CNE), then 
					a non-exceptional root <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> SHALL contain a code that exists in the domain with
					which the attribute is associated<xhtml:object name="footnote">
					 	There is no formal definition for this extra constraint as there is no machinery
					 	for the formal language to refer to externally specified constraints.
					</xhtml:object>. If a domain is extensible (CWE) then 
					a non-exceptional <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> SHALL contain a code that exists in the domain with
					which the attribute is associated, a code from a locally defined code system,
					or some originalText that describes the concept. If the code is taken from a 
					locally defined code system, then the <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="codeSystem"/>
                        <xhtml:param name="datatypeName" value="CD"/>
                     </xhtml:object>
					property SHALL specify the local code system.
				</xhtml:p>
                  <xhtml:p>
					For both CNE and CWE domain bindings, the translations may contain nonNull codes
					from any domain unless otherwise specified by the constraining model. 
				</xhtml:p>
                  <xhtml:div title="CD Examples">CDexamples
					    A simple example for code is the ICD-9 code for headache, which is "784.0". 
					
&lt;example code="784.0" codeSystem="2.16.840.1.113883.6.42" codeSystemName="ICD-9"&gt;
	&lt;displayName value="Headache"/&gt;
	&lt;originalText value="general headache"/&gt;
&lt;/example&gt;
					    A possible ICD-10 equivalent is "G44.1" (the ICD-10 classifications are slightly different). 
					
&lt;example code="G44.1" codeSystem="2.16.840.1.113883.6.3" codeSystemName="ICD-10"&gt;
	&lt;displayName value="Headache"/&gt;
	&lt;originalText value="general headache"/&gt;
&lt;/example&gt;Coding Failure Examples
							A common situation with  is when the actual concept cannot be 
							properly represented in a particular coding system. Usually this circumstance
							arises where the concept is expected to be represented in a particular coding
							system. For the purposes of these examples, we assume that all these example
							values are for an observation value of type  that is found in the full Snomed-CT valueset
							(Example OID for the value set = 2.16.840.1.113883.19.11.1 as published 11-June 2007, Real OID for the SNOMED-CT code system = 2.16.840.1.113883.6.96).
							Important Note: The OID root 2.16.840.1.113883.19 is used for example-only OIDs, and OIDs in 
							this space are never valid in real instances. The OIDs used in these examples that in the OID space
							2.16.840.1.113883.6, 2.16.840.1.113883.5 and 2.16.840.1.113883.11 are the correct OIDs to use in
							production instances.  
						
							The simplest case is where the  is not represented in the instance 
							at all, or simply represented as no information.
						
&lt;value nullFlavor="NI"/&gt;
							However this isn't a very useful representation - frequently the source system
							knows more information, and it is still useful to convey that information to 
							the destination system, while still labelling the coding as incomplete.
						
&lt;value nullFlavor="OTH" codeSystem="2.16.840.1.113883.6.96"/&gt;
							or it may be encoded as 
						
&lt;value nullFlavor="OTH" valueSet="2.16.840.1.113883.19.11.1" valueSetVersion="20070711"/&gt;
							Both examples say that the concept cannot be coded in SNOMED. Even more useful
							is to convey some specific information about the concept, even though it cannot
							be represented in SNOMED:
						
&lt;value nullFlavor="OTH" codeSystem="2.16.840.1.113883.6.96"&gt;
	&lt;originalText value="Burnt ear with iron. Burnt other ear calling for ambulance"/&gt;
&lt;/value&gt;
							It is also possible that the content was first encoded in some other 
							code system than SNOMED, and the source system was unable to encode 
							the value in SNOMED. In this case, there is two forms of representation.
							The first is when the binding to SNOMED is labelled as CWE: local 
							extensions are allowed: 
						
&lt;value code="burn" codeSystem="2.16.840.1.113883.19.5.2"&gt;
	&lt;originalText value="Burnt ear with iron. Burnt other ear calling for ambulance"/&gt;
&lt;/value&gt;
							In this case, because the binding is CWE, local extensions are allowed,
							and the source system can simply use it is own codeSystem (here identified
							by the OID "2.16.840.1.113883.19.5.2", which is an example OID) to extend
							the other code system. In fact, the source system can also use a code from
							another well known code system, such as ICD-9. If ICD-9 had a code "A10.1"
							which stood for this same concept, then this would be valid: 
						
&lt;value code="A10.1" codeSystem="2.16.840.1.113883.6.42"&gt;
	&lt;originalText value="Burnt ear with iron. Burnt other ear calling for ambulance"/&gt;
&lt;/value&gt;
							If, however, the binding to the SNOMED-CT valueset is labelled CNE, then the
							code must come from SNOMED. The same information as the case above 
							must be conveyed differently:
						
&lt;value nullFlavor="OTH" codeSystem="2.16.840.1.113883.6.96"&gt;
	&lt;originalText value="Burnt ear with iron. Burnt other ear calling for ambulance"/&gt;
    &lt;translation code="burn" codeSystem="2.16.840.1.113883.19.5.2"&gt;
&lt;/value&gt;
							Now the code is clearly marked as OTH: the code cannot be represented in
							SNOMED-CT, but a translation from another system is provided. Though it is
							pretty redundant in this case, the source system could indicate which translation
							comes from which using the source property: 
						
&lt;value nullFlavor="OTH" codeSystem="2.16.840.1.113883.6.96" source="s1"&gt;
	&lt;originalText value="Burnt ear with iron. Burnt other ear calling for ambulance"/&gt;
    &lt;translation id="s1" code="burn" codeSystem="2.16.840.1.113883.19.5.2"&gt;
&lt;/value&gt;
							All these examples have assumed that the attribute is bound to the 
							fictitious value set 2.16.840.1.113883.19.11.1 which is all of SNOMED-CT.
							If the value set was extended to include the LOINC codes as well, it would
							no longer be appropriate to encode a failure to code like this:
						
&lt;value nullFlavor="OTH" codeSystem="2.16.840.1.113883.6.96"/&gt;
							since it is not true that the concept could not be coded from SNOMED-CT - it 
							could not be coded in either SNOMED-CT or LOINC. For this reason, it is appropriate
							to encode the failure to code in the valueSet form:
						
&lt;value nullFlavor="OTH" valueSet="2.16.840.1.113883.19.11.1" valueSetVersion="20070711"/&gt;Expression examples
					    Expressions generally arise with complex medical terminologies such as SNOMED.
						For example, SNOMED CT defines a concept "cellulitis (disorder)"
						(128045006) an attribute "finding site" (363698007) and another
						concept "foot structure (body structure)" (56459004). SNOMED CT allows
						these codes to be combined in a code phrase:
					
128045006|cellulitis (disorder)|:{363698007|finding site|=56459004|foot structure|}
						The full CD form for this is:
					
&lt;value code="128045006:{363698007=56459004}" codeSystem="2.16.840.1.113883.6.42" codeSystemName="Snomed-CT"&gt;
	&lt;originalText value="Cellulitis of the foot"/&gt;
&lt;/value&gt;
						The SNOMED compositional expression language allows for the inclusion of the term
						in the expression, as shown in the first example. These make the expression more
						readable for humans, and so are used throughout this section in the standalone 
						expressions. However the terms are optional and do not improve readability for 
						computers; instead, their optional presence creates needless processing complexity, such as for testing equality. For this reason HL7 recommends that the 
						expressions in CD instances SHOULD NOT include the terms, and no CD examples include the terms 
						in the expressions in this specification. Value sets may make rules about the presence or absense of the
						terms in the expressions. 						
					
						The SNOMED compositional expression language is currently undergoing comment, 
						and may be found at 
						[].
						The next two examples are provided courtesy of David Markwell, and are
						based on SNOMED CT Core Edition 2007-01-31. 
					
						This first example is the SNOMED code for "fracture of left tibia". It shows 
						issues associated with grouping and nesting.
					
31978002|fracture of tibia|: 272741003|laterality|=7771000|left|
						Strictly speaking (in normal form) a "fracture of left tibia" is not
						a "left fracture" of a "tibia bone" but is a "fracture" of the "left"
						"tibia bone" (that is, the qualification of "left" applies to the bone
						not to the fracture). Also note in this example that the fracture and
						bone are grouped - this may look irrelevant but is potentially significant
						for combined fractures where different morphology may apply to different
						bones. An alternative rendering for this same concept is:
					
64572001|disease|:{116676008|associated morphology|=72704001|fracture|,
     363698007|finding site|=(12611008|bone structure of tibia|:272741003|laterality|=7771000|left|)}
						The second example shows a more complicated grouping and nesting structure. The SNOMED
						CT expression for "past history of fracture of left tibia" includes nesting even in
						its simplest form because the laterality does not apply to the past history but rather to
						the disorder.
					
417662000|past history of clinical finding|:246090004|associated finding|=
     (31978002|fracture of tibia|: 272741003|laterality|=7771000|left|)
						The alternative rendering is even more nested:
					
243796009|situation with explicit context|:246090004|associated finding|=
     (64572001|disease|:{116676008|associated morphology|=72704001|fracture|,
     363698007|finding site|=(12611008|bone structure of tibia|:
     272741003|laterality|=7771000|left|)}),408729009|finding context|=
     410515003|known present|,408731000|temporal context|=410513005|past|,
     408732007|subject relationship context|=410604004|subject of record|
     					These are provided as examples of SNOMED expression syntaxes. A full discussion the 
     					merits of the different forms, their relationship and how to work with them can be 
     					found in the SNOMED compositional expression language definition referred to above. 
     				
						It is important to note that the expression syntax and semantic rules are specified by
						the code system. For instance, in SNOMED CT, there are a defined set of
						qualifying attributes, and only Findings and Disorders can be
						qualified with the "finding site" attribute.  does not provide
						for normalization of compositional expressions, therefore it is
						possible to create ambiguous expressions.  Users should understand
						that they must provide the additional constraints necessary to assure
						unambiguous data representation, if they are planning to create
						compositional expressions using . Otherwise, they risk
						the inability to retrieve a complete set of all records corresponding
						to any given query.
					
						ICD-10 allows dual coding. Refer to Section 3.1.3 of the ICD-10 Instruction 
						Manual (2nd Edition, []).
						While ICD-10 clearly establishes the semantic basis for the dual coding, 
						it does not define an actual literal expression form suitable for use with
						CD. In such cases, HL7 defines a suitable literal expression form and assigns
						an OID to that. The OID for this ICD-10 expression is 2.16.840.1.113883.6.260, and specifies
						that the two ICD-10 codes are separated by a space.   
					
&lt;value code="J21.8 B95.6" codeSystem="2.16.840.1.113883.6.260" codeSystemName="ICD-10 Dual Code Expression"&gt;
	&lt;originalText value="Staph aureus bronchiolitis"/&gt;
&lt;/value&gt;
						The ICD-10 code J21.8 is "Acute bronchiolitis due to other specified organisms" and
						the code B95.6 is "Staphylococcus aureus as the cause of diseases classified to other chapters".
					</xhtml:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type ConceptDescriptor alias CD specializes ANY {
    ST.SIMPLE       code;
    UID             codeSystem;
    ST.NT           codeSystemName;
    ST.SIMPLE       codeSystemVersion;
    UID             valueSet;
    ST.SIMPLE       valueSetVersion;
    ST              displayName;
    ED.TEXT         originalText;
    SET&lt;CS&gt;         codingRationale;
    DSET&lt;CD&gt;        translation;
    CD              source;
    BL              implies(CD x);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text>
					A non-exceptional <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> value SHALL have a non-NULL <xhtml:object name="propertyRef">
                     <xhtml:param name="propertyName" value="code"/>
                     <xhtml:param name="datatypeName" value="CD"/>
                  </xhtml:object> or
					<xhtml:object name="propertyRef">
                     <xhtml:param name="propertyName" value="originalText"/>
                     <xhtml:param name="datatypeName" value="CD"/>
                  </xhtml:object> property. Conversely, a
					<xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> value without a value for both the <xhtml:object name="propertyRef">
                     <xhtml:param name="propertyName" value="code"/>
                     <xhtml:param name="datatypeName" value="CD"/>
                  </xhtml:object> and <xhtml:object name="propertyRef">
                     <xhtml:param name="propertyName" value="originalText"/>
                     <xhtml:param name="datatypeName" value="CD"/>
                  </xhtml:object> properties,
					or with a value that is not from the specified coding system is an exceptional
					value (NULL of flavor <xhtml:b>other</xhtml:b>). If the concept (the intent of the
					original text) cannot be properly represented within the set of codes to which 
					the attribute is constrained (the value set), then the nullFlavor of
					the <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> should be set to "OTH" (other) and either a reference
					to a code system or a value set (which may refer to multiple code
					systems) SHALL be provided.
				
				   Note that sending a <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> with a nullFlavor of <xhtml:b>other</xhtml:b> and a 
				   code system says that no appropriate code could be found in the entire code
				   system. If this statement can only be made about a a subset of the code system,
				   or about multiple code systems, then a value set should be used instead.     
				</mif:text>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x)
      where x.nonNull {
   x.code.nonNull.or(x.originalText.nonNull);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="CO" title="CodedOrdinal" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="CD"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					 Coded data, where the coding system from which the code comes defines a 
					 partial or complete order on some or all of the codes in the system. 
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					Codes may be assigned a numerical value, but this is not required. <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> adds semantics
					related to ordering and/or numerical values so that models that make use of such domains may
					introduce model elements that involve statements about the order of the terms in a domain.
				</xhtml:p>
                  <xhtml:p>
					The relative order of <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> values need not be independently
					obvious in their literal representation. It is expected that an
					application will look up the ordering of these values from some
					table. Some of the values will have directly assigned numerical 
					value suitable for some mathemetical operations.
				</xhtml:p>
                  <xhtml:p>
				    The translations of the code, if present, SHALL not imply a different 
				    order from that implied by the <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>. Translations MAY NOT imply any order.
					Translations SHALL not be considered when the ordering of the code
					system is determined. 
				</xhtml:p>
                  <xhtml:p>
					Although <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="value"/>
                        <xhtml:param name="datatypeName" value="CO"/>
                     </xhtml:object> has a type <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="REAL"/>
                     </xhtml:object>,
					<xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is provided to represent a series of concepts that have an 
					associated order, and sometimes a value. Likert scales are one such
					use case. <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> should not be used to model an observation or 
					physical measurement which has value along with a set of value
					interpretations, sometimes called reference ranges.  
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type CodedOrdinal alias CO specializes CD {
   REAL value;
   BL  lessOrEqual(CO o);
   BL  lessThan(CO o);
   BL  greaterThan(CO o);
   BL  greaterOrEqual(CO o);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="CS" title="CodedSimpleValue" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="CV"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					Coded data in its simplest form, where only the code is not predetermined.
					The code system and code system version are fixed by the context in which
					<xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> value occurs. <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> is used for coded attributes that have a single
					HL7-defined value set.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>
                     <xhtml:object name="footnote">
							CS is a data type rather than a flavor because as well as defining 
							a literal form, it also is associated with the introduction of
							default values to codeSystem and codeSystemVersion in an ITS.
						</xhtml:object> SHALL only be used in either of the following cases:
				</xhtml:p>
                  <xhtml:ol>
                     <xhtml:li>
                        <xhtml:object name="itemName">
                           <xhtml:param name="item" value="datatype"/>
                        </xhtml:object>
                     </xhtml:li>
                     <xhtml:li/>
                  </xhtml:ol>
                  <xhtml:p>
					For example, since <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="ED"/>
                     </xhtml:object> subscribes to the MIME
					design, it trusts IETF to manage the media type. This includes that this
					specification subscribes to the extension mechanism built into the MIME media
					type code (e.g., "application/x-myapp").
				</xhtml:p>
                  <xhtml:p>
					For <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> values, the designation of the domain qualifier
					SHALL always be CNE (<xhtml:b>coded, non-extensible</xhtml:b>) and the
					context will determine which values to use.<xhtml:object name="footnote">
							This is not withstanding the fact that an external referenced domain,
							such as the IETF MIME media type may include an extension
							mechanism. These extended MIME type codes would not be considered
							"extensions" in the sense of violating the CNE provision. The CNE
							provision is only violated if an attempt is made in using a different
							code system (by means of ), which is not
							possible with , or to use extensions that do not conform to the 
							external codeSystem.
						</xhtml:object>
                  </xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type CodedSimpleValue alias CS specializes CV {
   literal  ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="UID" title="UniqueIdentifierString" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ST.SIMPLE"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A unique identifier string is a character string which identifies an
					object in a globally unique and timeless manner. The allowable formats
					and values and procedures of this data type are strictly controlled by
					HL7. At this time, user-assigned identifiers SHALL only be certain character
					representations of ISO Object Identifiers (<xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="OID"/>
                  </xhtml:object>) and DCE Universally
					Unique Identifiers (<xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="UUID"/>
                  </xhtml:object>). In addition, HL7 reserves the right to assign other
					forms of <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object>s (<xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="RUID"/>
                  </xhtml:object>), such as mnemonic identifiers for code systems.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					The sole purpose of <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is to be a globally and timelessly unique
					identifier. The form of <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>, whether it is an <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="OID"/>
                     </xhtml:object>,
					a <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="UUID"/>
                     </xhtml:object> or a <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="RUID"/>
                     </xhtml:object>, is entirely irrelevant.
					As far as HL7 is concerned, the
					only thing one can do with a <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is denote to the object for which it
					stands. Comparison of <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>s is literal, i.e. if two <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>s are literally
					identical, they are assumed to denote to the same object. If two <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>s
					are not literally identical they <xhtml:b>may</xhtml:b> not denote to the
					same object. Note that this comparison is case sensitive; (<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="OID"/>
                     </xhtml:object>)s
					do not have letters subject to case, (<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="UUID"/>
                     </xhtml:object>)s are fixed to
					uppercase, and (<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="RUID"/>
                     </xhtml:object>)s have a fixed case.
				</xhtml:p>
                  <xhtml:p>
					No difference in semantics is recognized between the different
					allowed forms of <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>. The different forms are not distinguished
					by a component within or aside from the identifier string itself.
				</xhtml:p>
                  <xhtml:p>
					Even though this specification recognizes no semantic difference
					between the different forms of the unique identifier forms, there are
					differences of how these identifiers are built and managed, which is
					the sole reason to define subtypes of <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> for each of the
					variants.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type UniqueIdentifierString alias UID specializes ST.SIMPLE;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="OID" title="ObjectIdentifier" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="UID"/>
      </mif:derivedFrom>
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="INT"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A globally unique string representing an ISO Object Identifier
					(OID) in a form that consists only of numbers and dots (e.g.,
					"2.16.840.1.113883.3.1"). According to ISO, <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object>s are paths in a tree
					structure, with the left-most number representing the root and the
					right-most number representing a leaf.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p> 
					Each branch under the root corresponds to an assigning authority. Each
					of these assigning authorities may, in turn, designate its own set of
					assigning authorities that work under its auspices, and so on down the
					line. Eventually, one of these authorities assigns a unique (to it as
					an assigning authority) number that corresponds to a leaf node on the
					tree. The leaf may represent an assigning authority (in which case the
					root <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> identifies the authority), a class of particlar objects, 
					or an instance of an object. An assigning authority owns a namespace,
					consisting of its sub-tree.
				</xhtml:p>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>s are the preferred scheme for unique identifiers. <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>s SHOULD
					always be used except if one of the inclusion criteria for other
					schemes apply.
				</xhtml:p>
                  <xhtml:p>
					ISO/IEC 8824:1990(E) clause 28 defines the Object Identifier as
				</xhtml:p>
                  <xhtml:blockquote>
                     <xhtml:p>
                        <xhtml:b>28.9</xhtml:b> The semantics of an
						object identifier value are defined by reference to an <xhtml:b>
						object identifier tree</xhtml:b>. An object identifier tree is a tree whose root
						corresponds to [the ISO/IEC 8824 standard] and whose vertices [i.e. nodes]
						correspond to administrative authorities responsible for allocating arcs [i.e.
						branches] from that vertex. Each arc from that tree is labeled by an object
						identifier component, which is [an integer number]. Each information object to
						be identified is allocated precisely one vertex (normally a leaf) and no other
						information object (of the same or a different type) is allocated to
						that same vertex. Thus an information object is uniquely and
						unambiguously identified by the sequence of [integer numbers] (object
						identifier components) labeling the arcs in a path from the root to
						the vertex allocated to the information object.
					</xhtml:p>
                     <xhtml:p>
                        <xhtml:b>28.10</xhtml:b> An object identifier value is
						semantically an ordered list of object identifier component
						values. Starting with the root of the object identifier tree, each
						object identifier component value identifies an arc in the object
						identifier tree. The last object identifier component value identifies
						an arc leading to a vertex to which an information object has been
						assigned. It is this information object, which is identified by the
						object identifier value. [...]
					</xhtml:p>
                  </xhtml:blockquote>
                  <xhtml:p>
					According to ISO/IEC 8824 an object identifier is a sequence of object
					identifier component values, which are integer numbers. These
					component values are ordered such that the root of the object
					identifier tree is the head of the list followed by all the arcs down
					to the leaf representing the information object identified by the
					OID. The fact that <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> specializes <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="LIST&lt;INT&gt;"/>
                     </xhtml:object>
					represents this path of object identifier component
					values from the root to the leaf.
				</xhtml:p>
                  <xhtml:p>
					The <xhtml:b>leaf</xhtml:b> and "<xhtml:b>butLeaf</xhtml:b>"
					properties take the opposite view. The
					leaf is the last object identifier component value in the list, and
					the "butLeaf" property is all of the OID <xhtml:b>but</xhtml:b> the
					<xhtml:b>leaf</xhtml:b>. In a sense, the leaf is the identifier value and
					all of the OID but the leaf refers to the namespace in which the leaf
					is unique and meaningful.
				</xhtml:p>
                  <xhtml:p>
					However, what part of the OID is considered <xhtml:b>value</xhtml:b>
					and what is <xhtml:b>namespace</xhtml:b> may be viewed differently. In
					general, any OID component sequence to the left can be considered the namespace
					in which the rest of the sequence to the right is defined as a
					meaningful and unique identifier value. The value-property with a
					namespace OID as its argument represents this point of view.<xhtml:object name="footnote">
							The value/namespace view on ISO object identifiers has important
							semantic relevance. It represents the notion of identifier value
							versus identifier assigning authority (or "namespace"), which is common
							in healthcare information systems in general, and HL7 v2.x in
							particular.
						</xhtml:object>
                  </xhtml:p>
                  <xhtml:p>
					In order to support interoperability, HL7 maintains strict rules about the
					registration and use of OIDs. These rules are published in 
						the "Core Principles of V3 Models" specification under "Identification" ([<xhtml:a href="../coreprinciples/coreprinciples.htm#coreP_Identification-registry"/>]) and SHALL be followed.   
				</xhtml:p>
                  <xhtml:p>
						While most owners of an OID will "design" their namespace sub-tree in
						some meaningful way, there is no way to generally infer any meaning on
						the parts of an OID. HL7 does not standardize or require any namespace
						sub-structure. An OID owner, or anyone having knowledge about the
						logical structure of part of an OID, may still use that knowledge to
						infer information about the associated object; however, the techniques
						cannot be generalized.
					</xhtml:p>
                  <xhtml:img imageType="image/gif" src="datyp2fig5.gif"
                             alt="&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Example for a tree of ISO object identifiers. HL7's OID&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;is 2.16.840.1.113883.&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;"/>
                  <xhtml:p>
                     <xhtml:b>An HL7 interface SHALL NOT rely on any
						knowledge about the substructure of an OID for which it cannot control the
						assignment policies.</xhtml:b>
                  </xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type ObjectIdentifier alias OID specializes UID, LIST&lt;INT&gt; {
           INT  leaf;
           OID  butLeaf;
           OID  value(OID namespace);
   literal ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(OID x)
      where x.nonNull {
   x.notEmpty;
   x.tail.isEmpty.implies(x.leaf.equal(x.tail));
   x.tail.notEmpty.implies(x.leaf.equal(x.tail.leaf));
   x.tail.isEmpty.implies(x.butLeaf.isNull);
   x.tail.notEmpty.implies(x.butLeaf.head.equal(x.head)
         .and(x.butLeaf.tail.equal(x.butLeaf(x.tail))));
   forall(OID v; OID n) where v.equal(x.value(n)) {
      n.isEmpty.implies(v.equal(x));
      n.notEmpty.implies(v.equal(x.value(n.tail)));
      };
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="UUID" title="UniversalUniqueIdentifier" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="UID"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A globally unique string representing a DCE Universal Unique
					Identifier (UUID) in the common UUID format that consists of 5
					hyphen-separated groups of hexadecimal digits having 8, 4, 4, 4,
					and 12 places respectively.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					Both the UUID and its string representation are defined by the Open
					Group, CDE 1.1 Remote Procedure Call specification, Appendix A.
				</xhtml:p>
                  <xhtml:p>
					UUIDs are assigned based on Ethernet MAC addresses, the point in time
					of creation and some random component. This mix is believed to
					generate sufficiently unique identifiers without any organizational
					policy for identifier assignment (in fact this piggy-backs on the
					organization of MAC address assignment). Note that there are other 
					common methods for generating UUIDs. HL7 does not require that the UUID
					method defined by the Open Group specification so long as generated UUIDs
					are globally unique. 
				</xhtml:p>
                  <xhtml:p>
					UUIDs are <xhtml:b>not</xhtml:b> the preferred identifier
					scheme for use as HL7 UIDs. UUIDs may be used when identifiers are
					issued to objects representing individuals (e.g., entity instance
					identifiers, act event identifiers, etc.). For objects describing
					classes of things or events (e.g., catalog items), OIDs are the
					preferred identifier scheme.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type UniversalUniqueIdentifier alias UUID specializes UID {
   INT  timeLow;
   INT  timeMid;
   INT  timeHighAndVersion;
   INT  clockSequence;
   INT  node;
   literal  ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="RUID" title="HL7ReservedIdentifierScheme" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="UID"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A globally unique string defined exclusively by HL7. Identifiers in
					this scheme SHALL only be defined by balloted HL7 specifications. Local
					communities or systems SHALL never use such reserved identifiers based
					on bilateral negotiations.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					HL7 reserved identifiers are strings that consist only of (US-ASCII)
					letters and digits, where the first character SHALL be a
					letter. HL7 may assign these reserved identifiers as mnemonic
					identifiers for major concepts of interest to HL7. RUID's are case 
					sensitive; the case assigned to the identifier by HL7 will be used.
				</xhtml:p>
                  <xhtml:p>
					HL7 has reserved the RUID scheme for future use, but at this time there are no plans
					to make use of them, as <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="OID"/>
                     </xhtml:object>s and <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="UUID"/>
                     </xhtml:object>s have met all
					requirements so far identified.    
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type HL7ReservedIdentifierScheme alias RUID specializes UID;</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="II" title="InstanceIdentifier" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An identifier that uniquely identifies a thing or object. Examples
					are object identifier for HL7 RIM objects, medical record number,
					order id, service catalog item id, Vehicle Identification Number
					(VIN), etc. 
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					Note that a <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> does not identify the type of the object being identified, or 
					the type of the association between the object and the identifier - it is only
					the identifier itself. <xhtml:object name="footnote">HL7 is preparing a document that contains common usage patterns that
					will discuss how to best use the II type in common healthcare identification use cases.</xhtml:object>
                  </xhtml:p>
                  <xhtml:p>
					In order to simplify processing, when the root or extension properties have some nullFlavor other than 
					NotApplicable, the <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> itself must have some kind of nullFlavor.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type InstanceIdentifier alias II specializes ANY {
      UID        root;
      ST.SIMPLE  extension;
      ST.NT      identifierName;
      CS         scope;
      CS         reliability;
      BL         displayable;
  literal ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(II x) {
   root.isNull.and(root.notApplicable.not).implies(x.isNull);
   extension.isNull.and(extension.notApplicable.not).implies(x.isNull);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="URL" title="UniversalResourceLocator" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A telecommunications address specified according to Internet standard
					RFC 2396 [<xhtml:a href="http://www.ietf.org/rfc/rfc2396.txt"/>]. The
					URI specifies the protocol and the contact point defined by that
					protocol for the resource.  Notable uses of the telecommunication
					address data type are for telephone and telefax numbers, e-mail
					addresses, Hypertext references, FTP references, etc.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					The Internet standard RFC 2396 [<xhtml:a href="http://www.ietf.org/rfc/rfc2396.txt"/>] defines a URI as
					follows:
				</xhtml:p>
                  <xhtml:blockquote>
                     <xhtml:p>
						Just as there are many different methods of access to resources, there
						are several schemes for describing the location of such resources.
						The generic syntax for URLs provides a framework for
						new schemes to be established using protocols other than those defined
						in this document.
					</xhtml:p>
                     <xhtml:p>
						URLs are used to "locate" resources, by providing an abstract
						identification of the resource location. Having located a resource, a
						system may perform a variety of operations on the resource, as might
						be characterized by such words as "access", "update", "replace", "find
						attributes". In general, only the "access" method needs to be
						specified for any URL scheme.
					</xhtml:p>
                     <xhtml:p>
						By agreement, it is permissable to use a URI in place of a URL. In these
						cases, the resources identified SHOULD be accessible
						by some agreed method. A common use of URI's is to refer to SOAP attachments.
					</xhtml:p>
                  </xhtml:blockquote>
                  <xhtml:p>
				  Applications SHALL ignore separator characters when comparing <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>s with tel: scheme.  
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type UniversalResourceLocator alias URL specializes ANY {
   CS         scheme;
   ST.SIMPLE  address;
   literal    ST.SIMPLE;
   URL        canonical;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="TEL" title="TelecommunicationAddress" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="URL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A locatable resource that is identified by a URI. The address is specified as a Universal Resource 
					Identifier (URL) qualified by time specification and use codes that 
					help in deciding which address to use for a given time and purpose.
					TEL may be used to designate a retrievable resource such as a web 
					page, a telephone number (voice, fax or some other resource mediated 
					by telecommunication equipment), an e-mail address, or any other locatable
					resource that can be specified by a URL.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					The semantics of a telecommunication address is that a communicating
					entity (the responder) listens and responds to that address, and
					therefore can be contacted by an other communicating entity (the
					initiator).
				</xhtml:p>
                  <xhtml:p>
					The responder of a telecommunication address may be an automatic
					service that can respond with information (e.g., FTP or HTTP
					services).  In such case a telecommunication address is a reference to
					that information accessible through that address. A telecommunication
					address value can thus be resolved to some information (in the form of
					encapsulated data, <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="ED"/>
                     </xhtml:object>).
				</xhtml:p>
                  <xhtml:p>
					The telecommunication address is an extension of the Universal
					Resource Locator (<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="URL"/>
                     </xhtml:object>) specified according to Internet
					standard RFC 2396 [<xhtml:a href="http://www.ietf.org/rfc/rfc2396.txt"/>].
					The <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="URL"/>
                     </xhtml:object> specifies the protocol and the contact point
					defined by that protocol for the resource. Notable use cases for the
					telecommunication address data type are for telephone and fax numbers,
					e-mail addresses, Hypertext references, FTP references, etc.
				</xhtml:p>
                  <xhtml:div title="Examples for TEL">telexamples
						The first example shows a combination work and home phone number.
					
&lt;tel value="tel:+15556755745" use="H WP"/&gt;
						The second example shows a combination work phone number with optional separators and 
						an extension 545.
					
&lt;tel value="tel:+1(555)6755745;postd=545" use="WP"/&gt;
						Note that extensions are not the only use for the post-dial sequence. Consult RFC 2806
						[] for further details. The canonical
						form of this example is:
					
&lt;tel value="tel:+15556755745;postd=545" use="WP"/&gt;</xhtml:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type TelecommunicationAddress alias TEL specializes URL {
   DSET&lt;CS&gt; use;
   DSET&lt;CS&gt; capabilities;
   GTS      useablePeriod;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="ADXP" title="AddressPart" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SC.NT"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A character string that may have a type-tag signifying its role in the
					address. Typical parts that exist in about every address are street,
					house number, or post box, postal code, city, country but other roles
					may be defined regionally, nationally, or on an enterprise level
					(e.g. in military addresses). Addresses are usually broken up into
					lines, which are indicated by special line-breaking delimiter elements
					(e.g., DEL).
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type AddressPart alias ADXP specializes SC.NT {
   CS  partType;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="AD" title="PostalAddress" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="ADXP"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					Mailing and home or office addresses. A sequence of address parts,
					such as street or post office box, city, postal code, country, etc.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is primarily used to communicate data that will allow
					printing mail labels, that will allow a person to physically visit
					that address. The postal address data type is not supposed to be a
					container for additional information that might be useful for finding
					geographic locations (e.g., GPS coordinates) or for performing
					epidemiological studies. Such additional information is captured by
					other, more appropriate HL7 elements.
				</xhtml:p>
                  <xhtml:p>
					Addresses are conceptualized as text with added logical mark-up. The
					mark-up may break the address into lines and may describe in detail
					the role of each address part if it is known. Address parts occur in
					the address in the order in which they would be printed on a mailing
					label. The approach is similar to HTML or XML markup of text (but it
					is not technically limited to XML representations).
				</xhtml:p>
                  <xhtml:p>
					Addresses are essentially sequences of address parts, but add a "use"
					code and a valid time range for information about if and when the
					address can be used for a given purpose.
				</xhtml:p>
                  <xhtml:p>
						The correct presentation order of the parts is realm dependent and may not be the same between addresses 
						from different countries or realms. Patients regularly travel between realms, so realm specified ordering
						and constraints need to account for addresses from other realms as well. 
					</xhtml:p>
                  <xhtml:div title="AD Examples">ADExamples
						For examples of names, please consult the ISO datatypes [to do: what reference?].
					</xhtml:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type PostalAddress alias AD specializes LIST&lt;ADXP&gt; {
   DSET&lt;CS&gt; use;
   GTS      useablePeriod;
   BL       isNotOrdered;
   ST.NT    formatted;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="ENXP" title="EntityNamePart" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SC.NT"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A character string token representing a part of a name. May have a
					type code signifying the role of the part in the whole entity name,
					and a qualifier code for more detail about the name part type.
					Typical name parts for person names are given names, and family names,
					titles, etc.
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type EntityNamePart alias ENXP specializes SC.NT {
   CS       partType;
   DSET&lt;CS&gt;  qualifier;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="EN" title="EntityName" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="ENXP"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A name for a person, organization, place or thing. A sequence of name
					parts, such as given name or family name, prefix, suffix, etc.
					Examples for entity name values are "Jim Bob Walton, Jr.", "Health
					Level Seven, Inc.", "Lake Tahoe", etc. An entity name may be as simple
					as a character string or may consist of several entity name parts,
					such as, "Jim", "Bob", "Walton", and "Jr.", "Health Level Seven" and
					"Inc.", "Lake" and "Tahoe".
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					Entity names are conceptualized as text with added logical mark-up.
					Name parts occur in a natural order in which they would be displayed,
					as opposed to in a order detemined by name part. The ordering of the
					name parts is significant a feature that replaces the need for a
					separate "display name" property. Applications may change that
					ordering of name parts to account for their user's customary ordering
					of name parts. The approach is similar to HTML or XML markup of text
					(but it is not technically limited to XML representations).
				</xhtml:p>
                  <xhtml:p>
					Entity names are essentially sequences of entity name parts, but add a
					"use" code and a valid time range for information about when the name
					was used and how to choose between multiple aliases that may be valid
					at the same point in time.
				</xhtml:p>
                  <xhtml:p>
					The existence of the use and qualifier codes does not mean that names must 
					always be fully encoded. For example, in most contexts, as a matter of cultural 
					practice, prefixes will simply be recorded as part of the family name to which 
					they are corrected. Some specific implementation negotiation may always be 
					required to clarify how to deal with implementations that have different policies 
					about how names are represented using the facilities of the name.
				</xhtml:p>
                  <xhtml:div title="EN Examples">ENExamples
						For examples of names, please consult the ISO datatypes [to do: what reference?].
					</xhtml:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type EntityName alias EN specializes LIST&lt;ENXP&gt; {
      DSET&lt;CS&gt; use;
      IVL&lt;TS&gt;  validTime;
      EN       canonical;
      ST.NT    formatted;
   
  demotion   ST.NT;
  promotion  TN (ST x);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="QTY" title="Quantity" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					The quantity data type is an abstract generalization for all data
					types (1) whose value set has an order relation (less-or-equal) and
					(2) where difference is defined in all of the data type's totally
					ordered value subsets.  The quantity type abstraction is needed in
					defining certain other types, such as the interval and the probability
					distribution.
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
abstract type Quantity alias QTY specializes ANY {
   BL      isComparableTo(QTY x);
   BL      lessOrEqual(QTY x);
   BL      lessThan(QTY x);
   BL      greaterThan(QTY x);
   BL      greaterOrEqual(QTY x);
   TYPE    diffType;
   QTY     minus(QTY x);
   QTY     plus(QTY x);
   ED.TEXT originalText;
   promotion RTO&lt;QTY, INT&gt; (QTY x);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="QTZ" title="ZeroedQuantity" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					The Zeroed Quantity data type is an abstract generalization for all data
					types where the addition and subtraction operations involve both operands
					and results from the same type, and where the concept of a zero value exists. 
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
abstract type ZeroedQuantity alias QTZ specializes QTY {
   QTZ   minus(QTZ x);
   QTZ   plus(QTZ x);
   BL    isZero;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="INT" title="IntegerNumber" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTZ"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise numbers
					that are results of counting and enumerating. Integer numbers are
					discrete, the set of integers is infinite but countable.  No arbitrary
					limit is imposed on the range of integer numbers. Two NULL flavors are
					defined for the positive and negative infinity.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					Since the integer number data type includes all of the semantics of
					the mathematical integer number concept, the basic operations plus
					(addition) and times (multiplication) are defined. These operations
					are defined here as characterizing operations in the sense of ISO
					11404, and because these operations are needed in other parts of this
					specification, namely the semantics of the literal form.
				</xhtml:p>
                  <xhtml:p>
					The traditional recursive definitions of addition and multiplication
					are due to Grassmann, and use the notion of <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="successor"/>
                        <xhtml:param name="datatypeName" value="INT"/>
                     </xhtml:object>.<xhtml:object name="footnote">
							H. Grassman. Lehrbuch der Arithmetik. 1861. We prefer
							Grassman's original axioms to the Peano axioms, because Grassman's
							axioms work for all integers, not just for natural numbers. Also, "it
							is rather well-known, through Peano's own acknowledgment, that Peano
							borrowed his axioms from Dedekind and made extensive use of
							Grassmann's work in his development of the axioms." (Hao Wang. The
							Axiomatization of Arithmetic. J. Symb. Logic; 1957:22(2); p. 145).
						</xhtml:object>
                  </xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type IntegerNumber alias INT specializes QTZ {
           INT  successor;
           INT  predecessor;
           INT  plus(QTY x);
           INT  times(INT x);
           INT  negated;
           BL   isNegative;
           BL   nonNegative;
           REAL  dividedBy(REAL x);
           INT  dividedBy(INT x);
           INT  remainder(INT x);
           BL   isOne;
  literal  ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x, o, i)
      where x.nonNull.and(o.isZero) {
   x.lessThan(x.successor);
   x.plus(o).equal(x);
   x.plus(y.successor).equal(x.plus(y).successor);
   x.times(o).equal(o);
   x.times(y.successor).equal(x.times(y)).plus(x);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="REAL" title="RealNumber" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTZ"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A scalar magnitude. Typically used whenever quantities are measured,
					estimated, or computed from other real numbers.  The typical
					representation is decimal, where the number of significant decimal
					digits is known as the precision.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					The term "Real number" in this specification is used to mean that
					fractional values are covered without necessarily implying the full
					set of the mathematical real numbers that would include irrational
					numbers such as ρ, Euler's number, etc.<xhtml:object name="footnote">
							The term "Real" for a fractional number data type originates and is
							well established in the Algol, Pascal tradition of programming
							languages.
						</xhtml:object>
                  </xhtml:p>
                  <xhtml:p>
					This specification offers two choices for a number data type. The
					choice is made as follows: Any number attribute is a real if it is not
					known for sure that it is an integer. A number is an integer if it is
					<xhtml:b>always</xhtml:b> counted, typically representing an ordinal
					number. If there are conceivable use cases where such a number would
					be estimated or averaged, it is not always an integer and thus should
					use the Real data type.
				</xhtml:p>
                  <xhtml:p>
					The algebraic operations are specified here as characterizing
					operations in the sense of ISO 11404, and because these operations are
					needed in other parts of this specification.
				</xhtml:p>
                  <xhtml:p>
					Unlike the integer numbers, the real numbers semantics are not
					inductively constructed but only intuitively described by their axioms
					of their algebraic properties. The completeness axioms are
					intentionally left out so as to make no statement about irrational
					numbers.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type RealNumber alias REAL specializes QTZ {
             INT   precision;
             REAL  negated;
             BL    isOne;
             REAL  times(REAL x);
             REAL  dividedBy(REAL x);
             REAL  inverted;
             REAL  power(REAL x);
  literal    ST.SIMPLE;
  promotion  REAL  (INT x);
  demotion   INT;
};</mif:data>
            </mif:otherAnnotation>
            <mif:otherAnnotation type="ITS-Note">
               <mif:text>
                  <xhtml:p>
						This specification defines the real number data type in the broadest
						sense possible. However, it does not imply that any conforming ITS or
						implementation must be able to represent the full range of Real
						numbers, which would not be possible in any finite
						implementation. HL7's current use cases for the Real number data type
						are measured and estimated quantities and monetary amounts. These use
						cases can be handled with a restricted Real value space, rational
						numbers, and even just very limited decimals (scaled integers).
						However, we declare the representations of the real value space as
						floating point, rational, scaled integer, or digit string, and their
						various limitations to be out of the scope of this specification.
					</xhtml:p>
               </mif:text>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="RTO" title="Ratio" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A quantity constructed as the quotient of a numerator quantity divided
					by a denominator quantity. Common factors in the numerator and
					denominator are not automatically cancelled out.  The <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> data
					type supports titers (e.g., "1:128") and other quantities produced by
					laboratories that truly represent ratios. Ratios are not simply
					"structured numerics": for instance, blood pressure measurements
					(e.g. "120/60") are not ratios.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					Ratios are different from rational numbers, i.e., in ratios common
					factors in the numerator and denominator never cancel out.  A ratio of
					two real or integer numbers is not automatically reduced to a real
					number. In many cases the <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="REAL"/>
                     </xhtml:object>
					should be used instead of <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>
                  </xhtml:p>
                  <xhtml:p>
					The default value for both numerator and denominator is the integer
					number 1 (one). The denominator may not be zero.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTZ N, QTZ D&gt;
type Ratio&lt;N, D&gt; alias RTO&lt;N, D&gt; specializes QTY {
   N         numerator;
   D         denominator;
   literal   ST.SIMPLE;
   demotion  REAL;
   demotion  PQ;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="N" sortKey="1">
         <mif:type name="QTZ"/>
      </mif:parameter>
      <mif:parameter name="D" sortKey="2">
         <mif:type name="QTZ"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="PQ" title="PhysicalQuantity" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTZ"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A dimensioned quantity expressing the result of measuring.
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type PhysicalQuantity alias PQ specializes QTZ {
            REAL      value;
            CS        unit;
            SET&lt;CS&gt;   codingRationale;
            DSET&lt;PQR&gt; translation;

            PQ        canonical;
            PQ        plus(QTY x);
            BL        isOne;
            PQ        times(REAL x);
            PQ        dividedBy(REAL x);
            PQ        times(PQ x);
            PQ        dividedBy(PQ x);
            PQ        negated;
            PQ        inverted;
            PQ        power(INT x);

  literal   ST.SIMPLE;
  promotion  PQ  (REAL x);
  demotion  REAL;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="PQR" title="PhysicalQuantityRepresentation" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="CV"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An extension of the coded value data type representating a physical
					quantity using a unit from any code system. Used to show alternative
					representation for a physical quantity.
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
protected type PhysicalQuantityRepresentation alias PQR specializes CV {
   REAL  value;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="MO" title="MonetaryAmount" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTZ"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A quantity expressing an amount of money in some
					currency. While the monetary amount
					is a single kind of quantity (money) the exchange rates between the
					different units are variable.  This is the principle difference
					between <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="PQ"/>
                  </xhtml:object> and <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object>, and the reason why
					currency units are not physical units.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p/>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type MonetaryAmount alias MO specializes QTZ {
           REAL  value;
           CS    currency;
           MO    plus(MO x);
           MO    times(REAL x);
           MO    dividedBy(REAL x);
   literal ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="CAL" title="Calendar" datatypeKind="Definition" visibility="private">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="DSET">
            <mif:argumentDatatype name="CLCY"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A calendar is a concept of measuring time in various cycles. Such
					cycles are years, months, days, hours, minutes, seconds, and
					weeks. Some of these cycles are synchronized and some are not (e.g.,
					weeks and months are not synchronized).
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					After "rolling the time axis" into these cycles
					a calendar expresses a point in time as a sequence
					of integer counts of cycles, e.g., for year, month, day, hour,
					etc. The calendar is rooted in some conventional start point, called
					the "epoch."
				</xhtml:p>
                  <xhtml:img imageType="image/gif" hl7Id="CAL" src="datyp2fig9.gif" alt="**NO CAPTION**"/>
                  <xhtml:p>
					A calendar "rolls" the time axis into a complex convolute according to
					the calendar periods year (blue), month (yellow), day (green), hour
					(red), etc. The cycles need not be aligned, for example, the week (not
					shown) is not aligned to the month.<xhtml:object name="footnote">
							Imagine a special clock that measures those cycles, where the pointers
							are not all stacked on a common axis but each pointer is attached to
							the end of the pointer measuring the next larger cycle.
						</xhtml:object>
                  </xhtml:p>
                  <xhtml:p>
					Calendar is defined as a set of calendar cycles, and has a name and a
					code. The head of the Calendar is the largest CalendarCycle appearing
					right most in the calendar expression. The epoch is the beginning of
					that calendar, i.e., the point in time where all calendar cycles are
					zero.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
private type Calendar alias CAL specializes DSET&lt;CLCY&gt;  {
   CS    name;
   CLCY  head;
   TS    epoch;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="CLCY" title="CalendarCycle" datatypeKind="Definition"
                 visibility="private">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>    
					A calendar cycle defines one group of decimal digits in the calendar
					expression. Examples for calendar cycles are year, month, day, hour,
					minute, second, and week.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					A calendar cycle has a name and two codes, a one-letter code and a
					two-letter code. The property <xhtml:b>ndigits</xhtml:b> is the number of
					decimal digits occupied in the calendar expression. The property
					<xhtml:b>start</xhtml:b> specifies where counting starts (i.e., at 0 or 1).
					The <xhtml:b>next</xhtml:b> property is the next lower cycle in the order of
					the calendar expression. The max(<xhtml:b>t</xhtml:b>) property is the
					maximum number of cycles at time <xhtml:b>t</xhtml:b> (max depends on the
					time <xhtml:b>t</xhtml:b> to account for leap years and leap seconds).  The
					property value(<xhtml:b>t</xhtml:b>) is the integer number of cycles shown
					in the calendar expression of time <xhtml:b>t</xhtml:b>. The property
					sum(<xhtml:b>t</xhtml:b>, <xhtml:b>n</xhtml:b>) is the sum of <xhtml:b>n</xhtml:b>
					calendar cycles added to the time <xhtml:b>t</xhtml:b>.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
private type CalendarCycle alias CLCY specializes ANY {
   CV     name;
   INT    ndigits;
   INT    start;
   CLCY   next;
   INT    max(TS t);
   TS     sum(TS t, REAL r);
   INT    value(TS t);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CLCY c)
      where c.nonNull {
   c.name.nonNull;
   c.start.equal(0).or(c.start.equal(1));
   c.digits.greaterThan(0);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="TS" title="PointInTime" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A quantity specifying a point on the axis of natural time. A point
					in time is most often represented as a calendar expression.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					Semantically, however, time is independent from calendars and best
					described by its relationship to elapsed time (measured as a physical
					quantity in the dimension of time).  A <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> plus an elapsed
					time yields another <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>.  Inversely, a <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> minus
					another <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> yields an elapsed time.
				</xhtml:p>
                  <xhtml:p>
					As nobody knows when time began, a <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is conceptualized as
					the amount of time that has elapsed from some arbitrary zero-point,
					called an epoch.  Because there is no absolute zero-point on the time
					axis; natural time is a difference-scale quantity, where only
					differences are defined but no ratios. (For example, no <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>
					is — absolutely speaking — "twice as late" as another
					<xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>).
				</xhtml:p>
                  <xhtml:p>
					Given some arbitrary zero-point, one can express any point in time as
					an elapsed time measured from that offset. Such an arbitrary
					zero-point is called an epoch. This epoch-offset form is used as a
					semantic representation here, without implying that any system would
					have to implement <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> in that way. Systems that do not
					need to compute distances between <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>s will not need any
					other representation than a calendar expression literal.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type PointInTime alias TS specializes QTY {
           PQ   offset;
           CS   calendar;
           INT  precision;
           PQ   timezone;
           TS   plus(PQ x);
           PQ   minus(TS x);
           TS   minus(PQ x);
  literal  ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="EXPR" title="Expression" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="T" qualifier="parameter"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A generic data type extension used to specify an expression
					that can be used to derive the actual value of T given information
					taken from the context of use.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					For example <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> can be used for expressing dosage instructions that
					depend on patient body weight. 
				</xhtml:p>
                  <xhtml:p>
				The expression specifies how the value of type T can be evaluated. 
				Either an expression or a value or both may be provided. It is at the
				discretion of the receiver of the information whether to evaluate the 
				expression when the information is being processed. If no value is 
				provided, then the value SHALL have a nullFlavor, whether or not an 
				expression is provided.
			</xhtml:p>
                  <xhtml:p>
				Note that as a generic type extension, <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> does not modify the
				meaning of equality for the type which it specializes.
			</xhtml:p>
                  <xhtml:div title="Factor: A simple language for dosage quantities">
     This is a very simple language to support 
     common dosage formulas that dependent on some patient observations, e.g., body mass or the body surface area.
     The language supports any formula that uses one or more input data as factors multiplied with some constant coefficient. 
     For example, a standard dose might be 30 mL per kg of body mass,
     i.e. the constant coefficient is 30 mL/kg and is multiplied with the body mass.
				Introduction
						A factor expression simply calculates the value from as specified from one or more derivedFrom
						observations on the context of the local act of which the expression is an attribute.
						Here is an example:
					
 &lt;substanceAdministration&gt;
   ...
   &lt;doseQuantity xsi:type="EXPR_PQ" unit="mL" mediatype="application/hl7-factor+xml"&gt;
     &lt;coefficient value="30" unit="mL/kg"&gt;
     &lt;factor&gt;bodyMass&lt;/factor&gt;
   &lt;/doseQuantity&gt;
   ...
   &lt;derivedFrom&gt;
     &lt;localVariableName&gt;bodyMass&lt;/localVariableName&gt;
     &lt;monitoringObservation&gt;
       &lt;code code="29463-7" codeSystem="2.16.840.1.113883.6.1" displayName="BODY WEIGHT:MASS:PT:^PATIENT:QN"/&gt;
     &lt;/monitoringObservation&gt;
   &lt;/derivedFrom&gt;
 &lt;/substanceAdministration&gt;
      The value of the input observations that serve as factors is usually not provided but resolved at 
      the time of evaluating the expression; at that time the receiving application will have to source an
      appropriate observation in order to evaluate the expression. If no appropriate
      observation can be found, the result of the expression is null.     
					Formal Definition
      The mediatype for this language is "application/hl7-factor+xml".
      This language is only applicable to . The source SHALL be provided 
      in-line, and no translations are allowed. For interest, here is the formal definition:
					
					
invariant(EXPR x) where
  x.mediaType.equals("application/hl7-factor+xml") {
  x.expression.nonNull;
  x.expression.language.notApplicable;
  x.expression.compression.notApplicable;
  x.expression.reference.notApplicable;
  x.expression.integrityCheck.notApplicable;
  x.expression.integrityCheckAlgorithm.notApplicable;
  x.expression.description.notApplicable;
  x.expression.thumbnail.notApplicable;
  x.expression.translation.isEmpty;
};
      The expression consists of a coefficient with a type of , and a 
      series of factors, which are simple names. Factors are specified as a simple 
      data value, and refer to an ActRelationship.localVariableName of the relationship
	  specifying the input variable. The specific wire format for this is defined in the ITS specifications.
					
      An expression of this type SHALL only be used on an attribute that is part
      of an Act, and the Act SHALL have one ActRelationship for each named factor in
      the expression, where the ActRelationship has an Observation as target and
      a localVariableName attribute equal to the named factor.
      The target Observation SHALL 
      have a code that specifies the type of observation. 
      The target Observation MAY have a value, but typically NEED NOT carry a value. 
 					
      The result of the expression is the product of the coefficient and all the factors according to the 
      semantics of all data types involved.
      Specifically, Units in  factors SHALL be carried through correctly and determine the dimension of the final result. 
      If a unit is specified in the  itself, then the units of the result SHALL be compared to the units specified. If no
      conversion to the correct units is possible, the result of the evaluation SHALL be NULL. 
      In other words, specifying the unit will guarantee the dimension of the result.
   					
      This language is deliberately limited in scope for ease of implementation. For more
      sophisticated requirements other languages should be used instead.
      HL7 plans to develop separate appendix documents describing the use of other expression languages.
					</xhtml:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type Expression&lt;T&gt; alias EXPR&lt;T&gt; specializes T {
  ED      expression;
  EXPR&lt;T&gt;  evaluate;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="GLIST" title="GeneratedSequence" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="LIST"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A periodic or monotone sequence of values generated from
					parameters, rather than being enumerated. 
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is used to specify regular sampling points for biosignals.
				</xhtml:p>
                  <xhtml:p>
					The item at a certain index in the list is calculated by performing an
					integer division on the index (<xhtml:var>i</xhtml:var>) with the
					<xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="denominator"/>
                        <xhtml:param name="datatypeName" value="GLIST"/>
                     </xhtml:object> (<xhtml:var>d</xhtml:var>) and then take that
					value's remainder modulus <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="period"/>
                        <xhtml:param name="datatypeName" value="GLIST"/>
                     </xhtml:object>
					(<xhtml:var>p</xhtml:var>). Multiply this value with the
					<xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="increment"/>
                        <xhtml:param name="datatypeName" value="GLIST"/>
                     </xhtml:object> (<xhtml:var>Δx</xhtml:var>) and add to the
					<xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="head"/>
                        <xhtml:param name="datatypeName" value="GLIST"/>
                     </xhtml:object> (<xhtml:var>x</xhtml:var>
                     <xhtml:sub>0</xhtml:sub>).
				</xhtml:p>
                  <xhtml:blockquote>
                     <xhtml:p>
                        <xhtml:var>x</xhtml:var>
                        <xhtml:sub>
                           <xhtml:var>i</xhtml:var>
                        </xhtml:sub>=<xhtml:var>x</xhtml:var>
                        <xhtml:sub>0</xhtml:sub>
						+ <xhtml:var>Δx</xhtml:var> × (<xhtml:var>i</xhtml:var>/<xhtml:var>d</xhtml:var>)
						mod <xhtml:var>p</xhtml:var>.
					</xhtml:p>
                  </xhtml:blockquote>
                  <xhtml:table width="90%" hl7Id="table-GLIST.example">
                     <xhtml:caption>Examples for Generated Sequences</xhtml:caption>
                     <xhtml:thead>
                        <xhtml:tr>
                           <xhtml:th>head</xhtml:th>
                           <xhtml:th>increment</xhtml:th>
                           <xhtml:th>denominator</xhtml:th>
                           <xhtml:th>period</xhtml:th>
                           <xhtml:th>meaning</xhtml:th>
                        </xhtml:tr>
                     </xhtml:thead>
                     <xhtml:tbody>
                        <xhtml:tr>
                           <xhtml:td>0</xhtml:td>
                           <xhtml:td>1</xhtml:td>
                           <xhtml:td>1</xhtml:td>
                           <xhtml:td>∞</xhtml:td>
                           <xhtml:td>The identity-sequence where each item is equal to its index.</xhtml:td>
                        </xhtml:tr>
                        <xhtml:tr>
                           <xhtml:td>198706052000</xhtml:td>
                           <xhtml:td>2 hour</xhtml:td>
                           <xhtml:td>1</xhtml:td>
                           <xhtml:td>∞</xhtml:td>
                           <xhtml:td>
								Sequence starting on June 5, 1987 at 7 PM and
								incrementing every two hours: 9 PM, 11 PM, 1 AM (June 6), 3
								AM, 5 AM, and so on.
							</xhtml:td>
                        </xhtml:tr>
                        <xhtml:tr>
                           <xhtml:td>0 V</xhtml:td>
                           <xhtml:td>1 mV</xhtml:td>
                           <xhtml:td>1</xhtml:td>
                           <xhtml:td>100</xhtml:td>
                           <xhtml:td>
								The x-wave of a digital oscillograph scanning between
								0 and 100 mV in 100 steps of 1 mV. The frequency is unknown
								from these data as we do not know how much time elapses
								between each step of the index.
							</xhtml:td>
                        </xhtml:tr>
                        <xhtml:tr>
                           <xhtml:td>2002072920300</xhtml:td>
                           <xhtml:td>100 us</xhtml:td>
                           <xhtml:td>1</xhtml:td>
                           <xhtml:td>∞</xhtml:td>
                           <xhtml:td>
								A timebase from June 29,
								2002 at 8:30 PM with 100 us between each steps of the
								index. If combined with the previous generator as a second
								sampling dimension this would now describe our digital
								oscilloscope's x-timebase as 1 mV per 100 us. At 100 steps
								per period, the period is 10 ms, which is equal to a
								frequency of 100 Hz.
							</xhtml:td>
                        </xhtml:tr>
                        <xhtml:tr>
                           <xhtml:td>0 V</xhtml:td>
                           <xhtml:td>1 mV</xhtml:td>
                           <xhtml:td>100</xhtml:td>
                           <xhtml:td>100</xhtml:td>
                           <xhtml:td>
								Combining this generator to the previous two generators
								could describe a three-dimensional sampling space with two
								voltages and time. This generator also steps at 1 mV and has
								100 steps per period, however, it only steps every 100 index
								increments, so, the first voltage generator makes one full
								cycle before this generator is incremented. One can think of
								the two voltages as "rows" and "columns" of a "sampling
								frame". With the previous generator as the timebase, this
								results in a scan of sampling frames of 100 mV × 100
								mV with a framerate of 1 Hz.
							</xhtml:td>
                        </xhtml:tr>
                     </xhtml:tbody>
                  </xhtml:table>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type GeneratedSequence&lt;T&gt; alias GLIST&lt;T&gt; specializes LIST&lt;T&gt; {
   T.diffType  increment;
   INT  period;
   INT  denominator;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(GLIST&lt;T&gt; list, INT index)
      where list.nonNull.and(index.nonNull) {
   list.period.nonNull.implies(list.item(index).equal(
      list.head.plus(item.dividedBy(list.increment.denominator)
          .remainder(list.period)).times(increment)));
   list.period.isNull.implies(list.item(index).equal(
      list.head.plus(item.dividedBy(list.increment.denominator))
          .times(increment)));
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="SLIST" title="SampledSequence" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="LIST"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A sequence of sampled values scaled and translated from a list of
					integer values.  
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is used to specify sampled biosignals. The parameter T must be a type of<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QTY"/>
                     </xhtml:object>.
					A <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> contains a list of integers. The item at a certain index (<xhtml:var>i</xhtml:var>) in the list is calculated
					by multiplying the item at the same index in the
					<xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="digits"/>
                        <xhtml:param name="datatypeName" value="SLIST"/>
                     </xhtml:object> sequence
					(<xhtml:var>d</xhtml:var>
                     <xhtml:sub>
                        <xhtml:var>i</xhtml:var>
                     </xhtml:sub>) with the
					<xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="scale"/>
                        <xhtml:param name="datatypeName" value="SLIST"/>
                     </xhtml:object> (<xhtml:var>s</xhtml:var>)
					and then add that value to the <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="origin"/>
                        <xhtml:param name="datatypeName" value="SLIST"/>
                     </xhtml:object>
					(<xhtml:var>x</xhtml:var>
                     <xhtml:sub>
                        <xhtml:var>o</xhtml:var>
                     </xhtml:sub>).
				</xhtml:p>
                  <xhtml:blockquote>
                     <xhtml:p>
                        <xhtml:var>x</xhtml:var>
                        <xhtml:sub>
                           <xhtml:var>i</xhtml:var>
                        </xhtml:sub>=<xhtml:var>x</xhtml:var>
                        <xhtml:sub>
                           <xhtml:var>o</xhtml:var>
                        </xhtml:sub> + <xhtml:var>s</xhtml:var>
						× <xhtml:var>d</xhtml:var>
                        <xhtml:sub>
                           <xhtml:var>i</xhtml:var>
                        </xhtml:sub>
                     </xhtml:p>
                  </xhtml:blockquote>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is usually used for measured values of type <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PQ"/>
                     </xhtml:object>. 
					The <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is just a list of values; in order to 
					fully understand the data, information concerning the sampling conditions must be provided separately.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type SampledSequence&lt;T&gt; alias SLIST&lt;T&gt; specializes LIST&lt;T&gt; {
   T          origin;
   T.diffType        scale;
   LIST&lt;INT&gt;  digits;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SLIST&lt;T&gt; list, INT index)
      where list.nonNull.and(index.nonNegative) {
   list.item(index).equal(
      list.scale.times(digits.item(index))
          .plus(list.origin));
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="QSET" title="ContinuousSet" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
            <mif:argumentDatatype name="CEQ">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:argumentDatatype>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An unordered set of distinct values which are quantities.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					Continuous sets are distinguished from discrete sets in that they may contain an infinite number of elements, viz., 
					a period of time containing infinitely many points in time that can be defined to an arbitrary level of precision.
				</xhtml:p>
                  <xhtml:p>
					Although <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> provides methods to test for membership of the set, it does not actually
					contain any properties that specify what the contents of the set are. An instance of a 
					<xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is constructed by combining the <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> builder types in an expression
					tree using mathematical operation types. The expression tree specifies exactly which 
					values are part of the <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>. The central <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> builder type is <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="IVL"/>
                     </xhtml:object>
					which specifies a contiguous range of values. Multiple intervals may be combined into 
					expressions using the <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> specializations for mathematical operations: 
					union (<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSU"/>
                     </xhtml:object>), intersection (<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSI"/>
                     </xhtml:object>), difference (<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSD"/>
                     </xhtml:object>), 
					and periodic hull (<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSP"/>
                     </xhtml:object>). In addition, there are special types for 
					periodically repeating intervals (<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PIVL"/>
                     </xhtml:object>), event-related intervals (<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="EIVL"/>
                     </xhtml:object>),
					and <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSC"/>
                     </xhtml:object> which allows common timing expressions to be represented as simple codes.
					Note that <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="GTS"/>
                     </xhtml:object> is a full alias for <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSET"/>
                     </xhtml:object>&lt;<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TS"/>
                     </xhtml:object>&gt;.
				</xhtml:p>
                  <xhtml:p>
					Since the semantics of <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> are tightly bound to the definitions of equality in the <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QTY"/>
                     </xhtml:object>
					specializations, it is never appropriate to redefine the meaning of uniqueness in these sets, and all
					<xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>s use the default comparator <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="CEQ"/>
                     </xhtml:object>. Membership of the set is always based on equality.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
abstract type ContinuousSet&lt;T&gt; alias QSET&lt;T&gt; specializes SET&lt;T, CEQ&lt;T&gt;&gt; {
    IVL&lt;T&gt;    hull;
    IVL&lt;T&gt;    intervalAt(T x);
    IVL&lt;T&gt;    intervalAtOrAfter(T x);
    IVL&lt;T&gt;    intervalAfter(T x);
    BL        interleaves(QSET&lt;T&gt; x);
    QSET&lt;T&gt;   periodicHull(QSET&lt;T&gt; x);
    ED.TEXT   originalText;
  demotion  LIST&lt;IVL&lt;T&gt;&gt;;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="QSU" title="ContinuousSetUnion" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A Term in a <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="QSET"/>
                  </xhtml:object> expression that builds a <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="QSET"/>
                  </xhtml:object> from a union
					of other <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="QSET"/>
                  </xhtml:object>s.
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type ContinuousSetUnion&lt;T&gt; alias QSU&lt;T&gt; specializes QSET&lt;T&gt; {
    DSET&lt;QSET&lt;T&gt;&gt;   terms;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="QSI" title="ContinuousSetIntersection" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A Term in a <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="QSET"/>
                  </xhtml:object> expression that builds a <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="QSET"/>
                  </xhtml:object> from an intersection
					of other <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="QSET"/>
                  </xhtml:object>s.
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type ContinuousSetIntersection&lt;T&gt; alias QSI&lt;T&gt; specializes QSET&lt;T&gt; {
    DSET&lt;QSET&lt;T&gt;&gt;   terms;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="QSD" title="ContinuousSetDifference" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A Term in a <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="QSET"/>
                  </xhtml:object> expression that builds a <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="QSET"/>
                  </xhtml:object> from the
					difference between 2 <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="QSET"/>
                  </xhtml:object>s.
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type ContinuousSetDifference&lt;T&gt; alias QSD&lt;T&gt; specializes QSET&lt;T&gt; {
    QSET&lt;T&gt;   minuend;
    QSET&lt;T&gt;   subtrahend;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="QSP" title="ContinuousSetPeriodicHull" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A Term in a <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="QSET"/>
                  </xhtml:object> expression that builds a <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="QSET"/>
                  </xhtml:object> from the
					difference between 2 <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="QSET"/>
                  </xhtml:object>s.
				</mif:text>
            </mif:definition>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type ContinuousSetPeriodicHull&lt;T&gt; alias QSP&lt;T&gt; specializes QSET&lt;T&gt; {
    QSET&lt;T&gt;   low;
    QSET&lt;T&gt;   high;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="QSC" title="CodedContinuousSet" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="CS"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A Term in a <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="QSET"/>
                  </xhtml:object> expression that builds a <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="QSET"/>
                  </xhtml:object> from a coded value.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					The code unambiguously describes a <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSET"/>
                     </xhtml:object>&lt;T&gt; 
					such that <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSET"/>
                     </xhtml:object> properties can be supported. <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> SHALL only be used with 
					parameter types for which HL7 has defined domains and their associated codeSystems. At present 
					HL7 has only done this for <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TS"/>
                     </xhtml:object>, which is the domain GTSAbbreviation, associated with
					the codeSystem defined below. 
				</xhtml:p>
                  <xhtml:div title="GTSAbbreviation: Codes for &lt;&gt;.">datyp2gtslitsym
							
								
								
								
							
							
							
							
							
							
							
							
							

								 
									
									
									
									
									
									
								
								
									
									
									
									
									
									
									
									
									
									
									
									
									
								
							
						
								This table is not complete, nor does it include religious holidays
								other than Christian (of the Gregorian [Western] tradition) or
								national holidays countries other than those of the US. This
								is a limitation to be remedied by subsequent additions.
							
								Holidays are locale-specific. Exactly which religious holidays are
								subsumed under JH depends on the locale and other tradition. For
								global interoperability, using constructed 
								expressions is safer than named holidays. However, some holidays that
								depend on moon phases (e.g., Easter) or ad-hoc decree cannot be easily
								expressed in a  other than by use .
							
							Where possible, table  defines 
							literal values for  values that could be used in
							 literals in place of a coded value. Codes
							are defined for common periods of the day (AM, PM),
							for periods of the week (business day, weekend), and for holidays.
							The computation for the dates of some holidays, namely
							the Easter holiday, involve some sophistication that goes beyond what
							one would represent in a  literal. It is
							assumed that the dates of these holidays are drawn from some table or
							some generator module that is outside the scope of this specification.
						</xhtml:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type CodedContinuousSet&lt;T&gt; alias QSC&lt;T&gt; specializes QSET&lt;T&gt;, CS;</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="IVL" title="Interval" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A set of consecutive values of an ordered base data type.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					Any ordered type can be the basis of an <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>; it does not matter
					whether the base type is discrete or continuous. If the base data type
					is only partially ordered, all elements of <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> must be
					elements of a totally ordered subset of the partially ordered data
					type. 
				</xhtml:p>
                  <xhtml:p>
					For example, <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PQ"/>
                     </xhtml:object> is considered ordered. However the
					ordering of <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PQ"/>
                     </xhtml:object>s is only partial; a total order is only
					defined among comparable quantities (quantities of the same physical
					dimension).  While <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>s between 2 and 4 meter exist, there is no
					<xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> between 2 meters and 4 seconds.
				</xhtml:p>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>s are <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="SET"/>
                     </xhtml:object>s and have all the properties of
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="SET"/>
                     </xhtml:object>s. However, union and difference of <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>s
					may not be <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>s, since the elements of these union and
					difference <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="SET"/>
                     </xhtml:object>s might not be
					contiguous. Intersections of <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>s are always <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>s.
				</xhtml:p>
                  <xhtml:p>
							An interval specifies a set where all values apply simultaneously 
							(e.g. The encounter lasted from January 6th through January 12th).  For situations 
							where only one value within the specified range (e.g. "Take 2-4 tablets"), the 
							<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value=""/>
                     </xhtml:object> type should be used. Intervals arise commonly with time, 
							so intervals of <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TS"/>
                     </xhtml:object> are the most common type encountered. 
							Uses for intervals of <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PQ"/>
                     </xhtml:object> include age &gt; 65, blood 
							pressure &lt; 150 mm Hg, an instruction to keep systolic bp between 80 and 110 mmHg,
							or the width a stain on an electrophoresis gel.
						</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type Interval&lt;T&gt; alias IVL&lt;T&gt; specializes QSET&lt;T&gt; {
              T       low;
              T       high;
              QTY     width;
              T       center;
              BL      lowClosed;
              BL      highClosed;
              T       any;
              IVL&lt;T&gt;  hull(IVL&lt;T&gt; x);
   literal    ST.SIMPLE;
   promotion  IVL&lt;T&gt;  (T x);
   demotion   T;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="IVL_PQ" title="Interval&lt;PhysicalQuantity&gt;" datatypeKind="Binding"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A set of consecutive values of physical quantities.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> has a special literal form which is simply an interval of real numbers, a space,
					and the unit.
				</xhtml:p>
                  <xhtml:p>
					For example: "[0;5] mmol/L" or "&lt;20 mg/dL" are valid literal forms
					of intervals of physical quantities. Note that the generic interval form, e.g.,
					"[50 nm; 2 m]" is also allowed.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
IVL&lt;PQ&gt;.literal ST.SIMPLE {
   IVL&lt;PQ&gt;  : IVL&lt;REAL&gt; " " unit       { $.low.value.equal($1.low);
                                      $.low.unit.equal($3);
                                      $.lowClosed.equal($1.lowClosed);
                                      $.high.value.equal($1.high);
                                      $.high.unit.equal($3);
                                      $.highClosed.equal($1.highClosed); }
            | IVL&lt;REAL&gt;             { $.low.value.equal($1.low);
                                      $.low.unit.equal("1");
                                      $.lowClosed.equal($1.lowClosed);
                                      $.high.value.equal($1.high);
                                      $.high.unit.equal("1");
                                      $.highClosed.equal($1.highClosed); };
   CS unit  : ST                    { $.code.equal($1);
                                      $.codeSystem(2.16.840.1.113883.3.2); };
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:binding>
         <mif:targetDatatype name="IVL"/>
         <mif:argumentDatatype name="PQ"/>
      </mif:binding>
   </mif:datatype>
   <mif:datatype name="IVL_TS" title="Interval&lt;PointInTime&gt;" datatypeKind="Binding"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A set of consecutive values of time-stamps.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					The generic interval data type defines the interval of points in time
					too. However, there are some special considerations about literal
					representations and conversions of intervals of point in time, which
					are specified in this section.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type Interval&lt;PointInTime&gt; alias IVL&lt;TS&gt; specializes IVL&lt;T&gt;;</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:binding>
         <mif:targetDatatype name="IVL"/>
         <mif:argumentDatatype name="TS"/>
      </mif:binding>
   </mif:datatype>
   <mif:datatype name="PIVL" title="PeriodicInterval" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An interval of time that recurs periodically. <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> has
					two properties, <xhtml:object name="propertyRef">
                     <xhtml:param name="propertyName" value="phase"/>
                     <xhtml:param name="datatypeName" value="PIVL"/>
                  </xhtml:object> and <xhtml:object name="propertyRef">
                     <xhtml:param name="propertyName" value="period"/>
                     <xhtml:param name="datatypeName" value="PIVL"/>
                  </xhtml:object>/<xhtml:object name="propertyRef">
                     <xhtml:param name="propertyName" value="frequency"/>
                     <xhtml:param name="datatypeName" value="PIVL"/>
                  </xhtml:object>.
					<xhtml:object name="propertyRef">
                     <xhtml:param name="propertyName" value="phase"/>
                     <xhtml:param name="datatypeName" value="PIVL"/>
                  </xhtml:object> specifies the "interval
					prototype" that is repeated every <xhtml:object name="propertyRef">
                     <xhtml:param name="propertyName" value="period"/>
                     <xhtml:param name="datatypeName" value="PIVL"/>
                  </xhtml:object> or <xhtml:object name="propertyRef">
                     <xhtml:param name="propertyName" value="frequency"/>
                     <xhtml:param name="datatypeName" value="PIVL"/>
                  </xhtml:object>.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					For example, "every eight hours for two minutes" is a <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>
					where the interval's <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="WIDTH"/>
                        <xhtml:param name="datatypeName" value="IVL"/>
                     </xhtml:object> equals 2
					minutes and the <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="period"/>
                        <xhtml:param name="datatypeName" value="PIVL"/>
                     </xhtml:object>
					at which the interval recurs equals 8 hours.
				</xhtml:p>
                  <xhtml:p>
                     <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="phase"/>
                        <xhtml:param name="datatypeName" value="PIVL"/>
                     </xhtml:object> also marks the anchor point
					in time for the entire series of periodically recurring intervals.
					If count is null, the recurrence of a <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> has no
					beginning or ending, but is infinite in both future and past.
				</xhtml:p>
                  <xhtml:p>
					A <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is fully specified when both <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="period"/>
                        <xhtml:param name="datatypeName" value="PIVL"/>
                     </xhtml:object>/<xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="frequency"/>
                        <xhtml:param name="datatypeName" value="PIVL"/>
                     </xhtml:object>
					and <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="phase"/>
                        <xhtml:param name="datatypeName" value="PIVL"/>
                     </xhtml:object> are fully specified.
					The interval MAY be only partially specified where either
					only <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="WIDTH"/>
                        <xhtml:param name="datatypeName" value="IVL"/>
                     </xhtml:object> or only one boundary is
					specified. If count is null, then there is no limit to the number of repetitions.
				</xhtml:p>
                  <xhtml:p>
					For example: "every eight hours for two minutes" specifies only
					<xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="period"/>
                        <xhtml:param name="datatypeName" value="PIVL"/>
                     </xhtml:object> and <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="WIDTH"/>
                        <xhtml:param name="datatypeName" value="IVL"/>
                     </xhtml:object>
					of <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="phase"/>
                        <xhtml:param name="datatypeName" value="PIVL"/>
                     </xhtml:object> but no boundary of the
					<xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="phase"/>
                        <xhtml:param name="datatypeName" value="PIVL"/>
                     </xhtml:object>. Conversely,
					"every eight hours starting at 4 o'clock" specifies only
					<xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="period"/>
                        <xhtml:param name="datatypeName" value="PIVL"/>
                     </xhtml:object>
					and <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="LOW"/>
                        <xhtml:param name="datatypeName" value="IVL"/>
                     </xhtml:object> of <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="phase"/>
                        <xhtml:param name="datatypeName" value="PIVL"/>
                     </xhtml:object>
					but not <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="HIGH"/>
                        <xhtml:param name="datatypeName" value="IVL"/>
                     </xhtml:object> of <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="phase"/>
                        <xhtml:param name="datatypeName" value="PIVL"/>
                     </xhtml:object>.
					"Every eight hours for two minutes starting at 4 o'clock" is fully specified
					since <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="period"/>
                        <xhtml:param name="datatypeName" value="PIVL"/>
                     </xhtml:object>, and both <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="LOW"/>
                        <xhtml:param name="datatypeName" value="IVL"/>
                     </xhtml:object>
					and <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="WIDTH"/>
                        <xhtml:param name="datatypeName" value="IVL"/>
                     </xhtml:object> of <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="phase"/>
                        <xhtml:param name="datatypeName" value="PIVL"/>
                     </xhtml:object>
					are	specified.
				</xhtml:p>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is a generic type whose type
					parameter T is restricted to a <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TS"/>
                     </xhtml:object>
					and its extensions. <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PPD_TS&gt;"/>
                     </xhtml:object> is
					an extension of <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TS"/>
                     </xhtml:object> and therefore can be used to form
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PIVL&lt;PPD_TS&gt;"/>
                     </xhtml:object> values. This approach can model schedules of varying specificity.
				</xhtml:p>
                  <xhtml:p>
					Often times, repeating schedules are only approximately specified. For
					instance "three times a day for ten minutes each" does not usually
					mean a <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="period"/>
                        <xhtml:param name="datatypeName" value="PIVL"/>
                     </xhtml:object> of precisely 8 hours and does
					often not mean exactly 10 minutes intervals. Rather the distance
					between each occurrence may	vary as much as between 3 and 12 hours
					and the <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="WIDTH"/>
                        <xhtml:param name="datatypeName" value="IVL"/>
                     </xhtml:object> of the interval
					may be less than 5 minutes or more than 15 minutes.
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PIVL&lt;PPD_TS&gt;"/>
                     </xhtml:object> can be used to indicate how much
					leeway is allowed or how critical timing is to the specification.
				</xhtml:p>
                  <xhtml:p>
					Sometimes the periodic interval may occur a set number of times.
					For instance, the the schedule might be "2 minutes every 10 minutes 5 times".
					This can be represented with a phase of width 2 min, a period of 10 min, and
					a count of 5. Note that a more common use case is that the period only occurs
					for a limited time period, such as "once a day between June 3 and Jun 10. Though
					this may be represented using the count property, the proper way to implement
					this is to define the timing specification as an intersection between a <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> and 
					an <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="IVL"/>
                     </xhtml:object>. The data type flavor <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value=""/>
                     </xhtml:object> represents
					this common pattern.   
				</xhtml:p>
                  <xhtml:div title="Periodic Intervals as Sets">
						The essential property of a set is that it contains elements. For
						non-aligned s, the contains-property is
						defined as follows. A  t is
						contained in the  if and only if there is an integer
						i for which t plus 
						times i is an element of .
					
					
invariant (PIVL&lt;TS&gt; x, TS t)
      where x.nonNull.and(x.alignment.isNull) {
   x.contains(t).equal(exists(INT i) {
      x.phase.contains(t.plus(x.period.times(i)));
      });
};
						For calendar-aligned s the contains
						property is defined using the calendar-cycle's sum(t,
						n) property that adds n such calendar cycles
						to the time t.
					
					
invariant (PIVL&lt;TS&gt; x, TS t, CalendarCycle c)
      where x.nonNull.and(c.equal(x.alignment)) {
   x.contains(t).equal(exists(INT i) {
      x.phase.contains(c.sum(t, i));
      });
};</xhtml:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;TS T&gt;
type PeriodicInterval&lt;T&gt; alias PIVL&lt;T&gt;
            specializes  QSET&lt;T&gt; {
            IVL&lt;T&gt;       phase;
            PQ           period;
            RTO&lt;INT, PQ.TIME&gt;  frequency;
            INT.POS      count;
            BL           displayFrequencyInd;
            CS           alignment;
            BL           isFlexible;
   literal  ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="TS"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="EIVL" title="EventRelatedPeriodicInterval" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					Specifies a periodic interval of time where the recurrence is based on
					activities of daily living or other important events that are
					time-related but not fully determined by time.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					For example, "one hour after breakfast" specifies the beginning of the
					interval at one hour after breakfast is finished. Breakfast is assumed
					to occur before lunch but is not determined to occur at any specific
					time.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;TS T&gt;
type EventRelatedPeriodicInterval&lt;T&gt; alias EIVL&lt;T&gt;
           specializes  QSET&lt;T&gt; {
           CS           event;
           IVL&lt;PQ&gt;      offset;
  literal  ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="TS"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="QSET_TS" title="ContinuousSet&lt;PointInTime&gt;" datatypeKind="Binding"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A set of intervals constructed to describe specific and potentially complex schedules.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is used to specify the timing of schedules, events, actions and the cyclical validity-patterns
					that may exist for certain kinds of information, such as phone numbers (evening,
					daytime), addresses (so called "snowbirds," residing closer to the equator during
					winter and farther from the equator during summer) and office hours.
				</xhtml:p>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> has the following aspects:
				</xhtml:p>
                  <xhtml:ul>
                     <xhtml:li>
                        <xhtml:object name="itemName">
                           <xhtml:param name="item" value="datatype"/>
                        </xhtml:object>
                        <xhtml:object name="datatypeRef">
                           <xhtml:param name="datatypeName" value="QSET&lt;TS&gt;"/>
                        </xhtml:object>
                        <xhtml:object name="itemName">
                           <xhtml:param name="item" value="datatype"/>
                        </xhtml:object>
                        <xhtml:object name="datatypeRef">
                           <xhtml:param name="datatypeName" value="TS"/>
                        </xhtml:object>
                        <xhtml:object name="itemName">
                           <xhtml:param name="item" value="datatype"/>
                        </xhtml:object>
                     </xhtml:li>
                     <xhtml:li>
                        <xhtml:object name="itemName">
                           <xhtml:param name="item" value="datatype"/>
                        </xhtml:object>
                        <xhtml:object name="datatypeRef">
                           <xhtml:param name="datatypeName" value="PIVL"/>
                        </xhtml:object>
                        <xhtml:object name="itemName">
                           <xhtml:param name="item" value="datatype"/>
                        </xhtml:object>
                     </xhtml:li>
                     <xhtml:li>
                        <xhtml:object name="itemName">
                           <xhtml:param name="item" value="datatype"/>
                        </xhtml:object>
                        <xhtml:object name="datatypeRef">
                           <xhtml:param name="datatypeName" value="LIST&lt;IVL&lt;TS&gt;&gt;"/>
                        </xhtml:object>
                        <xhtml:object name="itemName">
                           <xhtml:param name="item" value="datatype"/>
                        </xhtml:object>
                     </xhtml:li>
                     <xhtml:li>
                        <xhtml:object name="itemName">
                           <xhtml:param name="item" value="datatype"/>
                        </xhtml:object>
                        <xhtml:object name="itemName">
                           <xhtml:param name="item" value="datatype"/>
                        </xhtml:object>
                     </xhtml:li>
                  </xhtml:ul>
                  <xhtml:p>
					In all cases, <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> as a <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="SET&lt;TS&gt;"/>
                     </xhtml:object> is built from one
					of the building blocks of <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSET&lt;TS&gt;"/>
                     </xhtml:object>: <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSU&lt;TS&gt;"/>
                     </xhtml:object>,
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSI&lt;TS&gt;"/>
                     </xhtml:object>, <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSD&lt;TS&gt;"/>
                     </xhtml:object>, <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSC&lt;TS&gt;"/>
                     </xhtml:object>, <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="IVL&lt;TS&gt;"/>
                     </xhtml:object>, 
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PIVL&lt;TS&gt;"/>
                     </xhtml:object> and <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="EIVL&lt;TS&gt;"/>
                     </xhtml:object>.
					Ultimately the building blocks from which all <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> values are constructed
					are <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="IVL&lt;TS&gt;"/>
                     </xhtml:object>, <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSC&lt;TS&gt;"/>
                     </xhtml:object>, <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PIVL"/>
                     </xhtml:object>, and <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="EIVL"/>
                     </xhtml:object>.
					Since <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TS"/>
                     </xhtml:object> can be promoted to <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="IVL&lt;TS&gt;"/>
                     </xhtml:object>, it is 
					also possible to use <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TS"/>
                     </xhtml:object> directly when building a <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>.
				</xhtml:p>
                  <xhtml:p>
				 	This example specifies every other Tuesday in the season from the (US holidays) Memorial Day to Labor Day in the 
				 	years 2002 and 2003. This set of times is built as an expression of the intersection between 3 sets:
				</xhtml:p>
                  <xhtml:ul>
                     <xhtml:li>
                        <xhtml:p>Every other tuesday</xhtml:p>
                     </xhtml:li>
                     <xhtml:li>
                        <xhtml:p>The years 2002 and 2003</xhtml:p>
                     </xhtml:li>
                     <xhtml:li>
                        <xhtml:p>The season between Memorial Day and Labor Day</xhtml:p>
                     </xhtml:li>
                  </xhtml:ul>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type ContinuousSet&lt;PointInTime&gt; alias QSET&lt;TS&gt; specializes QSET&lt;T&gt; {
  literal  ST.SIMPLE;  
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:staticExample itsName="XML">
               <mif:data>
                  <example>
&lt;example xsi:type="QSI_TS"&gt; 
	&lt;!-- intersection, because it is a QSI --&gt;

	&lt;!-- every other Tuesday --&gt;
	&lt;term xsi:type='PIVL_TS' alignment='DW'&gt;
		&lt;phase lowClosed='true' highClosed='false'&gt;
			&lt;low value='20001202'/&gt;
			&lt;high value='20001203'/&gt;
		&lt;/phase&gt;
		&lt;period value='2' unit='wk'/&gt;
	&lt;/term&gt;

	&lt;!-- 2002 and 2003 --&gt;
	&lt;term xsi:type='IVL_TS' lowClosed='true' highClosed='false'&gt;
		&lt;low value='20020101'/&gt;
		&lt;high value='20040101'/&gt;
	&lt;/term&gt;					
	
	&lt;!-- season between Memorial Day and Labor Day --&gt;
	&lt;!-- periodic hull between Memorial day and Labor Day --&gt;
	&lt;term xsi:type='QSP_TS'&gt;
		&lt;first type="QSI_TS"&gt; 
		&lt;!-- memorial day: intersection of mondays and last week of May --&gt;
			&lt;term xsi:type='PIVL_TS'&gt;
				&lt;phase highClosed='false'&gt;
					&lt;low value='19870525'/&gt;
					&lt;high value='19870601'/&gt;
				&lt;/phase&gt;
				&lt;period value='1' unit='a'/&gt;
			&lt;/term&gt;
			&lt;term xsi:type='PIVL_TS'&gt;
				&lt;phase highClosed='false'&gt;
					&lt;low value='19870105'/&gt;
					&lt;high value='19870106'/&gt;
				&lt;/phase&gt;
				&lt;period value='1' unit='wk'/&gt;
			&lt;/term&gt;
		&lt;/first&gt;
		&lt;second type="QSI_TS"&gt;
		&lt;!-- labor day :  intersection of mondays and first week of Sept --&gt;
			&lt;term xsi:type='PIVL_TS'&gt;
				&lt;phase highClosed='false'&gt;
					&lt;low value='19870901'/&gt;
					&lt;high value='19870908'/&gt;
				&lt;/phase&gt;
				&lt;period value='1' unit='a'/&gt;
			&lt;/term&gt;
			&lt;term xsi:type='PIVL_TS'&gt;
				&lt;phase highClosed='false'&gt;
					&lt;low value='19870105'/&gt;
					&lt;high value='19870106'/&gt;
				&lt;/phase&gt;
				&lt;period value='1' unit='wk'/&gt;
			&lt;/term&gt;
		&lt;/second&gt;
	&lt;/term&gt;
&lt;/example&gt;</example>
               </mif:data>
            </mif:staticExample>
         </mif:appInfo>
      </mif:annotations>
      <mif:binding>
         <mif:targetDatatype name="QSET"/>
         <mif:argumentDatatype name="TS"/>
      </mif:binding>
   </mif:datatype>
   <mif:datatype name="GTS" title="GeneralTimingSpecification" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="annotated">
         <mif:targetDatatype name="QSET">
            <mif:argumentDatatype name="TS"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					An alias for <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="QSET"/>
                  </xhtml:object>&lt;<xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="TS"/>
                  </xhtml:object>&gt;. 
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>  is an alias for <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSET"/>
                     </xhtml:object>&lt;<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TS"/>
                     </xhtml:object>&gt;, and the 
					terms may be freely used interchangeably to refer to the type semantically. 
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="ITS-Note">
               <mif:text>
                  <xhtml:p>
							Implementation Technology Specifications MAY not support aliasing the type
							if this is not easily supported in the typing system. In such cases, the specification
							MAY only define types for <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="QSET"/>
                     </xhtml:object>&lt;<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TS"/>
                     </xhtml:object>&gt;, and 
							not support <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> as an alias.
						</xhtml:p>
               </mif:text>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="UVP" title="UncertainValueProbabilistic" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="T" qualifier="parameter"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A generic data type extension used to specify a quantified probability expressing
					the information producer's belief that the given value is correct.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					How the probability number is determined is outside the scope of this
					specification.
				</xhtml:p>
                  <xhtml:p>
					Probabilities are subjective and (as any data value) must be
					interpreted in their individual context; for example, when new
					information is found, the probability might change. Thus, for any
					message, document, or other information representation, the
					information — and particularly the probabilities — reflect
					what the information producer believed was appropriate for the purpose
					and at the time the message or document was created.
				</xhtml:p>
                  <xhtml:p>
					For example, at the beginning of the 2000 baseball season (May), the
					Las Vegas odds makers may have given the New York Yankees a
					probability of 1 in 10 (0.100) of winning the World Series. At the
					time of this writing, the Yankees and Mets have won their respective
					pennants, but the World Series has yet to begin. The probability of
					the Yankees winning the World Series is obviously significantly
					greater at this point in time, perhaps 6 in 10 (0.600). The context,
					and in particular the time of year, make a significant difference.
				</xhtml:p>
                  <xhtml:p>
					Since probabilities are subjective measures of belief, they can be
					stated without being "correct" or "incorrect" per se, let alone
					"precise" or "imprecise." Notably, one does not have to conduct
					experiments to measure a frequency of some outcome in order to specify
					a probability. In fact, whenever statements about individual people or
					events are made, it is not possible to confirm such probabilities with
					"frequentist" experiments.
				</xhtml:p>
                  <xhtml:p>
					Returning to our example, the Las Vegas odds makers can not insist on
					the Yankees and Mets playing 1000 trial games prior to the Series;
					and even if they could, they would not have the fervor of the real Series
					and therefore not be accurate. Instead, the odds makers must derive
					the probability from history and judgment.
				</xhtml:p>
                  <xhtml:p>
					The type T is not formally constrained. In theory, discrete
					probabilities can only be stated for discrete data values. Thus,
					generally <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> SHOULD NOT be used with <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="REAL"/>
                     </xhtml:object>,
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PQ"/>
                     </xhtml:object>, or <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="MO"/>
                     </xhtml:object> values. 
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type UncertainValueProbabilistic&lt;T&gt; alias UVP&lt;T&gt; specializes T {
   REAL  probability;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="NPPD" title="NonParametricProbabilityDistribution"
                 datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="DSET">
            <mif:argumentDatatype name="UVP">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:argumentDatatype>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A set of <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="UVP"/>
                  </xhtml:object> with explicit probabilities.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
				   An <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is a histogram).  All the elements in the set are considered alternatives, and each is assigned a number expressing either the probability that its value is correct or the frequency with which it occurs in a sample.
				</xhtml:p>
                  <xhtml:p>
					The purpose of <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is chiefly
					to support statistical data reporting as it occurs in measurements
					taken from many subjects and consolidated in a histogram. This occurs
					in epidemiology, veterinary medicine and laboratory medicine, but also in
					cost controlling and business process engineering.
				</xhtml:p>
                  <xhtml:p>
					Semantically, the information of a stated value exists in contrast to
					the complement set of unstated possible values. Thus, semantically, an
					<xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> contains <xhtml:b>all</xhtml:b>
					possible values and assigns probabilities to each of them.
				</xhtml:p>
                  <xhtml:p>
					The easiest way to visualize this is a bar chart as shown in this figure:
				</xhtml:p>
                  <xhtml:img imageType="image/gif" src="DT-NPPD-ex1.gif" alt="Example of a Histogram"/>
                  <xhtml:p>
					This example illustrates the probability of selected major league
					baseball teams winning the World Series (prior to the season
					start). Each team is mutually exclusive, and were we to include all of
					the teams, the sum of the probabilities would equal 1 (i.e., it is
					certain that one of the teams will win).
				</xhtml:p>
                  <xhtml:p>
					Just as with <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="UVP"/>
                     </xhtml:object>, the type T is not formally
					constrained, even though there are reasonable and unreasonable
					uses. Typically one would use <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> for unordered types, if
					only a "small" set of possible values is assigned explicit
					probabilities, or if the probability distribution cannot (or should
					not) be approximated with parametric methods. For other cases, one may
					prefer <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PPD"/>
                     </xhtml:object>.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;ANY T&gt;
type NonParametricProbabilityDistribution&lt;T&gt; alias NPPD&lt;T&gt;
      specializes DSET&lt;UVP&lt;T&gt;&gt; {
   UVP&lt;T&gt; mostLikely(INT n);
};</mif:data>
            </mif:otherAnnotation>
            <mif:otherAnnotation type="ITS-Note">
               <mif:text>
                  <xhtml:p>
						Even though semantically <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> assigns probabilities to all
						possible values, not all values need to be represented
						explicitly. Those possible values that are not mentioned
						will have the remaining probability distributed equally over
						all unmentioned values. For example, if the value set is {A; B; C; D}
						but the <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> value states just {(B; 0.5); (C; 0.25)} then the
						remaining probability is 1 - 0.75 = 0.25, which is distributed evenly over
						the complement set: {(A; 0.125); (D; 0.125)}. Semantically, the <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>
						is the union of the stated probability distribution and the unstated
						complement with the remaining probability distributed evenly.
					</xhtml:p>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> SHALL be used where only one value for T may be true. The sum of the probabilities assigned
						to the mentioned values should be &lt;= 1, but due to estimating and rounding inaccuracies, the total 
						MAY actually exceed 1.
					</xhtml:p>
               </mif:text>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="URG" title="UncertainRange" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="T" qualifier="parameter"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					Indicates that the value comes from a range of possible values of an ordered base data type.
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is used where the actual value is unknown, but it is known that the 
					value comes from a known range of possible values (e.g. "Take 2-4 tablets").
					For situations where all values apply simultaneously (e.g. The encounter lasted 
					from January 6th through January 12th) the <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value=""/>
                     </xhtml:object> type should be used.
				</xhtml:p>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> differs from <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PPD"/>
                     </xhtml:object> in that <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PPD"/>
                     </xhtml:object> is used to report a 
					particular value along with an associated distribution of uncertainty for the 
					value, or to report the summary distribution of a set of data, whereas <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> indicates
					that there is a single value that, although unknown, must come from a particular range
					of values. No inference regarding distribution of values can be taken. <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> 
					is often associated with an instruction to perform a particular operation at 
					some point within a given time interval.  
				</xhtml:p>
                  <xhtml:p>
					Any ordered type can be the basis of an <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>; it does not matter
					whether the base type is discrete or continuous. If the base data type
					is only partially ordered, all possible values for the <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> SHALL be
					elements of a totally ordered subset of the partially ordered data
					type.
				</xhtml:p>
                  <xhtml:p>
					For example, <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PQ"/>
                     </xhtml:object> is considered ordered. However the
					ordering of <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PQ"/>
                     </xhtml:object>s is only partial; a total order is only
					defined among comparable quantities (quantities of the same physical
					dimension).  While <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>s between 2 and 4 meter exists, there is no
					<xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> between 2 meters and 4 seconds.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type UncertainRange&lt;T&gt; alias URG&lt;T&gt; specializes T {
   IVL&lt;T&gt;   range;
   BL       couldBe(T value);
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="BN" title="BooleanNonNull" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="BL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains the <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="BL"/>
                  </xhtml:object> so that it is not null.
						This is defined for use within the data types specification where it is not
						appropriate for a null value to be used.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						Values conforming to the BN flavor SHALL NOT have null values.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor BooleanNonNull alias BN constrains BL;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (BN x) {
   x.isNull.not;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="ED.TEXT" title="TextWithReference" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="ED"/>
                  </xhtml:object> so that it  
						only contains plain text. 
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						This is useful because there is sometimes
						a need to allow for references, but the content must be a simple
						string. In addition, no translations are allowed.
					</xhtml:p>
                  <xhtml:p>
						The mediaType of the ED content SHALL be plain text, like the type <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="ST"/>
                     </xhtml:object>
						but a reference is allowed.
					</xhtml:p>
                  <xhtml:p>
						The mediaType of the ED content SHALL be plain text, like the type <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="ST"/>
                     </xhtml:object>
						but a reference is allowed.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor TextWithReference alias ED.TEXT constrains ED;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ED.TEXT x) where x.nonNull {
  x.mediaType.equal("text/plain");
  x.integrityCheck.isNull;
  x.thumbnail.isNull;
  x.compression.isNull;
  x.translation.isEmpty;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="ED.SIGNATURE" title="DigitalSignature" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="ED"/>
                  </xhtml:object> so that the contents are an 
						XML digital Signature according the W3C Signature specifications. 
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						Reference, integrityCheck, thumbnail, compression, and language SHALL be null.
						ED.mediaType SHALL be "text/xml". Translations SHALL be not applicable.
						The content SHALL conform to the w3c XML digital signature specification
						 ([<xhtml:a href="http://www.w3.org/Signature/"/>]).
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor DigitalSignature alias ED.SIGNATURE constrains ED;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ED.SIGNATURE x) where x.nonNull {
  x.reference.isNull;
  x.integrityCheck.isNull;
  x.thumbnail.isNull;
  x.description.isNull;
  x.compression.isNull;
  x.language.isNull;
  x.mediaType.equal("text/xml");
  x.translation.isEmpty;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="ED.IMAGE" title="Image" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="ED"/>
                  </xhtml:object> so that the contents are an 
						image. 
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						The mediaType SHALL start with "image/".
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor Image alias ED.IMAGE constrains ED;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ED.IMAGE x) where x.nonNull {
  x.mediaType.code.subList(0,6).equal("image/");
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="ED.STRUCTURED_TEXT" title="StructuredText" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="ED"/>
                  </xhtml:object> so that the contents are structured
						text. 
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						The mediaType SHALL be "text/x-hl7-text+xml". The contents of the ED SHALL be a valid
						structured text as described by CDA and SPL. No translations are allowed.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor StructuredText alias ED.STRUCTURED_TEXT constrains ED;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ED.STRUCTURED_TEXT x) where x.nonNull {
  x.mediaType.equal("text/x-hl7-text+xml");
  x.translation.isEmpty;
  x.description.notApplicable;
  x.thumbnail.notApplicable;
  x.compression.notApplicable;
  x.reference.notApplicable;
  x.integrityCheck.notApplicable;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="ED.STRUCTURED_TITLE" title="StructuredTitle" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="ED"/>
                  </xhtml:object> so that the contents are a structured title. 
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						The mediaType SHALL be "text/x-hl7-title+xml". The contents of the ED SHALL be a valid
						title as described by CDA and SPL. No translations are allowed.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor StructuredTitle alias ED.STRUCTURED_TITLE constrains ED;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ED.STRUCTURED_TITLE x) where x.nonNull {
  x.mediaType.equal("text/x-hl7-title+xml");
  x.translation.isEmpty;
  x.description.notApplicable;
  x.thumbnail.notApplicable;
  x.compression.notApplicable;
  x.reference.notApplicable;
  x.integrityCheck.notApplicable;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="ST.NT" title="StringNoTranslations" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ST"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="ST"/>
                  </xhtml:object> so that it there are no translations.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						Translations SHALL be empty.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor StringNoTranslations alias ST.NT constrains ST;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ST.NT x) where x.nonNull {
  x.translation.isEmpty;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="ST.SIMPLE" title="StringSimple" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ST.NT"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="ST.NT"/>
                  </xhtml:object> so that it does not specify a language.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						language SHALL be not applicable. 
					</xhtml:p>
                  <xhtml:p>
						The concept of language does not apply to these strings - they are always to be understood as a sequence of 
						characters that identify a concept in some language independent fashion.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor StringSimple alias ST.SIMPLE constrains ST.NT;
</mif:data>
            </mif:otherAnnotation>
            <mif:otherAnnotation type="ITS-Note">
               <mif:text>
                  <xhtml:p>
							This type corresponds to a simple string in most implementation technologies (i.e. xs:string in W3C Schema).
						</xhtml:p>
               </mif:text>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ST.SIMPLE x) where x.nonNull {
  x.language.notApplicable;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="SC.NT" title="CodedStringNoTranslations" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="SC"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="SC"/>
                  </xhtml:object> so that it has no translations.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						Translations SHALL be empty.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor CodedStringNoTranslations alias SC.NT constrains SC;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (SC.NT x) where x.nonNull {
  x.translation.isEmpty;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="CV" title="CodedValue" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="CD"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="CD"/>
                  </xhtml:object> so that there is no translations,
						and only a single concept is allowed.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is used when any reasonable use case will require only a
						single code value. Thus, it should not be used in circumstances where
						multiple alternative codes for a given value are desired. Note that this 
						prevents graceful migration from one code system to another, so <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is not usually
						used outside the data types specification.
					</xhtml:p>
                  <xhtml:p>
						There SHALL be no translations, and there SHALL be no source.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor CodedValue alias CV constrains CD;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (CV x) where x.nonNull {
  x.translation.isEmpty;
  x.source.isNull;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="TEL.URL" title="LocatableResource" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TEL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="TEL"/>
                  </xhtml:object>  so that it points to a locatable resource that returns binary content.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						The URL scheme SHALL be "file", "ftp", "cid", "http", "https" or "nfs". Use "cid" is for soap attachments.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor LocatableResource alias TEL.URL constrains TEL;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TEL.URL x) where x.nonNull {
 x.use.isEmpty.and(
  x.scheme.equal("file").or(
   x.scheme.equal("ftp").or(
    x.scheme.equal("http").or(
     x.scheme.equal("https").or(
      x.scheme.equal("cid").or(
       x.scheme.equal("nfs")))))));
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="TEL.PHONE" title="TelephoneAddress" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TEL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="TEL"/>
                  </xhtml:object>  so it refers to some telephone based
						communication system with a person or organisation.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						The URL scheme SHALL be "tel".
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor TelephoneAddress alias TEL.PHONE constrains TEL;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TEL.PHONE x) where x.nonNull {
  x.scheme.equal("tel");
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="TEL.EMAIL" title="EmailAddress" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TEL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains the <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="TEL"/>
                  </xhtml:object>  type so that it is an SMTP email address.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						The URL scheme SHALL be "mailto:".
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor EmailAddress alias TEL.EMAIL constrains TEL;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TEL.EMAIL x) where x.nonNull {
  x.scheme.equal("mailto");
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="PNXP" title="PersonNamePart" datatypeKind="Flavor" visibility="protected">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ENXP"/>
      </mif:derivedFrom>
   </mif:datatype>
   <mif:datatype name="PN" title="PersonName" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="EN"/>
      </mif:derivedFrom>
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="PNXP"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="EN"/>
                  </xhtml:object> for use when the named Entity
						is a Person. 
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						It constrains <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="ENXP"/>
                     </xhtml:object> used in the parts 
						so that only those entity name parts qualifiers applicable to person names
						are allowed. Since the structure of entity name is mostly determined by the
						requirements of person name, the restriction is very minor.
					</xhtml:p>
                  <xhtml:p>
						The qualifier on any part SHALL NOT include the code "LS".
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor PersonName alias PN constrains EN;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PN x) where x.nonNull {
   forall(ENXP part)
         where x.contains(part) {
      part.qualifier.contains(EntityPartNameQualifier.LS).not;
      }
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="ONXP" title="OrganizationNamePart" datatypeKind="Flavor"
                 visibility="protected">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ENXP"/>
      </mif:derivedFrom>
   </mif:datatype>
   <mif:datatype name="ON" title="OrganizationName" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="EN"/>
      </mif:derivedFrom>
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="ONXP"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="EN"/>
                  </xhtml:object> for use when the named Entity
						is an Organization. 
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						It constrains <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="ENXP"/>
                     </xhtml:object> used in the parts 
						so that only those entity name part types and qualifiers applicable to organization names
						are allowed. 
						Organization names, such as "Health Level Seven, Inc." mostly consist only
						of untyped name parts, prefixes, suffixes, and delimiters.
					</xhtml:p>
                  <xhtml:p>
						The family and given name part types SHALL not be used in the name of an organisation.
					</xhtml:p>
                  <xhtml:p>
						The following qualifiers SHALL not be used in the parts of the name of an organisation: BR, AD, SP, MID, AC, PR, NB, HON. 
						The following codes SHALL not be used in the organisation name use: I, P, R, DN, M.
					</xhtml:p>
                  <xhtml:div title="Examples">ON-examples
							The following is the organization name, "Health Level Seven, Inc." in
							a simple string form:
						&lt;name&gt;Health Level Seven, Inc.&lt;/name&gt;
							And with the legal status "Inc." as a distinguished name part:
						&lt;name&gt;Health Level Seven, &lt;suffix qualifier="LS"&gt;Inc.&lt;/suffix&gt;&lt;/name&gt;</xhtml:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor OrganizationName alias ON constrains EN;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ON x) where x.nonNull {
  forall(ENXP part)
         where x.contains(part) {
      part.type.implies(EntityNamePartType.FAM).not;
      part.type.implies(EntityNamePartType.GIV).not;
      }
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="TNXP" title="TrivialNamePart" datatypeKind="Flavor"
                 visibility="protected">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ENXP"/>
      </mif:derivedFrom>
   </mif:datatype>
   <mif:datatype name="TN" title="TrivialName" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="EN"/>
      </mif:derivedFrom>
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="TNXP"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="EN"/>
                  </xhtml:object>  so that it is effectively a simple string, suitable
						for use as a simple name for things and places.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> with its
						single name part is therefore equivalent to a simple character
						string.
					</xhtml:p>
                  <xhtml:p>
						There SHALL only be one part type, its type SHALL be unknown, and it SHALL have 
						no qualifiers. As a consequence of this, the formatted rendition of then name
						is exactly equal to the one part of the name itself.
					</xhtml:p>
                  <xhtml:p>
						Trivial names are typically used for places and things, such as
						<xhtml:b>Lake Erie</xhtml:b> or <xhtml:b>Washington-Reagan National Airport</xhtml:b>:
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor TrivialName alias TN constrains EN;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TN x) where x.nonNull {
   x.head.nonNull;
   x.head.partType.isNull;
   x.tail.isEmpty;
   x.formatted.equal(x.head);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
            <mif:staticExample itsName="XML">
               <mif:data>
                  <example>
&lt;name&gt;Lake Erie&lt;/name&gt;
&lt;name&gt;Washington-Reagan National Airport&lt;/name&gt;</example>
               </mif:data>
            </mif:staticExample>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="INT.NONNEG" title="IntegerNonNegative" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="INT"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="INT"/>
                  </xhtml:object>  so that it has a value of 0 or greater.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						The value of the INT SHALL be equal or greater than 0 if it is not null.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor IntegerNonNegative alias INT.NONNEG constrains INT;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (INT.NONNEG x) where x.nonNull {
  x.greaterOrEqual(0);
  x.nullFlavor.implies(NullFlavor.NINF).not;
  x.isNegative.not;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="INT.POS" title="IntegerPositive" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="INT.NONNEG"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="INT.NONNEG"/>
                  </xhtml:object>  so that it has a value greater than 0.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						The value of the INT SHALL be greater than 0 if it is not null.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor IntegerPositive alias INT.POS constrains INT.NONNEG;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (INT.POS x) where x.nonNull {
  x.greaterThan(0);
  x.isZero.not;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="PQ.TIME" title="LengthOfTime" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="PQ"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constraints <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="PQ"/>
                  </xhtml:object> so that it has units that describe a period of time.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						The units SHALL be some UCUM code that refers to a measurement of time. Translations are not allowed.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor LengthOfTime alias PQ.TIME constrains PQ;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PQ.TIME x, PQ y) where x.nonNull.and(y.unit.equal("s")) {
  x.isComparableTo(y);
  x.translation.isEmpty;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="TS.DATE" title="Date" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TS"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="TS"/>
                  </xhtml:object>  so that it only contains a date value.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						If the value is not null, there SHALL be 8 or fewer digits, and there can be no timezone. This flavor is specific
						to the gregorian calendar.
					</xhtml:p>
                  <xhtml:p>
						The string literal representation of this form is YYYY[MM[DD]].
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor Date alias TS.DATE constrains TS;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.DATE x) where x.nonNull {
  x.timezone.isNull;
  x.precision.lessOrEqual(8);
  x.calendar.implies(Calendar.GREG);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="TS.DATE.FULL" title="FullDate" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TS.DATE"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="TS.DATE"/>
                  </xhtml:object>  so that it contains a reference to a particular day.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						If the value is not null, there SHALL be 8 digits in the literal form, with no timezone. This flavor is specific
						to the gregorian calendar.
					</xhtml:p>
                  <xhtml:p>
						The string literal representation of this form is YYYYMMDD.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor FullDate alias TS.DATE.FULL constrains TS.DATE;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.DATE.FULL x) where x.nonNull {
  x.precision.equal(8);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="TS.DATETIME" title="DateTime" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TS"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains a <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="TS"/>
                  </xhtml:object>  so that it is not more precise
						than seconds.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						If the value is not null, there SHALL be 14 or less digits, and there can be a timezone. This flavor is specific
						to the gregorian calendar.
					</xhtml:p>
                  <xhtml:p>
						The string literal representation of this form is YYYY[MM[DD[hh[mm[ss]]]]][+/-ZZZZ].
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor DateTime alias TS.DATETIME constrains TS;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.DATETIME x) where x.nonNull {
  x.precision.lessOrEqual(14);
  x.calendar.implies(Calendar.GREG);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="TS.DATETIME.FULL" title="FullDateTime" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TS.DATETIME"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="TS.DATETIME"/>
                  </xhtml:object> so that it contains a reference to a particular second with a timezone.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						If the value is not null, there SHALL be 14 digits in the literal form. There SHALL be a timezone. This flavor
						is specific to the gregorian calendar.
					</xhtml:p>
                  <xhtml:p>
						The string literal representation of this form is YYYYMMDDhhmmss+/-ZZZZ.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor FullDateTime alias TS.DATETIME.FULL constrains TS.DATETIME;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.DATETIME.FULL x) where x.nonNull {
  x.precision.equal(14);
  x.timezone.nonNull;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="TS.INSTANT" title="InstantInTime" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TS.DATETIME"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="TS.DATETIME"/>
                  </xhtml:object> so that it contains a reference to a particular millisecond with a timezone.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						If the value is not null, there SHALL be 17 digits in the literal form. There SHALL be a timezone. This flavor
						is specific to the gregorian calendar.
					</xhtml:p>
                  <xhtml:p>
						The string literal representation of this form is YYYYMMDDhhmmss.zzz+/-ZZZZ.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor InstantInTime alias TS.INSTANT constrains TS.DATETIME;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.DATETIME.FULL x) where x.nonNull {
  x.precision.equal(17);
  x.timezone.nonNull;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="IVL.LOW" title="IntervalLow" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="IVL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="IVL"/>
                  </xhtml:object> so that low is provided and lowClosed is true.
						All other properties are prohibited.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						If the value is not null, low SHALL be provided and lowClosed SHALL be true. high and highClosed are prohibited.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor IntervalLow alias IVL.LOW constrains IVL&lt;T&gt;;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL.LOW x) where x.nonNull {
  x.low.nonNull;
  x.lowClosed;
  x.high.isNull;
  x.highClosed.isNull;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="IVL.HIGH" title="IntervalHigh" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="IVL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="IVL"/>
                  </xhtml:object> so that high is provided and highClosed is true.
						All other properties are prohibited.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						If the value is not null, high SHALL be provided and highClosed SHALL be true. low and lowClosed SHALL be null.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor IntervalHigh alias IVL.HIGH constrains IVL&lt;T&gt;;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL.HIGH x) where x.nonNull {
  x.high.nonNull;
  x.highClosed;
  x.low.isNull;
  x.lowClosed.isNull;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="IVL.WIDTH" title="IntervalWidth" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="IVL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="IVL"/>
                  </xhtml:object> so that width is mandatory and low, lowClosed, high and highClosed are prohibited.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						if the value is not null, Width SHALL be provided. low, lowClosed, high and highClosed  SHALL be null.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor IntervalWidth alias IVL.WIDTH constrains IVL&lt;T&gt;;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL.WIDTH x) where x.nonNull {
  x.width.nonNull;
  x.low.isNull;
  x.lowClosed.isNull;
  x.high.isNull;  /* strictly this is superfluous */
  x.highClosed.isNull;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="URG.LOW" title="UncertainRangeLow" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="URG"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="URG"/>
                  </xhtml:object> so that low and lowClosed are required.
						high and highClosed are prohibited.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						If the value is not null, range.low SHALL be provided and range.lowClosed SHALL be true. range.high and range.highClosed SHALL be null.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor UncertainRangeLow alias URG.LOW constrains URG&lt;T&gt;;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (URG.LOW x) {
  exists(IVL.LOW r) {
    x.range.equal(r);
  }
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="URG.HIGH" title="UncertainRangeHigh" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="URG"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="URG"/>
                  </xhtml:object> so that high and highClosed are required.
						low and lowClosed are prohibited.
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						If the value is not null, high SHALL be provided and highClosed SHALL be true. low and lowClosed SHALL be null.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor UncertainRangeHigh alias URG.HIGH constrains URG&lt;T&gt;;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (URG.HIGH x) where x.unknown {
  exists(IVL.HIGH r) {
    x.range.equal(r);
  }
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="GTS.BOUNDEDPIVL" title="BoundedPeriodicInterval" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="QSI">
            <mif:argumentDatatype name="TS"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
                  <xhtml:object name="itemName">
                     <xhtml:param name="item" value="datatype"/>
                  </xhtml:object> constrains <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="QSI&lt;TS&gt;"/>
                  </xhtml:object> (GTS) so that it only allows an intersection of <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="IVL&lt;TS&gt;"/>
                  </xhtml:object>
						and <xhtml:object name="datatypeRef">
                     <xhtml:param name="datatypeName" value="PIVL&lt;TS&gt;"/>
                  </xhtml:object>. 
					</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
						This allows a system to capture a frequency together with an outer time boundary
						and is useful for things like dosage instructions.
					</xhtml:p>
                  <xhtml:p>
						The Bounded PIVL SHALL contain 2 terms. One of the terms SHALL be an <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="IVL&lt;TS&gt;"/>
                     </xhtml:object> and one
						SHALL be a <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PIVL&lt;TS&gt;"/>
                     </xhtml:object>.
					</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
flavor BoundedPeriodicInterval alias GTS.BOUNDEDPIVL constrains QSI&lt;TS&gt;;
</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (GTS.BOUNDEDPIVL x) where x.nonNull {
  x.dataType.equals(QSI&lt;TS&gt;);
  ((QSI&lt;TS&gt;)x).terms.cardinality.equal(2);
  exists(IVL&lt;TS&gt; y) {((QSI&lt;TS&gt;)x).terms.contains(y)};
  exists(PIVL&lt;TS&gt; z) {((QSI&lt;TS&gt;)x).terms.contains(z)};  
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="PPD" title="ParametricProbabilityDistribution" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="T" qualifier="parameter"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text>
					A generic data type extension specifying uncertainty of quantitative
					data using a distribution function and its parameters. 
				</mif:text>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					Aside from the 
					specific parameters of the distribution, a mean (expected value) and 
					standard deviation is always given to help maintain a minimum layer
					of interoperability if receiving applications cannot process a
					given probability distribution.
				</xhtml:p>
                  <xhtml:p>
					For example, the most common college entrance exam in the United
					States is the SAT, which includes three parts: reading, math and writing. 
					Each part has a minimum score of 400 (no questions answered
					correctly) and a perfect score of 800. In 1998, according to the
					College Board, 1,172,779 college-bound seniors took the test. The mean
					score for the math portion of the test was 512, and the standard
					deviation 112. These parameter values (512, 112), tagged as the normal
					distribution parameters, paint a pretty good picture of test score
					distribution. In most cases, there is no need to specify all
					1-million+ points of data when just 2 parameters will do!
				</xhtml:p>
                  <xhtml:img imageType="image/gif" hl7Id="PPD.example" src="DT-PPD-ex1.gif"
                             alt="Example for a parametric probability distribution"/>
                  <xhtml:p>
					Note that the normal distribution is only one of several distributions
					defined for HL7.
				</xhtml:p>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> SHALL only be applied to value domains that have a continuous distribution
					(<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="REAL"/>
                     </xhtml:object>, <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PQ"/>
                     </xhtml:object>, <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="MO"/>
                     </xhtml:object>, and
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="TS"/>
                     </xhtml:object>). Uncertainty (<xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>) MAY be applied to the numerator
					and denominator of a <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="RTO"/>
                     </xhtml:object> separately.
				</xhtml:p>
                  <xhtml:p>
					Since a <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> specializes T, a simple T value is
					the mean (expected value or first moment) of the probability
					distribution. Applications that cannot deal with distributions will
					take the simple T value neglecting the uncertainty. That simple value
					of type T is also used to standardize the data for computing the
					distribution.
					</xhtml:p>
                  <xhtml:p>
					Where applicable, <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> conforms to
					the ISO <xhtml:b>Guide to the Expression of Uncertainty in
					Measurement</xhtml:b> (GUM) as reflected by NIST publication 1297
					<xhtml:b>Guidelines for Evaluating and Expressing the Uncertainty of NIST
					Measurement Results</xhtml:b>. <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> does not
					describe how uncertainty is to be evaluated but only how it is
					expressed. The concept of "standard uncertainty" as set forth by the
					ISO GUM corresponds to <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="standardDeviation"/>
                        <xhtml:param name="datatypeName" value="PPD"/>
                     </xhtml:object>.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
template&lt;QTY T&gt;
type ParametricProbabilityDistribution&lt;T&gt; alias PPD&lt;T&gt; specializes T {
   T.diffType  standardDeviation;
   CS          distributionType;
   literal  ST.SIMPLE;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PPD&lt;T&gt; x)  {
  x.datatype.implies(INT).not;
  x.datatype.implies(RTO).not;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="PPD_REAL" title="ParametricProbabilityDistribution&lt;RealNumber&gt;"
                 datatypeKind="Binding"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text/>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
					The parametric probability distribution of real numbers is fully defined by
					the generic data type.
					However, there are some special considerations about literal representations
					and conversions of probability distributions over <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="REAL"/>
                     </xhtml:object>s, which are
					specified in this section.
				</xhtml:p>
                  <xhtml:div title="&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Converting a real number (REAL) to an uncertain real number&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(PPD&lt;REAL&gt;)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;">
						When converting a  into a ,
						 is calculated from the
						 value's order of magnitude and
						
						(number of significant digits).
						Let x be a  with
						 n. We can
						determine the order of magnitude e of x as
						e = log10 |x| where e is rounded to
						the next integer that is closer to zero (special case: if x
						is zero, e is zero).  The value of the least significant digit
						l is then l = 10e-n
						and the  σ = l /
						2.
					Examples of standard deviations computed from precision p and order of magnitude eRepresentationxepe - p + 1lσ00(0)1010.51101010.52201010.59901010.5101012010.510010023010.51e+1101111051e+21002121005010e+11002211051.11.102-10.10.0510.110.113-10.10.051.1e+21102211051.1e-20.011-22-30.0010.00051.1e-40.00011-42-50.000010.00000510.1e-40.00101-33-50.000010.0000050.1e-10.01-21-20.010.0050.01e-10.001-31-30.0010.00050.01e-20.0001-41-40.00010.000050.000(0)3-20.010.005</xhtml:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type ParametricProbabilityDistribution&lt;RealNumber&gt; alias PPD&lt;REAL&gt; specializes PPD&lt;T&gt;;</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:binding>
         <mif:targetDatatype name="PPD"/>
         <mif:argumentDatatype name="REAL"/>
      </mif:binding>
   </mif:datatype>
   <mif:datatype name="PPD_PQ" title="ParametricProbabilityDistribution&lt;PhysicalQuantity&gt;"
                 datatypeKind="Binding"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text/>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is constructed from <xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PPD"/>
                     </xhtml:object>. However,
					recognizing that the <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="unit"/>
                        <xhtml:param name="datatypeName" value="PQ"/>
                     </xhtml:object> can be factored
					from the boundaries, we add additional semantics and a
					separate literal form. The additional view of a <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object>
					is a probability distribution over real numbers with one unit.
				</xhtml:p>
                  <xhtml:p>
					The unit applies to both mean and <xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="standardDeviation"/>
                        <xhtml:param name="datatypeName" value="PPD"/>
                     </xhtml:object>.
				</xhtml:p>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type ParametricProbabilityDistribution&lt;PhysicalQuantity&gt; alias PPD&lt;PQ&gt; specializes PPD&lt;T&gt; {
   PPD&lt;REAL&gt; value;
   CS  unit;
};</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PPD&lt;PQ&gt; x)
      where x.nonNull {
   x.value.nonNull;
   ((REAL)x.value).equal(((PQ)x).value);
   x.unit.equal(((PQ)x).unit);
   x.value.standardDeviation.equal(x.standardDeviation.value);
   x.standardDeviation.unit.equal(x.unit);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:binding>
         <mif:targetDatatype name="PPD"/>
         <mif:argumentDatatype name="PQ"/>
      </mif:binding>
   </mif:datatype>
   <mif:datatype name="PPD_TS" title="ParametricProbabilityDistribution&lt;PointInTime&gt;"
                 datatypeKind="Binding"
                 visibility="public">
      <mif:annotations>
         <mif:documentation>
            <mif:definition>
               <mif:text/>
            </mif:definition>
            <mif:designComments>
               <mif:text>
                  <xhtml:p>
                     <xhtml:object name="itemName">
                        <xhtml:param name="item" value="datatype"/>
                     </xhtml:object> is fully defined by the generic data type.
					<xhtml:object name="propertyRef">
                        <xhtml:param name="propertyName" value="standardDeviation"/>
                        <xhtml:param name="datatypeName" value="PPD"/>
                     </xhtml:object> is of type TS.diffType, which is a duration (a
					<xhtml:object name="datatypeRef">
                        <xhtml:param name="datatypeName" value="PQ"/>
                     </xhtml:object> in the dimension of time).
				</xhtml:p>
                  <xhtml:div title="Converting  to ">
						When converting a  into a ,
						 is
						calculated from the  value's order of magnitude
						and precision (number of significant digits) such that two
						s span the maximal time range of the digits not
						specified. For example, in 20000609 the unspecified digits are hour of
						the day and lower. All these digits together span a duration of 24
						hours, and thus,  is 12 h, or half the span from
						20000609000000.0000... up to 20000609999999.9999... (= 20000610).
					
						This rule is different from that specified for 
						in that the range of uncertainty lies 
						above the time value specified. This is to go with the common sense judgment 
						that June 9th spans all day of June 9th with noon as the center, not midnight.
					</xhtml:div>
               </mif:text>
            </mif:designComments>
            <mif:otherAnnotation type="DTDL">
               <mif:data>
type ParametricProbabilityDistribution&lt;PointInTime&gt; alias PPD&lt;TS&gt; specializes PPD&lt;T&gt;;</mif:data>
            </mif:otherAnnotation>
         </mif:documentation>
      </mif:annotations>
      <mif:binding>
         <mif:targetDatatype name="PPD"/>
         <mif:argumentDatatype name="TS"/>
      </mif:binding>
   </mif:datatype>
</mif:datatypeModelLibrary>