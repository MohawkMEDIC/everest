<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MARC.Everest</name>
    </assembly>
    <members>
        <member name="T:MARC.Everest.Attributes.FlavorMapAttribute">
            <summary>
            Indicates a flavor of the current type and which real concrete <see cref="T:System.Type">Type</see> it maps to.
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.FlavorMapAttribute.FlavorId">
            <summary>
            Gets or sets the id of the flavor of the current type the map is for.
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.FlavorMapAttribute.Implementer">
            <summary>
            Gets or sets the concrete <see cref="T:System.Type">Type</see> that implements the flavor.
            </summary>
        </member>
        <member name="T:MARC.Everest.Attributes.InteractionResponseAttribute">
            <summary>
            Summary of InteractionResponse
            </summary>
        </member>
        <member name="T:MARC.Everest.Attributes.PropertyAttribute">
            <summary>
            Indicates how a rendering component should treat the name, conformance, validation of a bound property when rendering.
            </summary>
        </member>
        <member name="M:MARC.Everest.Attributes.PropertyAttribute.#ctor">
            <summary>
            Creates a new instance of the property attribute
            </summary>
        </member>
        <member name="T:MARC.Everest.Attributes.PropertyAttribute.AttributeAttributeType">
            <summary>
            The type of attribute represented by this class.
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.PropertyAttribute.AttributeAttributeType.Structural">
            <summary>
            The attribute is a structural attribute.
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.PropertyAttribute.AttributeAttributeType.NonStructural">
            <summary>
            The attribute is a non structural attribute.
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.PropertyAttribute.AttributeAttributeType.Traversable">
            <summary>
            The attribute represents a traversable connection to another structure
            </summary>
        </member>
        <member name="T:MARC.Everest.Attributes.PropertyAttribute.AttributeConformanceType">
            <summary>
            Identifies levels of conformance that an attribute can employ.
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.PropertyAttribute.AttributeConformanceType.Mandatory">
            <summary>
            A value must be supplied and must not be null (no null flavors are permitted)
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.PropertyAttribute.AttributeConformanceType.Required">
            <summary>
            The property must be supported, but data is supplied only when avaialable. (min occurs is 0)
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.PropertyAttribute.AttributeConformanceType.Populated">
            <summary>
            A value must be supplied (min occurs is 1) but a null flavor can be used
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.PropertyAttribute.AttributeConformanceType.Optional">
            <summary>
            Implementers may choose to not support this concept
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.PropertyAttribute.NamespaceUri">
            <summary>
            Gets or sets the namespace of URI of the property
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.PropertyAttribute.SupplierDomain">
            <summary>
            Gets or sets an identifier of a value set to which valid codes are members.
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.PropertyAttribute.PropertyType">
            <summary>
            Gets or sets the attribute type of this property.
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.PropertyAttribute.Type">
            <summary>
            Gets or sets a <see cref="T:System.Type">System.Type</see> that is used when 
            choosing which <see cref="T:MARC.Everest.Attributes.PropertyAttribute">PropertyAttribute</see> 
            to use. This <see cref="T:System.Type">Type</see> will be compared to the type of object in the property.
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.PropertyAttribute.InteractionOwner">
            <summary>
            Gets or sets a <see cref="T:System.Type"/> that is signifies the interaction this type must be a member of when determining if the current traversal path should be considered to be rendered into the formatter 
            </summary>
            <remarks>
            This is added to support the fact that HL7v3 allows certain traversals to occur within certain interactions
            </remarks>
        </member>
        <member name="P:MARC.Everest.Attributes.PropertyAttribute.Conformance">
            <summary>
            Gets or sets the minimum required conformance of the property when being serialized. If this conformance
            is not met, an exception will be thrown.
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.PropertyAttribute.MinOccurs">
            <summary>
            Gets or sets the minimum number of occurences of an element in an array. This value is only used for Arrays.
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.PropertyAttribute.MaxOccurs">
            <summary>
            Gets or sets the maximum number of occurences of an element in an array. If the array contains more elements, a valiation error occurs. This value is only used for Arrays.
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.PropertyAttribute.MinLength">
            <summary>
            Gets or sets the minimum length of the default property within a PDV
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.PropertyAttribute.MaxLength">
            <summary>
            Gets or sets the maximum length of the default property within a PDV
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.PropertyAttribute.ImposeFlavorId">
            <summary>
            Gets or sets the HL7 flavor to impose 
            Identifies what flavor to impose on the object. For example, an ImposeFlavorId of "BUS" on an II typed
            property dictates that the II.BUS rules should be applied against the property
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.PropertyAttribute.DefaultUpdateMode">
            <summary>
            Gets or sets the UpdateMode that is used if one is not explicitly specified.
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.PropertyAttribute.IgnoreTraversal">
            <summary>
            Gets or sets value that specifies whether or not to ignore the traversal, ie: render the property in place of the containing type.
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.PropertyAttribute.FixedValue">
            <summary>
            Gets the fixed value for the object
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.PropertyAttribute.SortKey">
            <summary>
            Sort order for the property
            </summary>
        </member>
        <member name="T:MARC.Everest.Attributes.EnumerationAttribute">
            <summary>
            Indicates how to represent an enumeration or field value when graphing to an ITS.
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.EnumerationAttribute.Value">
            <summary>
            Gets or sets the resulting value what will appear in the output of the ITS when graphed.
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.EnumerationAttribute.SupplierDomain">
            <summary>
            Gets or sets the supplier domain that this value belongs to
            </summary>
        </member>
        <member name="T:MARC.Everest.Attributes.FlavorAttribute">
            <summary>
            Indicates that a method should be used to validate an instance of the named flavor. Note that the 
            method is expected to be a <see cref="T:System.Predicate">Predicate&lt;Type&gt;</see>
            </summary>
        </member>
        <member name="M:MARC.Everest.Attributes.FlavorAttribute.#ctor">
            <summary>
            Creates a new instance of the FlavorAttribute class
            </summary>
        </member>
        <member name="M:MARC.Everest.Attributes.FlavorAttribute.#ctor(System.String)">
            <summary>
            Creates a new instance of the FlavorAttribute class with the specified parameters
            </summary>
        </member>
        <member name="T:MARC.Everest.Attributes.InteractionAttribute">
            <summary>
            Identifies that a particular structure represents a complete HL7v3 interaction with transport, controlAct and payload wrappers
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.InteractionAttribute.TriggerEvent">
            <summary>
            Gets or sets the trigger event for this interaction.
            </summary>
        </member>
        <member name="T:MARC.Everest.Attributes.MarkerAttribute">
            <summary>
            Indicates a property as marking a special HL7 property such as updateMode, classCode, etc...
            </summary>
        </member>
        <member name="T:MARC.Everest.Attributes.MarkerAttribute.MarkerAttributeType">
            <summary>
            Indicates the types of markers supported.
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.MarkerAttribute.MarkerAttributeType.Flavor">
            <summary>
            The property identifies the flavour of the type.
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.MarkerAttribute.MarkerAttributeType.NullFlavor">
            <summary>
            The property identifies the NullFlavor attribute.
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.MarkerAttribute.MarkerAttributeType.UpdateMode">
            <summary>
            The property identifies the update mode attribute.
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.MarkerAttribute.MarkerAttributeType.ContextConduction">
            <summary>
            The property identifies the context conduction attribute.
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.MarkerAttribute.MarkerAttributeType.ClassCode">
            <summary>
            The property identifies the class code attribute.
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.MarkerAttribute.MarkerAttributeType.TypeCode">
            <summary>
            The property identifies the type code attribute.
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.MarkerAttribute.MarkerAttributeType.DeterminerCode">
            <summary>
            The property identifies the determiner code attribute.
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.MarkerAttribute.MarkerAttributeType.Data">
            <summary>
            Property represents the data within the datatype.
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.MarkerAttribute.MarkerType">
            <summary>
            Gets or sets the type of marker identified.
            </summary>
        </member>
        <member name="T:MARC.Everest.Attributes.NamedAttribute">
            <summary>
            Base attribute that represents a property, class, etc... that has a corresponding RIM name.
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.NamedAttribute.Name">
            <summary>
            Gets or sets the RMIM name of this attribute.
            </summary>
        </member>
        <member name="M:MARC.Everest.Attributes.NamedAttribute.#ctor">
            <summary>
            Creates a new instance of the named attribute.
            </summary>
        </member>
        <member name="M:MARC.Everest.Attributes.NamedAttribute.#ctor(System.String)">
            <summary>
            Creates a new instance of the named attribute, supplying the <paramref name="name"/>.
            </summary>
            <param name="name">The RMIM name of the attribute.</param>
        </member>
        <member name="T:MARC.Everest.Attributes.PropertyCollapseAttribute">
            <summary>
            Property collapsing attribute
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.PropertyCollapseAttribute.Order">
            <summary>
            Gets or sets the order in which this collapsed member should be rendered
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.PropertyCollapseAttribute.FixedAttributeValues">
            <summary>
            Gets or sets a list of fixed attribute values in the format
            ATTRIBUTE=VALUE;ATTRIBUTE=VALUE
            </summary>
        </member>
        <member name="T:MARC.Everest.Attributes.RealizationAttribute">
            <summary>
            When used, this attributes marks all the RIM concepts that a particular entity 
            "realizes".
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.RealizationAttribute.OwnerClass">
            <summary>
            The type that owns this realization 
            </summary>
        </member>
        <member name="T:MARC.Everest.Attributes.StateAttribute">
            <summary>
            Identifies a valid named state that the bound property can be "in"
            </summary>
        </member>
        <member name="M:MARC.Everest.Attributes.StateAttribute.#ctor">
            <summary>
            Create a new instance of the state object
            </summary>
        </member>
        <member name="M:MARC.Everest.Attributes.StateAttribute.#ctor(System.String)">
            <summary>
            Create a new instance of the state object with the named state
            </summary>
            <param name="Name">The name of the state</param>
        </member>
        <member name="T:MARC.Everest.Attributes.StateTransitionAttribute">
            <summary>
            Identifies a valid state transition for a property
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.StateTransitionAttribute.FromState">
            <summary>
            The name of the state that a state can be entered from
            </summary>
        </member>
        <member name="M:MARC.Everest.Attributes.StateTransitionAttribute.#ctor">
            <summary>
            Create a new instance of the state transition attribute
            </summary>
        </member>
        <member name="M:MARC.Everest.Attributes.StateTransitionAttribute.#ctor(System.String,System.String)">
            <summary>
            Create a new instance of the state transition attribute with given from state and new state
            </summary>
            <param name="FromState">The state that the transition starts in</param>
            <param name="Name">The name of the state the transition may go to</param>
        </member>
        <member name="T:MARC.Everest.Attributes.StructureAttribute">
            <summary>
            Identifies a class or structure as belonging to an RMIM structure. Without this attribute, classes
            and structures are "not" graphable to an ITS
            </summary>
        </member>
        <member name="M:MARC.Everest.Attributes.StructureAttribute.#ctor">
            <summary>
            Namespace uri
            </summary>
        </member>
        <member name="T:MARC.Everest.Attributes.StructureAttribute.StructureAttributeType">
            <summary>
            Identifies the type of structures that can be represented in the RMIM class
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.StructureAttribute.StructureAttributeType.MessageType">
            <summary>
            The structure represents a message structure
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.StructureAttribute.StructureAttributeType.DataType">
            <summary>
            The structure represents a data type
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.StructureAttribute.StructureAttributeType.Interaction">
            <summary>
            The structure represents an interaction, which can be used as an entry point 
            for formatting.
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.StructureAttribute.StructureAttributeType.ValueSet">
            <summary>
            Structure represents a value set or a fixed set of
            values that can be selected
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.StructureAttribute.StructureAttributeType.ConceptDomain">
            <summary>
            Structure represents a concept domain or a fixed set of
            concepts that can be selected
            </summary>
        </member>
        <member name="F:MARC.Everest.Attributes.StructureAttribute.StructureAttributeType.CodeSystem">
            <summary>
            Structure represents a code system or a set of codes
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.StructureAttribute.NamespaceUri">
            <summary>
            Gets or sets the namespace of this data type
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.StructureAttribute.StructureType">
            <summary>
            Identifies the type of structure this represents.
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.StructureAttribute.IsEntryPoint">
            <summary>
            When true, signals that the specified structure can be used as the root of serialization
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.StructureAttribute.CodeSystem">
            <summary>
            Code system
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.StructureAttribute.DefaultTemplateType">
            <summary>
            Default template type
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.StructureAttribute.Model">
            <summary>
            The name of the model that contained the file
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.StructureAttribute.Publisher">
            <summary>
            Gets the name of the publishing group/organization
            </summary>
        </member>
        <member name="T:MARC.Everest.Attributes.TypeMapAttribute">
            <summary>
            The TypeMap attribute overcomes the change of names of types
            from R1 to R2 datatypes that have no meaning other than name changes.
            For example, a QSI is nothing more than an SXPR with all components
            having the operator Intersect. Likewise a QSU is an SXPR with all 
            components having operator Union
            </summary>
        </member>
        <member name="P:MARC.Everest.Attributes.TypeMapAttribute.ArgumentType">
            <summary>
            Identifies the argument type that must be supplied to trigger the map
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.ConnectionStringParser">
            <summary>
            Parser for connection strings
            </summary>
            <remarks>
            <para>This class is commonly used by connectors within the Everest Framework to facilitate the parsing
            of connection strings. Connection strings are in the format:</para>
            <code>key=value;key=value</code>
            <para>This static class provides mechanisms for parsing such strings into a dictionary of key/value pairs</para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.Connectors.ConnectionStringParser.ParseConnectionString(System.String)">
            <summary>
            Parse a connection string.
            </summary>
            <param name="connectionString">The connection string to parse.</param>
            <returns>The keys and values for the keys.</returns>
        </member>
        <member name="T:MARC.Everest.Connectors.ICodeDomStructureFormatter">
            <summary>
            Identifies a structured formatter that generates assemblies "on the fly"
            </summary>
            <remarks>
            <para>
            CodeDom structure formatters are different from regular <see cref="T:MARC.Everest.Connectors.IStructureFormatter"/>
            in that they use CodeDom (or other dynamic "discovery" mechanism to generate code in memory which is compiled
            when the first instance is passed through the formatter.
            </para>
            <para>
            This class exposes the <see cref="F:BuildCache(Type[])"/> method which is intended to force the CodeDom formatter
            to build its code in memory and compile one or more assemblies. These assemblies can then be referenced (and saved
            for later use) by the developer at runtime.
            </para>
            </remarks>
        </member>
        <member name="P:MARC.Everest.Connectors.ICodeDomStructureFormatter.GenerateInMemory">
            <summary>
            If true, generate the assembly in memory
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.ICodeDomStructureFormatter.GeneratedAssemblies">
            <summary>
            Get a list of assemblies this formatter has generated
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.ICodeDomStructureFormatter.Parse(System.IO.Stream,System.Reflection.Assembly)">
            <summary>
            Parse an object from a stream using only interactions from the specified 
            assembly.
            </summary>
            <param name="a">The assembly from which to qualify the root element</param>
            <param name="s">The stream from which to parse</param>
            <remarks>
            <para>When using formatter, it is important to remember that the formatter
            by default will scan all assemblies in the current app domain. This may
            result in undesirable effects when formatting within an application that
            has multiple RMIM assemblies loaded (the formatter will just use the first
            </para>
            <para>This method override of Parse allows developers to specify which
            RMIM assembly they would like data parsed from.</para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.Connectors.ICodeDomStructureFormatter.BuildCache(System.Type[])">
             <summary>
             Build a cache for the specified types
             </summary>
             <example>
             <code lang="cs" title="Pre-building assemblies for formatting">
             <![CDATA[
             // Create an instance of the primary formatter
             ICodeDomStructureFormatter formatter = new XmlIts1Formatter();
             formatter.GenerateInMemory = false;
            
             // Assign a graph aide
            formatter.GraphAides.Add(new DatatypeFormatter() { CompatibilityMode = DatatypeFormatterCompatibilityMode.ClinicalDocumentArchitecture
             });
            
             // Let the user know we're initializing
            Console.WriteLine("Please Wait, Initializing...");
            
             // Build the type cache
            formatter.BuildCache(new Type[] { typeof(ClinicalDocument) });
            
             // Continue with the program here
            Console.WriteLine("Initialized, Program is continuing...");
             ]]>
             </code>
             </example>
        </member>
        <member name="T:MARC.Everest.Connectors.IConnector">
            <summary>
            The IConnector interface responsible for defining connector interfaces to/from external systems.
            </summary>
            <remarks>
            IConnectors follow one of the following patterns:
            <list type="table">
                <listheader>
                    <term>Pattern</term>
                    <description>Description</description>
                </listheader>
                <item>
                    <term><see cref="T:MARC.Everest.Connectors.IListenWaitConnector"/></term>    
                    <description>Represents a connector that can actively listen for messages
                    from solicitors and processes the message. No assumption is made that the 
                    connector can (or should) send a response. An example of a Listen/Wait connector
                    is a Queue listener</description>
                    
                </item>
                <item>
                    <term><see cref="T:MARC.Everest.Connectors.IListenWaitRespondConnector"/></term>    
                    <description>Represents a connector that can actively listen for messages
                    from solicitors, process the message and send a response to the solicitor. 
                    An example of a Listen/Wait/Respond connector is an Http connector</description>
                </item>
                <item>
                    <term><see cref="T:MARC.Everest.Connectors.ISendingConnector"/></term>    
                    <description>Represents a connector that can broadcast message instances to
                    the destination. This connector provides no facility to solicit (ie: get a response)
                    from the destination</description>
                </item>
                <item>
                    <term><see cref="T:MARC.Everest.Connectors.ISendReceiveConnector"/></term>    
                    <description>Represents a connector that can solicit data from the remote 
                    endpoint. This connector provides mechanisms for sending, waiting and receiving
                    messages in asynchronous and synchronous modes</description>
                </item>
            </list>
            </remarks>
        </member>
        <member name="P:MARC.Everest.Connectors.IConnector.ConnectionString">
            <summary>
            Gets or sets the connection string property.
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.IConnector.Open">
            <summary>
            Opens or validates a connection with the remote system as defined by <paramref name="connectionString"/>. 
            </summary>
            <remarks>
            Note that in some connector infrastructures this will merely verify the connection can be opened, and 
            the actual opening of the connection may be withheld until a send or receive is executed.
            </remarks>
        </member>
        <member name="M:MARC.Everest.Connectors.IConnector.Close">
            <summary>
            Closes any active connection with the remote system
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.IConnector.IsOpen">
            <summary>
            Returns true if a channel is currently opened
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.IDatatypeStructureFormatter">
            <summary>
            Identifies a class that renders datatypes
            </summary>
            <remarks>
            This interface includes the ability to programatically determine which properties
            from the Everest Datatypes classes are supported by the particular formatter
            </remarks>
        </member>
        <member name="M:MARC.Everest.Connectors.IDatatypeStructureFormatter.GetSupportedProperties(System.Type)">
             <summary>
             Get the supported properties for the specified datatype
             </summary>
             <example>
             <code lang="cs" title="Getting supported properties">
             <![CDATA[
             // Create the data type formatter
            IDatatypeStructureFormatter datatypeFormatter = new DatatypeFormatter();
            
             // Get supported properties for ED
            var supportedProperties = datatypeFormatter.GetSupportedProperties(typeof(ED));
            
             // Determine if Translation is supported
            bool isTranslationSupported = Array.Exists(supportedProperties, o => o.Name == "Translation");
            Console.WriteLine("ED.Translation is supported? {0}", isTranslationSupported);
             ]]>
             </code>
             </example>
        </member>
        <member name="T:MARC.Everest.Connectors.IFilteredConnector">
            <summary>
            Represents a connector that retrieves filtered data from an endpoint (like a 
            database system)
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.IFilteredConnector.Filter">
            <summary>
            A prototype class that represents data to filter
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.IFormattedConnector">
             <summary>
             Represents a <see cref="T:MARC.Everest.Connectors.IConnector"/> that sends or receives data "over the wire" using a 
             <see cref="T:MARC.Everest.Connectors.IStructureFormatter"/> for serialization 
             of the message.
             </summary>
             <remarks>
             <para>This interface is implemented by connectors that exchange data with external systems
             using HL7v3. If a connector implementation does not need to send data using V3 (ie: does not 
             need a v3 Formatter instance) then it will most likely not need to implement this interface</para>
             </remarks>
             <example>
             <code lang="cs">
             <![CDATA[
             // Create the formatter
            XmlIts1Formatter itsFormatter = new XmlIts1Formatter();
            itsFormatter.ValidateConformance = false;
            itsFormatter.GraphAides.Add(new DatatypeFormatter()
                {
                    ValidateConformance = false,
                    CompatibilityMode = DatatypeFormatterCompatibilityMode.Universal
                }
            );
            
             // Setup connector
             IFormattedConnector connector = new WcfClientConnector();
             connector.Formatter = itsFormatter;
             ]]>
             </code>
             </example>
        </member>
        <member name="P:MARC.Everest.Connectors.IFormattedConnector.Formatter">
            <summary>
            Get or set the formatter this connector uses to format the message.
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.IFormatterGraphResult">
            <summary>
            Represents a structure that contains the results of a graph operation
            </summary>
            <remarks>
            <para>
            This interface has been added to Everest to facilitate clean up of the formatting
            architecture within previous versions of Everest. 
            </para>
            <para>
            Whenever a formatter's Graph method is called, it will return a populated <see cref="T:MARC.Everest.Connectors.IFormatterGraphResult"/>
            instance with the overall result of graphing and the details of the graph.
            </para>
            </remarks>
        </member>
        <member name="P:MARC.Everest.Connectors.IFormatterGraphResult.Details">
            <summary>
            Gets the details of the graphing operation
            </summary>
            <remarks>
            The details array contain a list of <see cref="T:MARC.Everest.Connectors.IResultDetail"/> instances
            that describe the outcome of the formatter operation. These classes have been architected similar to 
            exceptions in that the content of the class along with the type of class determines the meaning of the 
            result detail.
            </remarks>
            <seealso cref="T:MARC.Everest.Connectors.ResultDetail"/>
            <seealso cref="T:MARC.Everest.Connectors.InsufficientRepetitionsResultDetail"/>
            <seealso cref="T:MARC.Everest.Connectors.MandatoryElementMissingResultDetail"/>
            <seealso cref="T:MARC.Everest.Connectors.RequiredElementMissingResultDetail"/>
            <seealso cref="T:MARC.Everest.Connectors.FixedValueMisMatchedResultDetail"/>
            <seealso cref="T:MARC.Everest.Connectors.VocabularyIssueResultDetail"/>
            <seealso cref="T:MARC.Everest.Connectors.UnsupportedDatatypePropertyResultDetail"/>
        </member>
        <member name="P:MARC.Everest.Connectors.IFormatterGraphResult.Code">
            <summary>
            Gets the result code that describes the overall result of the graph operation
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.IFormatterParseResult">
            <summary>
            Represents a formatter parse result
            </summary>
            <remarks>
            <para>
            This interface has been added to Everest to facilitate clean up of the formatting
            architecture within previous versions of Everest. 
            </para>
            <para>
            Whenever a formatter's Parse method is called, it will return a populated <see cref="T:MARC.Everest.Connectors.IFormatterParseResult"/>
            instance with the overall result of parsing (the code), the details of the graph and the parsed structure
            </para>
            </remarks>
        </member>
        <member name="P:MARC.Everest.Connectors.IFormatterParseResult.Details">
            <summary>
            Gets the details of the parse operation
            </summary>
            <remarks>
            The details array contain a list of <see cref="T:MARC.Everest.Connectors.IResultDetail"/> instances
            that describe the outcome of the formatter operation. These classes have been architected similar to 
            exceptions in that the content of the class along with the type of class determines the meaning of the 
            result detail.
            </remarks>
            <seealso cref="T:MARC.Everest.Connectors.ResultDetail"/>
            <seealso cref="T:MARC.Everest.Connectors.InsufficientRepetitionsResultDetail"/>
            <seealso cref="T:MARC.Everest.Connectors.MandatoryElementMissingResultDetail"/>
            <seealso cref="T:MARC.Everest.Connectors.RequiredElementMissingResultDetail"/>
            <seealso cref="T:MARC.Everest.Connectors.FixedValueMisMatchedResultDetail"/>
            <seealso cref="T:MARC.Everest.Connectors.VocabularyIssueResultDetail"/>
            <seealso cref="T:MARC.Everest.Connectors.UnsupportedDatatypePropertyResultDetail"/>
        </member>
        <member name="P:MARC.Everest.Connectors.IFormatterParseResult.Code">
            <summary>
            Gets the code that summarizes the operation's outcome
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.IFormatterParseResult.Structure">
            <summary>
            Gets the IGraphable that represents the actual structure that was parsed
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.IListenWaitConnector">
             <summary>
             Represents a <see cref="T:MARC.Everest.Connectors.IReceivingConnector"/> connector that is persistant in memory and can "listen" for data
             over a transport channel
             </summary>
             <seealso cref="T:MARC.Everest.Connectors.IListenWaitRespondConnector"/>
             <example>
             
             <code lang="cs" title="Running an IListenWaitConnector in synchronous mode">
             <![CDATA[
             // Setup the formatter
            XmlIts1Formatter fmtr = new XmlIts1Formatter();
            fmtr.GraphAides.Add(new DatatypeFormatter() 
            { 
                ValidateConformance = false 
            });
            fmtr.ValidateConformance = false;
            
             // Prepare the connection string
            FileConnectionStringBuilder fsb = new FileConnectionStringBuilder()
            {
                Directory = "C:\\temp",
                Pattern = "*.xml"
            };
            
             // Create the connector
            IListenWaitConnector connector = new FileListenConnector(fsb.GenerateConnectionString());
             // Set the formatter
            ((IFormattedConnector)connector).Formatter = fmtr;
            
            try
            {
                // Open the channel and start accepting messages
                connector.Open();
                connector.Start();
            
                // Wait until a message is available
                IReceiveResult result = connector.Receive();
            
                // Output the type
                Console.WriteLine(result.Structure.ToString());
            }
            finally
            {
                connector.Close();
                connector.Dispose();
            }
             ]]>
             </code>
             
             <code lang="cs" title="Running an IListenWaitConnector in Asynchronous mode">
             <![CDATA[
            static void Main(string[] args)
            {
            
                // Good practice to force load
                Assembly.Load(new AssemblyName("MARC.Everest.RMIM.UV.NE2008"));
            
                // Setup the formatter
                XmlIts1Formatter fmtr = new XmlIts1Formatter();
                
                // Formatter & Connector Connection String Truncated to save space
            
                // Create the connector
                IListenWaitConnector connector = new FileListenConnector(fsb.GenerateConnectionString());
            
                // Set the formatter
                ((IFormattedConnector)connector).Formatter = fmtr;
            
                try
                {
                    // Open the channel and start accepting messages
                    connector.Open();
            
                    // Set the event handler
                    connector.MessageAvailable += new 
                           EventHandler<UnsolicitedDataEventArgs>(
                               connector_MessageAvailable
                           );
            
                    // Start listening
                    connector.Start();
            
                    Console.WriteLine("Drop a message in the directory!");
                    Console.WriteLine("Press any key to stop listening");
                    Console.ReadKey();
                }
                finally
                {
                    connector.Close();
                    connector.Dispose();
                }
            }
            
             /// <summary>
             /// Process the message
             /// </summary>
            static void connector_MessageAvailable(object sender, UnsolicitedDataEventArgs e)
            {
                // Receive the result message
                IReceiveResult result = (sender as IListenWaitConnector).Receive();
                Console.WriteLine(result.Structure.ToString());
            }
             ]]>
             </code>
             </example>
        </member>
        <member name="M:MARC.Everest.Connectors.IListenWaitConnector.Start">
            <summary>
            Start listening for unsolicited requests
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.IListenWaitConnector.Stop">
            <summary>
            Stop listening
            </summary>
        </member>
        <member name="E:MARC.Everest.Connectors.IListenWaitConnector.MessageAvailable">
            <summary>
            Event is fired when unsolicited data is received
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.IListenWaitRespondConnector">
            <summary>
            Represents a <see cref="T:MARC.Everest.Connectors.IListenWait"/> connector that can send responses back to the
            solicitor
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.IListenWaitRespondConnector.Send(MARC.Everest.Interfaces.IGraphable,MARC.Everest.Connectors.IReceiveResult)">
            <summary>
            Send <paramref name="data"/> to the remote endpoint
            </summary>
            <param name="data">The data to send to the remote endpoint</param>
            <param name="correlate">The result of the receive function that this response should be correlated with</param>
            <returns>Response code from the sending handler</returns>
        </member>
        <member name="M:MARC.Everest.Connectors.IListenWaitRespondConnector.BeginSend(MARC.Everest.Interfaces.IGraphable,MARC.Everest.Connectors.IReceiveResult,System.AsyncCallback,System.Object)">
            <summary>
            Starts an asynchronous send of the data to the remote endpoint
            </summary>
            <param name="data">The data to send</param>
            <param name="callback">The delegate to call when the message is confirmed sent</param>
            <param name="state">An object representing the state of the request</param>
            <param name="correlate">The result of the receive function that this response should be correlated with</param>
            <returns>A callback information class</returns>
        </member>
        <member name="M:MARC.Everest.Connectors.IListenWaitRespondConnector.EndSend(System.IAsyncResult)">
            <summary>
            Get the send result of an asynchronous call
            </summary>
            <param name="asyncResult">A pointer to the async result returned from the begin send method</param>
            <returns>Response code from the sending handler</returns>
        </member>
        <member name="E:MARC.Everest.Connectors.IListenWaitRespondConnector.InvalidResponse">
            <summary>
            Fires if the response to a message did not pass conformance. This allows the user to suggest a new 
            structure to send in place of the invalid one
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.IReceiveResult">
            <summary>
            Represents a result from a receive connection
            </summary>
            <remarks>
            <para>The IReceiveResult interface allows connectors to pass back meta data about the
            instance received from the wire. For example, an MsMq connector could theoretically
            pass queue and authentication information along with the parsed message instance</para>
            </remarks>
        </member>
        <member name="P:MARC.Everest.Connectors.IReceiveResult.Code">
            <summary>
            The result code
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.IReceiveResult.Details">
            <summary>
            The details of the result
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.IReceiveResult.Structure">
            <summary>
            The result received from the connector
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.IReceivingConnector">
            <summary>
            Represents a <see cref="T:MARC.Everest.Connectors.IConnector"/> that receives data from a remote endpoint
            </summary>
            <remarks>
            This type of connector is not to be confused with an <see cref="T:MARC.Everest.Connectors.IListenWaitConnector"/> 
            as it does not actively try to receive messages from an endpoint. Rather, it serves
            as a marker for the Send/Receive pattern.
            </remarks>
            <seealso cref="T:MARC.Everest.Connectors.ISendingConnector"/>
        </member>
        <member name="M:MARC.Everest.Connectors.IReceivingConnector.Receive">
            <summary>
            Receive data from the connector
            </summary>
            <returns>The data received from the connector interface</returns>
        </member>
        <member name="M:MARC.Everest.Connectors.IReceivingConnector.BeginReceive(System.AsyncCallback,System.Object)">
            <summary>
            Start an asynchronous receive operation
            </summary>
            <param name="callback">The delegate to call when the data is fully received</param>
            <param name="state">An object representing the status of the receive operation</param>
            <returns>An IAsyncResult point that can be used to track the request</returns>
        </member>
        <member name="M:MARC.Everest.Connectors.IReceivingConnector.EndReceive(System.IAsyncResult)">
            <summary>
            Receive the contents of an asynchronous receive operation
            </summary>
            <param name="result">A pointer to the BeingReceive return value</param>
            <returns>The data received from the connector interface</returns>
        </member>
        <member name="P:MARC.Everest.Connectors.IReceivingConnector.HasData">
            <summary>
            True if the receive connector has new data waiting
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.ISendingConnector">
            <summary>
            Represents a <see cref="T:MARC.Everest.Connectors.IConnector"/> that can send data to a remote system
            </summary>
            <seealso cref="T:MARC.Everest.Connectors.IReceivingConnector"/>
        </member>
        <member name="M:MARC.Everest.Connectors.ISendingConnector.Send(MARC.Everest.Interfaces.IGraphable)">
             <summary>
             Send <paramref name="data"/> to the remote endpoint
             </summary>
             <param name="data">The data to send to the remote endpoint</param>
             <returns>Response code from the sending handler</returns>
             <example>
             <code lang="cs">
             <![CDATA[
             public static void Publish(IGraphable instance, ISendingConnector target)
            {
                // Check target is open
                if (!target.IsOpen())
                    target.Open();
            
                ISendResult result = target.Send(instance);
                // Verify data was sent
                if (result.Code != ResultCode.Accepted &&
                    result.Code != ResultCode.AcceptedNonConformant)
                    Console.WriteLine("There was a problem sending the message");
            }
            
             ]]>
             </code>
             </example>
        </member>
        <member name="M:MARC.Everest.Connectors.ISendingConnector.BeginSend(MARC.Everest.Interfaces.IGraphable,System.AsyncCallback,System.Object)">
             <summary>
             Starts an asynchronous send of the data to the remote endpoint
             </summary>
             <param name="data">The data to send</param>
             <param name="callback">The delegate to call when the message is confirmed sent</param>
             <param name="state">An object representing the state of the request</param>
             <returns>A callback information class</returns>
             <example>
             <code lang="cs">
             <![CDATA[
            public static void Publish(IGraphable instance, ISendingConnector target)
            {
                // Check target is open
                if (!target.IsOpen())
                    target.Open();
            
                IAsyncResult asyncResult = target.BeginSend(instance, null, null);
            
                // Print "Doing something else" while the formatter formats
                while (!asyncResult.IsCompleted)
                    Console.WriteLine("Doing something else....");
            
                // Get the send result
                ISendResult result = target.EndSend(asyncResult);
            
                // Verify data was sent
                if (result.Code != ResultCode.Accepted &&
                    result.Code != ResultCode.AcceptedNonConformant)
                    Console.WriteLine("There was a problem sending the message");
            }
             ]]>
             </code>
             </example>
             <seealso cref="F:EndSend(IAsyncResult asyncResult)"/>
        </member>
        <member name="M:MARC.Everest.Connectors.ISendingConnector.EndSend(System.IAsyncResult)">
            <summary>
            Get the send result of an asynchronous call
            </summary>
            <param name="asyncResult">A pointer to the async result returned from the begin send method</param>
            <returns>Response code from the sending handler</returns>
            <seealso cref="F:BeginSend(IGraphable data, AsyncCallback callback, object state)"/>
        </member>
        <member name="T:MARC.Everest.Connectors.ISendReceiveConnector">
            <summary>
            Represents a <see cref="T:MARC.Everest.Connectors.ISendingConnector"/> that sends and receives messages over 
            a transport channel
            </summary>
            <seealso cref="T:MARC.Everest.Connectors.ISendingConnector"/>
            <seealso cref="T:MARC.Everest.Connectors.IReceivingConnector"/>
        </member>
        <member name="M:MARC.Everest.Connectors.ISendReceiveConnector.Receive(MARC.Everest.Connectors.ISendResult)">
             <summary>
             Receive the response to a message that has been sent
             </summary>
             <param name="correlate">The <see cref="T:MARC.Everest.Connectors.ISendResult"/> that represents the response from the send method</param>
             <returns>A receive result</returns>
             <example>
             <code lang="cs">
             <![CDATA[
             <summary>
             Sends <paramref name="request"/> via
             <paramref name="target"/>, waits for a 
             response and returns the result.
             </summary>
             <returns>The response message</returns>
            public static IGraphable SendAndWait(IGraphable request, ISendReceiveConnector target)
            {
                if (!target.IsOpen())
                    target.Open();
            
                // Send a request
                ISendResult sendResult = target.Send(request);
            
                // If the send was successful then block and wait the response
                if (sendResult.Code == ResultCode.Accepted ||
                    sendResult.Code == ResultCode.AcceptedNonConformant)
                {
                    // Block and wait for response
                    IReceiveResult receiveResult = target.Receive(sendResult);
            
                    // If the receive result was successful return the structure
                    if (receiveResult.Code == ResultCode.Accepted ||
                        receiveResult.Code == ResultCode.AcceptedNonConformant)
                        return receiveResult.Structure;
                }
                else
                    Console.WriteLine("There was a problem sending the message");
                return null;
            }
             ]]>
             </code>
             </example>
        </member>
        <member name="M:MARC.Everest.Connectors.ISendReceiveConnector.BeginReceive(MARC.Everest.Connectors.ISendResult,System.AsyncCallback,System.Object)">
             <summary>
             Start the receive operation
             </summary>
             <param name="correlate">The <see cref="T:MARC.Everest.Connectors.ISendResult"/> that represents the response from the send operation</param>
             <param name="callback">A callback delegate that is executed with the receive operation completes</param>
             <param name="state">A user state</param>
             <returns>An <see cref="T:System.IAsyncResult"/> handle</returns>
             <example>
             <code lang="cs">
             <![CDATA[
             response and returns the result.
             </summary>
             <returns>The response message</returns>
            public static IGraphable SendAndWait(IGraphable request, ISendReceiveConnector target)
            {
                if (!target.IsOpen())
                    target.Open();
            
                // Send a request
                IAsyncResult asyncResult = target.BeginSend(request, null, null);
            
                // Wait for the message to be serialized and sent
                while (!asyncResult.IsCompleted)
                    Console.WriteLine("Formatting and Sending...");
            
                ISendResult sendResult = target.EndSend(asyncResult);
            
                // If the send was successful then block and wait the response
                if (sendResult.Code == ResultCode.Accepted ||
                    sendResult.Code == ResultCode.AcceptedNonConformant)
                {
                    // Begin the receive operation
                    asyncResult = target.BeginReceive(sendResult, null, null);
            
                    // Wait for the message to be received and parsed
                    while (!asyncResult.IsCompleted)
                        Console.WriteLine("Receiving...");
            
                    // Get the receive result
                    IReceiveResult receiveResult = target.EndReceive(asyncResult);
            
                    // If the receive result was successful return the structure
                    if (receiveResult.Code == ResultCode.Accepted ||
                        receiveResult.Code == ResultCode.AcceptedNonConformant)
                        return receiveResult.Structure;
                }
                else
                    Console.WriteLine("There was a problem sending the message");
                return null;
            }
             ]]>
             </code>
             </example>
             <seealso cref="F:EndReceive(IAsyncResult asyncResult)"/>
        </member>
        <member name="M:MARC.Everest.Connectors.ISendReceiveConnector.EndReceive(System.IAsyncResult)">
            <summary>
            End the receive operation and retrieve the result
            </summary>
            <param name="asyncResult">The result of the <see cref="M:MARC.Everest.Connectors.ISendReceiveConnector.BeginReceive(MARC.Everest.Connectors.ISendResult,System.AsyncCallback,System.Object)"/> method</param>
            <returns>A receive result</returns>
            <seealso cref="F:BeginReceive(ISendResult correlate, AsyncCallback callback, object state)"/>
        </member>
        <member name="T:MARC.Everest.Connectors.ResultCode">
            <summary>
            Result codes
            </summary>
        </member>
        <member name="F:MARC.Everest.Connectors.ResultCode.Accepted">
            <summary>
            The message was accepted for delivery
            </summary>
        </member>
        <member name="F:MARC.Everest.Connectors.ResultCode.AcceptedNonConformant">
            <summary>
            The message was accepted however it did not pass conformance
            </summary>
        </member>
        <member name="F:MARC.Everest.Connectors.ResultCode.Rejected">
            <summary>
            The message was rejected for delivery due to validation failures
            in the formatter
            </summary>
        </member>
        <member name="F:MARC.Everest.Connectors.ResultCode.Error">
            <summary>
            An error occured while sending the message to the remote endpoint
            </summary>
        </member>
        <member name="F:MARC.Everest.Connectors.ResultCode.NotAvailable">
            <summary>
            The connection was not available
            </summary>
        </member>
        <member name="F:MARC.Everest.Connectors.ResultCode.TypeNotAvailable">
            <summary>
            The Type was not available
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.ISendResult">
            <summary>
            Represents a result from a sending connector
            </summary>
            <remarks>
            This interface permits connectors to pass contextual meta data about the send
            operation back to callers. For example, if a call failed, it would be possible
            for a sending connector to pass back an HTTP error code in a send result class.
            </remarks>
        </member>
        <member name="P:MARC.Everest.Connectors.ISendResult.Code">
            <summary>
            The result of the send operation
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.ISendResult.Details">
            <summary>
            The details of how the result was attained.
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.ResultDetailType">
            <summary>
            Identifies the type of send result detail
            </summary>
        </member>
        <member name="F:MARC.Everest.Connectors.ResultDetailType.Error">
            <summary>
            The detail represents a fatal error
            </summary>
        </member>
        <member name="F:MARC.Everest.Connectors.ResultDetailType.Warning">
            <summary>
            The detail represents a warning
            </summary>
        </member>
        <member name="F:MARC.Everest.Connectors.ResultDetailType.Information">
            <summary>
            The detail represents an informational message
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.IResultDetail">
            <summary>
            Represents details about the send result
            </summary>
            <remarks>
            The IResultDetail interface provides mechanisms for retrieving errors from the 
            process of formatting an instance. 
            </remarks>
            <example lang="cs" title="Printing Error Details">
            <code lang="cs" title="Printing Error Details">
            // This example assumes instance is an IGraphable object
            // and that formatter is a formatter
            IStructureFormatter isf = (IStructureFormatter)formatter;
            IFormatterGraphResult result = isf.Graph(Console.OpenStandardOutput(), instance);
            foreach(IResultDetail dtl in result.Details)
                Console.WriteLine("{0} at {1}", dtl.Message, dtl.Location);
            </code>
            </example>
        </member>
        <member name="P:MARC.Everest.Connectors.IResultDetail.Type">
            <summary>
            The type of detail this result detail line represents
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.IResultDetail.Message">
            <summary>
            The textual message of the result detail
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.IResultDetail.Exception">
            <summary>
            The exception that may have caused this result detail to fail.
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.IResultDetail.Location">
            <summary>
            Identifies the location of the error
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.IStructureFormatter">
            <summary>
            Represents a class that has the ability to render an IGraphable object into another form, effectively
            serializing it
            </summary>
            <remarks>
            <para>The manner in which structure formatters are implemented have changed for Everest 1.0, 
            namely the Graph and Parse methods will be updated to be harmonized with the manner that 
            jEverest formats structures. 
            </para>
            <para>This will rid us of the Details array and will alter the method signatures for the formatter
            methods like GraphObject and ParseObject
            </para>
            </remarks>
        </member>
        <member name="P:MARC.Everest.Connectors.IStructureFormatter.GraphAides">
             <summary>
             Instances of other IStructureFormatters that provide assistance to the primary formatter
             </summary>
             <example>
             <code lang="cs" title="Assigning a graphing aide">
             <![CDATA[
             // Create an instance of the primary formatter
            IStructureFormatter formatter = new XmlIts1Formatter();
            
             // Assign a graph aide
            formatter.GraphAides.Add(new DatatypeR2Formatter());
             ]]>
             </code>
             </example>
        </member>
        <member name="P:MARC.Everest.Connectors.IStructureFormatter.Host">
            <summary>
            The host of this formatter
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.IStructureFormatter.HandleStructure">
            <summary>
            Gets the types that this formatter can graph to/from the specified format
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.IStructureFormatter.Graph(System.IO.Stream,MARC.Everest.Interfaces.IGraphable)">
             <summary>
             Graphs the object <paramref name="o"/> onto stream <paramref name="s"/> and returns
             a <see cref="T:MARC.Everest.Connectors.IFormatterGraphResult"/> structure with additional 
             details
             </summary>
             <param name="s">The stream to graph the message to</param>
             <param name="o"></param>
             <returns>An instance of <see cref="T:MARC.Everest.Connectors.IFormatterGraphResult"/> containing the results of the graph operation</returns>
             <example>
             <code lang="cs" title="Graphing an instance to a stream">
             <![CDATA[
            Stream s = null;
            try
            {
                // Initialize the stream
                s = File.Create("mydata.dat");
            
                // Make a stream writer for easier addition of data to the stream
                StreamWriter sw = new StreamWriter(s);
                sw.WriteLine("This demonstrates writing data before a formatter!");
                sw.Flush();
            
                // Create a simple instance
                MCCI_IN000000UV01 instance = new MCCI_IN000000UV01(
                    Guid.NewGuid(),
                    DateTime.Now,
                    MCCI_IN000000UV01.GetInteractionId(),
                    ProcessingID.Production,
                    "P",
                    AcknowledgementCondition.Always);
            
                // Setup the formatter
                IStructureFormatter structureFormatter = new XmlIts1Formatter()
                {
                    ValidateConformance = false
                };
                structureFormatter.GraphAides.Add(new DatatypeFormatter());
            
                // Format
                structureFormatter.Graph(s, instance);
            
                // Write some data after
                sw.WriteLine("This appears afterwards!");
                sw.Close();
            }
            finally
            {
                if (s != null)
                    s.Close();
            }
             ]]>
             </code>
             </example>
        </member>
        <member name="M:MARC.Everest.Connectors.IStructureFormatter.Parse(System.IO.Stream)">
             <summary>
             Parses an object from <paramref name="s"/> and returns a <see cref="T:MARC.Everest.Connectors.IFormatterParseResult"/>
             structure with additional details
             </summary>
             <param name="s">The stream from which to graph</param>
             <returns>An instance of <see cref="T:MARC.Everest.Connectors.IFormatterParseResult"/> containing the results of the parse operation</returns>
             <example>
             <code lang="cs" title="Parsing data from a stream">
             <![CDATA[
             // Load the assembly into the current AppDomain
            Assembly.Load(new AssemblyName("MARC.Everest.RMIM.UV.NE2008, Version=1.0.4366.42027, Culture=neutral"));
            
            Stream s = null;
            try
            {
                // Initialize the stream
                s = File.OpenRead("mydata.xml");
            
                // Setup the formatter
                IStructureFormatter structureFormatter = new XmlIts1Formatter()
                {
                    ValidateConformance = false
                };
                structureFormatter.GraphAides.Add(new DatatypeFormatter());
            
                // Parse
                var result = structureFormatter.Parse(s);
            
                // Output the type of instance that was parsed
                Console.WriteLine("This file contains a '{0}' instance", result.Structure.GetType().Name);
            }
            finally
            {
                if (s != null)
                    s.Close();
            }
             ]]>
             </code>
             </example>
        </member>
        <member name="T:MARC.Everest.Connectors.IValidatingStructureFormatter">
            <summary>
            Identifies a formatter that can validate structures
            </summary>
            <remarks>
            <para>This interface appends the ValidateConformance property to 
            the structure formatter. When true, this flag will enable
            the validation of messages when using the Graph and Parse
            methods.</para>
            <para>
            Most formatters will stop rendering messages when major errors
            are encountered. It is usually good practice to set this to 
            false when testing and debugging an application, and setting
            it to true when production data is being processed.
            </para>
            </remarks>
        </member>
        <member name="P:MARC.Everest.Connectors.IValidatingStructureFormatter.ValidateConformance">
            <summary>
            If true, validates the conformance of the structures
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.IXmlStructureFormatter">
            <summary>
            Structured formatter that supports xml data
            </summary>
            <remarks>
            This interface appends the necessary functionality to call a formatter
            using <see cref="T:System.Xml.XmlWriter"/> and <see cref="T:System.Xml.XmlReader"/>
            instances. For the best results, it is strongly recommended that callers 
            of these functions use the <see cref="T:MARC.Everest.Xml.XmlStateWriter"/> and
            <see cref="T:MARC.Everest.Xml.XmlStateReader"/> classes rather than <see cref="T:System.Xml.XmlWriter"/>
            and <see cref="T:System.Xml.XmlReader"/> classes respectively.
            </remarks>
        </member>
        <member name="M:MARC.Everest.Connectors.IXmlStructureFormatter.Graph(System.Xml.XmlWriter,MARC.Everest.Interfaces.IGraphable)">
            <summary>
            Graph object <paramref name="o"/> onto XML Writer <paramref name="s"/>
            </summary>
            <param name="s">The stream (XML Writer) to graph the object</param>
            <param name="o">The object to be graphed</param>
            <returns>A structure containing the results of the graph operation</returns>
        </member>
        <member name="M:MARC.Everest.Connectors.IXmlStructureFormatter.Parse(System.Xml.XmlReader)">
            <summary>
            Parse an object from an XMLReader
            </summary>
            <param name="r">The reader to read from</param>
        </member>
        <member name="M:MARC.Everest.Connectors.IXmlStructureFormatter.Parse(System.Xml.XmlReader,System.Type)">
            <summary>
            Parse an object from <paramref name="r"/> using type <paramref name="t"/>
            </summary>
            <param name="r">The reader to read from</param>
            <param name="t">The type to use for formatting</param>
        </member>
        <member name="T:MARC.Everest.Connectors.MessageEventArgs">
            <summary>
            Event arguments for message based events
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.MessageEventArgs.Code">
            <summary>
            Get or set the code that was generated from formatting the message
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.MessageEventArgs.Details">
            <summary>
            The details related to the formatting
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.MessageEventArgs.Alternate">
            <summary>
            An alternate structure to send
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.MessageEventArgs.#ctor(MARC.Everest.Connectors.ResultCode,System.Collections.Generic.IEnumerable{MARC.Everest.Connectors.IResultDetail})">
            <summary>
            Create a new instance of the MessageEventArgs class
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.ReceiveResultAsyncResult">
            <summary>
            Provides an AsyncResult class that can be supplied to/from EndReceive/BeginReceive methods
            </summary>
            <remarks>This class is used to implement the standard asynchronous BeginX/EndX pattern 
            used by many .NET frameworks. For more information see the MSDN documentation for 
            IAsyncResult</remarks>
        </member>
        <member name="P:MARC.Everest.Connectors.ReceiveResultAsyncResult.AsyncState">
            <summary>
            
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.ReceiveResultAsyncResult.AsyncWaitHandle">
            <summary>
            
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.ReceiveResultAsyncResult.CompletedSynchronously">
            <summary>
            
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.ReceiveResultAsyncResult.IsCompleted">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.ReceiveResultAsyncResult.SetComplete">
            <summary>
            Set the operation to complete
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.ReceiveResultAsyncResult.#ctor(System.Object,System.Threading.WaitHandle)">
            <summary>
            Create a new instance of the SendResultAsyncResult
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.ResultDetail">
            <summary>
            Represents diagnostic details about a validation, formatting or connection
            operation.
            </summary>
        </member>
        <member name="F:MARC.Everest.Connectors.ResultDetail.exception">
            <summary>
            Exception
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.ResultDetail.Type">
            <summary>
            Type of result detail
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.ResultDetail.Message">
            <summary>
            Message of the detail
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.ResultDetail.Location">
            <summary>
            Gets or sets the location of the details
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.ResultDetail.Exception">
            <summary>
            Exception
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.ResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String,System.Exception)">
            <summary>
            Creates a new instance of hte datatype result detail
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.ResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String)">
            <summary>
            Creates a new instance of the result detail class
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.ResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.Exception)">
            <summary>
            Create a new instance of the datatype result detail
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.ResultDetail.#ctor(System.String)">
            <summary>
            Result detail
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.ResultDetail.ToString">
            <summary>
            Represent this as a string
            </summary>
            <returns></returns>
        </member>
        <member name="T:MARC.Everest.Connectors.ValidationResultDetail">
            <summary>
            Represents result details related to the validation of a message instance
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.ValidationResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String,System.Exception)">
            <summary>
            Creates a new instance of hte datatype result detail
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.ValidationResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String)">
            <summary>
            Creates a new instance of the result detail class
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.ValidationResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.Exception)">
            <summary>
            Create a new instance of the datatype result detail
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.ValidationResultDetail.#ctor(System.String)">
            <summary>
            Result detail
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.FormalConstraintViolationResultDetail">
            <summary>
            This class is used to group validation result details which represent formal constraint violations in the message
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.FormalConstraintViolationResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String,System.Exception)">
            <summary>
            Creates a new instance of hte datatype result detail
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.FormalConstraintViolationResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String)">
            <summary>
            Creates a new instance of the result detail class
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.FormalConstraintViolationResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.Exception)">
            <summary>
            Create a new instance of the datatype result detail
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.FormalConstraintViolationResultDetail.#ctor(System.String)">
            <summary>
            Result detail
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.RequiredElementMissingResultDetail">
            <summary>
            Required element is missing
            </summary>
            <remarks>
            This formal constraint violation indicates that an instance is missing a required element
            where the minimum occurs is set to 1 (the conformance of Populated). At minimum a NullFlavor
            should be popualted
            </remarks>
        </member>
        <member name="M:MARC.Everest.Connectors.RequiredElementMissingResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String)">
            <summary>
            Create a new instance of the required element missing result detail
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.RequiredElementMissingResultDetail.#ctor(System.String)">
            <summary>
            Result detail
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.InsufficientRepetitionsResultDetail">
            <summary>
            Insufficient repetitions
            </summary>
            <remarks>
            This formal constraint violation indicates that an instnace has not supplied sufficient
            repetitions to fulfill the min occurs constraint on the property.
            </remarks>
        </member>
        <member name="M:MARC.Everest.Connectors.InsufficientRepetitionsResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String)">
            <summary>
            Create a new instance of the datatype result detail
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.InsufficientRepetitionsResultDetail.#ctor(System.String)">
            <summary>
            Result detail
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.MandatoryElementMissingResultDetail">
            <summary>
            Mandatory element is missing
            </summary>
            <remarks>
            This formal constraint violation indicates that an instance has a property set to null (or whose null flavor is set ) when
            the conformance for the property is Mandatory
            </remarks>
        </member>
        <member name="M:MARC.Everest.Connectors.MandatoryElementMissingResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String)">
            <summary>
            Create a new instance of the datatype result detail
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.MandatoryElementMissingResultDetail.#ctor(System.String)">
            <summary>
            Result detail
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.NotImplementedResultDetail">
            <summary>
            The requested feature has not been implemented in the Everest Framework
            </summary>
            <remarks>
            This result detail is usually triggered when functionality has been implemented that 
            has not been implemented, or is impossible to implement in the Everest Framework
            </remarks>
        </member>
        <member name="M:MARC.Everest.Connectors.NotImplementedResultDetail.#ctor(System.String)">
            <summary>
            Creates a new instance of the not implemented result detail with the specified <paramref name="message"/>
            </summary>
            <param name="message">A human readable message the describes the result detail</param>
        </member>
        <member name="M:MARC.Everest.Connectors.NotImplementedResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String,System.Exception)">
            <summary>
            Creates a new instance of the not implemented result detail with the specified <paramref name="type"/>,
            <paramref name="message"/> which occurred at <paramref name="location"/> and was triggered by <paramref name="exception"/>
            being thrown
            </summary>
            <param name="type">Indicates the type of result detail (error, warning, informational)</param>
            <param name="message">A human readable message that describes the result detail</param>
            <param name="location">The location in the stream where the result detail was triggered</param>
            <param name="exception">An exception that caused the result detail to be thrown</param>
        </member>
        <member name="M:MARC.Everest.Connectors.NotImplementedResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String)">
            <summary>
            Creates a new instance of the not implemented result detail with the specified <paramref name="type"/>,
            <paramref name="message"/> which occurred at <paramref name="location"/>
            </summary>
            <param name="type">Indicates the type of result detail (error, warning, informational)</param>
            <param name="message">A human readable message that describes the result detail</param>
            <param name="location">The locaiton within the stream where the result detail was triggered.</param>
        </member>
        <member name="T:MARC.Everest.Connectors.NotImplementedElementResultDetail">
            <summary>
            Encountered an element that was not understood
            </summary>
            <remarks>
            This result details occurs during the parsing of an instance whereby the formatter encountered
            an element that has no "home" within the object. 
            </remarks>
        </member>
        <member name="M:MARC.Everest.Connectors.NotImplementedElementResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String,System.Exception)">
            <summary>
            Create a new instance of the datatype result detail
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.NotImplementedElementResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String,System.String,System.Exception)">
            <summary>
            Create a new instance of the not implemented element result detail
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.NotImplementedElementResultDetail.#ctor(System.String,System.String)">
            <summary>
            Result detail
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.NotSupportedChoiceResultDetail">
            <summary>
            A choice element was used that is not supported
            </summary>
            <remarks>
            This result detail is usually used whenever a property is populated with a valid value (from .NET perspective) however
            the RMIM model does not support the choice. This is commonly raised for referneces to System.Object</remarks>
        </member>
        <member name="M:MARC.Everest.Connectors.NotSupportedChoiceResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.Exception)">
            <summary>
            Create a new instance of the datatype result detail
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.NotSupportedChoiceResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String,System.Exception)">
            <summary>
            Create a new instance of the not implemented element result detail
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.NotSupportedChoiceResultDetail.#ctor(System.String)">
            <summary>
            Result detail
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.FixedValueMisMatchedResultDetail">
            <summary>
            The fixed value in the message definition does not match the value supplied
            </summary>
            <remarks>
            This violation occurs during the parsing of an instance whereby a value is supplied in the instance that does not
            match the fixed value defined in the .NET type. The formatter may override the supplied value with the fixed value, 
            or may use the fixed value
            </remarks>
        </member>
        <member name="M:MARC.Everest.Connectors.FixedValueMisMatchedResultDetail.#ctor(System.String,System.String,System.String)">
            <summary>
            Create a new instance of the datatype result detail
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.FixedValueMisMatchedResultDetail.#ctor(System.String,System.String,System.Boolean,System.String)">
            <summary>
            Create a new instance of the datatype result detail
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.FixedValueMisMatchedResultDetail.Overwritten">
            <summary>
            When true, indicates that the supplied value was used to overwrite the fixed value
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.FixedValueMisMatchedResultDetail.SuppliedValue">
            <summary>
            Gets or sets the supplied value on the wire
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.VocabularyIssueResultDetail">
            <summary>
            An issue was detected with the codified concepts within the message
            </summary>
            <remarks>
            This issue is raised whenever codified data is encountered whereby the supplied value 
            cannot be used in the context, or if the value is unknown / invalid.
            </remarks>
        </member>
        <member name="M:MARC.Everest.Connectors.VocabularyIssueResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.Exception)">
            <summary>
            Create a new instance of the datatype result detail
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.VocabularyIssueResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String,System.Exception)">
            <summary>
            Create a new instance of the vocabulary issue result detail
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.VocabularyIssueResultDetail.#ctor(System.String)">
            <summary>
            Result detail
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.DatatypeValidationResultDetail">
            <summary>
            Identifies that basic validation of a datatype instance has failed
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.DatatypeValidationResultDetail.DatatypeName">
            <summary>
            Gets the name of the datatype where validation failed
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.DatatypeValidationResultDetail.Message">
            <summary>
            Gets the error message
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.DatatypeValidationResultDetail.#ctor(System.String)">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.DatatypeValidationResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String)">
            <summary>
            Creates a new instance of the datatype validation result detail class with the specified parameters
            </summary>
            <param name="type">The type of result detail</param>
            <param name="datatypeName">The name of the datatype that is not supported</param>
            <param name="location">The location within the instance that that is not supported</param>
        </member>
        <member name="M:MARC.Everest.Connectors.DatatypeValidationResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the datatype validation result detail class with the specified parameters
            </summary>
            <param name="type">The type of result detail</param>
            <param name="datatypeName">The name of the datatype that is not supported</param>
            <param name="location">The location within the instance that that is not supported</param>
        </member>
        <member name="T:MARC.Everest.Connectors.DatatypeFlavorValidationResultDetail">
            <summary>
            Identifies that flavor validation of a datatype instance has failed
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.DatatypeFlavorValidationResultDetail.FlavorName">
            <summary>
            Gets the name of the datatype where validation failed
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.DatatypeFlavorValidationResultDetail.Message">
            <summary>
            Gets the message
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.DatatypeFlavorValidationResultDetail.#ctor(System.String,System.String)">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.DatatypeFlavorValidationResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the datatype validation result detail class with the specified parameters
            </summary>
            <param name="type">The type of result detail</param>
            <param name="datatypeName">The name of the datatype that is not supported</param>
            <param name="location">The location within the instance that that is not supported</param>
        </member>
        <member name="T:MARC.Everest.Connectors.PropertyValuePropagatedResultDetail">
            <summary>
            Identifies that the value in a data type has been propagated as the traversal
            on which the original value was set is not rendered
            </summary>
            <remarks>
            <para>This result detail is added whenever a value (such as NullFlavor, Flavor, etc...)
            is set on a data type that is "transparent" or not rendered (such as GTS.Hull). The result detail
            is used to record the original and destination and value of propagation</para>
            </remarks>
        </member>
        <member name="P:MARC.Everest.Connectors.PropertyValuePropagatedResultDetail.ValuePropagated">
            <summary>
            Gets the value that was propagated
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.PropertyValuePropagatedResultDetail.OriginalPath">
            <summary>
            Gets the original path that the value was originally set on
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.PropertyValuePropagatedResultDetail.DestinationPath">
            <summary>
            Gets the destination path that the value has been propagated to
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.PropertyValuePropagatedResultDetail.Message">
            <summary>
            Gets the message of the result detail
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.PropertyValuePropagatedResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String,System.Object,System.String)">
            <summary>
            Creates a new instance of the property propagated result detail
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.UnsupportedDatatypePropertyResultDetail">
            <summary>
            Identifies that a property populated within the datatype can't rendered
            to the output stream by the current datatype formatter
            </summary>
            <remarks>
            <para>
            Because the Everest data type library is a combination of R1 and R2 concepts 
            (to support write once render both) some concepts cannot be rendered within 
            either instance of a message. 
            </para>
            <para>This result detail signals that a value populated in memory may
            not have been rendered on the wire</para>
            <para>This abstract class must be extended by datatype formatters</para>
            </remarks>
        </member>
        <member name="P:MARC.Everest.Connectors.UnsupportedDatatypePropertyResultDetail.Message">
            <summary>
            Gets the message for the detail
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.UnsupportedDatatypePropertyResultDetail.PropertyName">
            <summary>
            Gets or sets the name of the property that isn't supported
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.UnsupportedDatatypePropertyResultDetail.DatatypeName">
            <summary>
            Gets or sets the name of the datatype that contains the unsupported property
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.UnsupportedDatatypePropertyResultDetail.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.UnsupportedDatatypePropertyResultDetail.#ctor(MARC.Everest.Connectors.ResultDetailType,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the unsupported data type result detail
            </summary>
            <param name="type">The type of result detail</param>
            <param name="propertyName">The name of the property that is not supported</param>
            <param name="datatypeName">The name of the datatype that is not supported</param>
            <param name="location">The location within the instance that that is not supported</param>
        </member>
        <member name="T:MARC.Everest.Connectors.SendResultAsyncResult">
            <summary>
            Provides an AsyncResult class that can be supplied to/from EndSend/BeginSend methods
            </summary>
            <remarks>This class is used to implement the standard asynchronous BeginX/EndX pattern 
            used by many .NET frameworks. For more information see the MSDN documentation for 
            IAsyncResult</remarks>
        </member>
        <member name="P:MARC.Everest.Connectors.SendResultAsyncResult.AsyncState">
            <summary>
            The state of the asynchronous operation
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.SendResultAsyncResult.AsyncWaitHandle">
            <summary>
            Wait handle
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.SendResultAsyncResult.CompletedSynchronously">
            <summary>
            True if the operation completed synchronously
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.SendResultAsyncResult.IsCompleted">
            <summary>
            True if the operation is complete
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.SendResultAsyncResult.SetComplete">
            <summary>
            Set the operation to complete
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.SendResultAsyncResult.#ctor(System.Object,System.Threading.WaitHandle)">
            <summary>
            Create a new instance of the SendResultAsyncResult
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.UnsolicitedDataEventArgs">
            <summary>
            Event arguments for unsolicited data received
            </summary>
            <remarks>
            <para>
            This event arguments class is passed by the MessageReceived event found on
            <see cref="T:MARC.Everest.Connectors.IListenWaitConnector"/>. When a new message
            is ready to be processed by the <see cref="T:MARC.Everest.Connectors.IListenWaitConnector"/>, 
            it will fire the MessageReceived method. This event args class supplies data to the 
            subscribed event handlers for that event.
            </para>
            </remarks>
        </member>
        <member name="P:MARC.Everest.Connectors.UnsolicitedDataEventArgs.ReceiveEndpoint">
            <summary>
            The remote enpoint address where the data was received from
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.UnsolicitedDataEventArgs.Timestamp">
            <summary>
            The time the data was received
            </summary>
        </member>
        <member name="P:MARC.Everest.Connectors.UnsolicitedDataEventArgs.SolicitorEndpoint">
            <summary>
            The endpoint of the solicitor
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.UnsolicitedDataEventArgs.#ctor(System.Uri,System.DateTime,System.Uri)">
            <summary>
            Create a new instance of the UnsolicitedDataEventArgs
            </summary>
            <param name="receiveEndpoint">The endpoint the data was received from</param>
            <param name="timestamp">The time the data was received</param>
            <param name="solicitorEndpoint">The solicitor of the data</param>
        </member>
        <member name="T:MARC.Everest.Connectors.CreateXSITypeNameDelegate">
            <summary>
            A delegate that is used by <see cref="T:Util.CreateXSIType"/> that 
            is used to override the manner in which XSI:TYPEs are created
            </summary>
        </member>
        <member name="T:MARC.Everest.Connectors.Util">
            <summary>
            Utility class for formatting data
            </summary>
        </member>
        <member name="F:MARC.Everest.Connectors.Util.s_enumerationMaps">
            <summary>
            Maps of enumerations and validators
            </summary>
        </member>
        <member name="F:MARC.Everest.Connectors.Util.s_flavorValidation">
            <summary>
            Flavor validation
            </summary>
        </member>
        <member name="F:MARC.Everest.Connectors.Util.s_wireMaps">
            <summary>
            Maps from wire format to real format
            Key - string in the format {FROM}>{TO}
            Value - MethodInfo of the method that will perform the operation to convert
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.Util.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.Util.ParseMaps(System.Type)">
            <summary>
            Parse maps from <paramref name="t"/>
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:MARC.Everest.Connectors.Util.Convert``1(System.Object)">
            <summary>
            Convert the object <paramref name="value"/> to the type specified by <typeparam name="T"/> if possible. This is used to
            parse objects from a wire format to a friendly format
            </summary>
            <remarks>
            <para>This utility method is usually used when comparing string data to instance classes. It can also be
            used to develop custom formatters.</para>
            <example>
            <code lang="cs" title="Converting a string to a list">
            <![CDATA[
                string adUseString = "PHYS BAD PUB";
                SET<CS<PostalAddressUse>> instance = Util.Convert<SET<CS<PostalAddressUse>>>(adUseString);
                
                // Results in a SET<CS<PostalAddressUse>> with three items:
                // 1. CS<PostalAddressUse> = PostalAddressUse.PhysicalVisit
                // 2. CS<PostalAddressUse> = PostalAddressUse.BadAddress
                // 3. CS<PostalAddressUse> = PostalAddressUse.Public
            ]]>
            </code>
            </example>
            </remarks>
            <exception cref="T:MARC.Everest.Exceptions.VocabularyException">If <paramref name="value"/> cannot be converted to <typeparamref name="T"/> because <typeparamref name="T"/> points to an enumeration
            and there is no known literal in <typeparamref name="T"/> that represents <paramref name="value"/></exception>
            <exception cref="T:MARC.Everest.Exceptions.FormatterException">When no method to convert <paramref name="object"/> to <typeparamref name="T"/> could be found</exception>
        </member>
        <member name="M:MARC.Everest.Connectors.Util.Convert``1(System.Object,System.Boolean)">
            <summary>
            Soft-convert
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.Util.FromWireFormat(System.Object,System.Type)">
            <summary>
            Convert from wire format
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.Util.FindConverter(System.Type,System.Type,System.Type)">
            <summary>
            Find the converter for the types specified
            </summary>
            <param name="scanType">The type to scan in</param>
            <param name="sourceType">The source type</param>
            <param name="destType">The destination type</param>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.Connectors.Util.ToWireFormat(System.Object)">
            <summary>
            Map an enumeration value from the literal to the wire format
            </summary>
            <param name="instanceValue">The value of the literal</param>
            <returns>A string representing the enumeration's literal value on the wire</returns>
            <remarks>
            Can be used to represent any data type as it's wire level rendering string (as it would appear if it were a structural attribute)
            <example>
            <code lang="cs" title="Converting a set to a string">
            <![CDATA[
             SET<CS<PostalAddressUse>> instance = new SET<CS<PostalAddressUse>>() { 
                 PostalAddressUse.PhysicalVisit,
                 PostalAddressUse.BadAddress,
                 PostalAddressUse.Direct
             };
             string output = MARC.Everest.Connectors.Util.ToWireFormat(instance);
                
             // Results in a string containing:
             // "PHYS BAD DIR"
            ]]>
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:MARC.Everest.Connectors.Util.ValidateFlavor(System.String,MARC.Everest.DataTypes.ANY,MARC.Everest.Connectors.IResultDetail[]@)">
            <summary>
            Validate <paramref name="instance"/> to the flavor <paramref name="flavor"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.Util.ParseXSITypeName(System.String)">
            <summary>
            Parse XSI Type Name
            </summary>
            <param name="xsiType"></param>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.Connectors.Util.ParseXSITypeNameInternal(System.Collections.Generic.Queue{System.String})">
            <summary>
            Parse XSI Type names
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.Util.CreateXSITypeName(System.Type)">
            <summary>
            Create an XSI Type name
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.Util.CreateXSITypeName(System.Type,MARC.Everest.Connectors.CreateXSITypeNameDelegate)">
            <summary>
            Creates an XSI type name with the specified <paramref name="subTypeCreator"/> used
            to create nested generic types
            </summary>
        </member>
        <member name="M:MARC.Everest.Connectors.Util.TryFromWireFormat(System.Object,System.Type,System.Object@)">
            <summary>
            Attempt casting <paramref name="value"/> to <paramref name="destType"/> placing the result 
            in <paramref name="result"/>
            </summary>
            <exception cref="T:MARC.Everest.Exceptions.VocabularyException">When <paramref name="value"/> cannot be cast to a strongly typed vocabulary if required in <paramref name="result"/></exception>
        </member>
        <member name="M:MARC.Everest.Connectors.Util.TryFromWireFormat(System.Object,System.Type,System.Object@,System.Collections.Generic.IList{MARC.Everest.Connectors.IResultDetail})">
            <summary>
            Attempt casting <paramref name="value"/> to <paramref name="destType"/> placing the result 
            in <paramref name="result"/>
            </summary>
            <remarks>If null is passed as the <paramref name="resultDetails"/> parameter then a <see cref="T:MARC.Everest.Exceptions.VocabularyException"/>
            will be thrown whenever vocabulary cannot be cast.</remarks>
        </member>
        <member name="T:MARC.Everest.DataTypes.PostalAddressUse">
            <summary>
            Identifies how an address can be used
            </summary>
            <see cref="T:MARC.Everest.DataTypes.AD"/>
            <example>
            <code title="Creating multiple addresses for one person" lang="cs">
            <![CDATA[
                            LIST<AD> personAddresses = new LIST<AD>(3);
                            ///  Add a home address
                            personAddresses.Add(
                                new AD(PostalAddressUse.HomeAddress, 
                                new ADXP[] { 
                                        new ADXP("123 Main Street", AddressPartType.StreetAddressLine),
                                        new ADXP("Hamilton", AddressPartType.City),
                                    new ADXP("Ontario", AddressPartType.State)
                                    }
                                )
                            ); 
                            ///  Add a Business Address
                            personAddresses.Add(
                            new AD(PostalAddressUse.WorkPlace, 
                                    new ADXP[]{
                                    new ADXP("123 Fake Street", AddressPartType.StreetAddressLine),
                                        new ADXP("Hamilton", AddressPartType.City),
                                        new ADXP("Ontario", AddressPartType.State)
                                    }                   
                                )
                            ); 
                            ///  Add a Direct Buisness Phone #
                            personAddresses.Add(
                                new AD(PostalAddressUse.Direct,
                                    new ADXP[]{
                                        new ADXP("555-867-5309")
                                }
                                )
                            );
                            foreach (AD address in personAddresses)
                            {
                                Console.WriteLine(address.ToString());
                            }
                            Console.ReadKey();
            ]]>
            </code>
            </example>
        </member>
        <member name="F:MARC.Everest.DataTypes.PostalAddressUse.HomeAddress">
            <summary>
            A communication address at a home, attempted contacts for business purposes
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.PostalAddressUse.PrimaryHome">
            <summary>
            The primary home to reach a person after business hours
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.PostalAddressUse.VacationHome">
            <summary>
            A vacation home
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.PostalAddressUse.WorkPlace">
            <summary>
            An office address
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.PostalAddressUse.Direct">
            <summary>
            Indicates a work place address or a telecommunication address
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.PostalAddressUse.Public">
            <summary>
            Indicates a work place address or telecommunication address that is a standard
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.PostalAddressUse.BadAddress">
            <summary>
            A flag indicating that the address is bad
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.PostalAddressUse.PhysicalVisit">
            <summary>
            Used primarily to visit an address
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.PostalAddressUse.PostalAddress">
            <summary>
            Used to send mail
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.PostalAddressUse.TemporaryAddress">
            <summary>
            A temporary address may be good for visit or mailing
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.PostalAddressUse.Alphabetic">
            <summary>
            Alphabetic transcription
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.PostalAddressUse.Ideographic">
            <summary>
            Address as understood by the datacentre
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.PostalAddressUse.Syllabic">
            <summary>
            Syllabic translation of the address
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.PostalAddressUse.Soundex">
            <summary>
            An address spelled according to the soundex algorithm
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.PostalAddressUse.Phonetic">
            <summary>
            The address as understood by the datacentre
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.AD">
             <summary>
             Mailing at home or office addresses is primarily used to communicate data that will 
             allow printing mail labels.
             </summary>
             <example>
             <code title="Instantiating an AD" lang="cs">
             <![CDATA[
             AD test = new AD( 
             PostalAddressUse.HomeAddress, 
             new ADXP[] { 
                     new ADXP("123", AddressPartType.BuildingNumber),  
                         new ADXP("Main", AddressPartType.StreetNameBase),  
                         new ADXP("Street", AddressPartType.StreetType), 
                         new ADXP("West", AddressPartType.Direction),  
                         new ADXP("Hamilton", AddressPartType.City),  
                         new ADXP("Ontario", AddressPartType.State),  
                         new ADXP("Canada", AddressPartType.Country), 
                         new ADXP("L8K 3K4", AddressPartType.PostalCode) 
             });
             
             // Write to console
             Console.Write(test.ToString("{BNR} {STB} {STTYP} {DIR}\r\n{CTY}, {STA}\r\n{CNT}\r\n{ZIP}")); 
             
             // Output: 
             // 123 Main Street West 
             // Hamilton, Ontario 
             // Canada 
             // L8K3K4 
             ]]>
             </code>
             </example>
             
             <example>
             <code title="Using the AD(SET&lt;CS&lt;PostalAddressUse&gt;&gt; use, IEnumerable&lt;ADXP&gt; parts) Constructor" lang="cs">
             <![CDATA[
            
             // SET(IEnumerable collection, Comparison<T> comparator)
                    SET<CS<PostalAddressUse>> setCS01 = new SET<CS<PostalAddressUse>>(
                                                    new CS<PostalAddressUse>[]{
                                                    new CS<PostalAddressUse>(PostalAddressUse.WorkPlace),
                                                    new CS<PostalAddressUse>(PostalAddressUse.HomeAddress)
                                                    },
                                                    CS<PostalAddressUse>.Comparator);
                                                    
                    // Address Parts enumeration
                    ADXP[] addressParts01 = new ADXP[] {
                                    new ADXP("123", AddressPartType.BuildingNumber),
                                    new ADXP("Bromley", AddressPartType.StreetName)               
                                    };
            
                    // Two Parameter Constructor -- (SET<CS<PostalAddressUse>> use, IEnumerable<ADXP> parts)
                    AD test04 = new AD(setCS01, addressParts01);
             
             
             ]]>
             </code>
            </example>
            <remarks>
            <para>
             Mailing, home and office addresses are commonly communicated using the AD class. The AD data type
             is primarily intended to facilitate the printing of address labels or providing a location that an
             entity can be located.
             </para>
             <para>
             Although not recommended, the AD data type can also be used, in some cases, to facilitate the location
             of points of interest on a map (which require additional geocoding)
             </para>
             <para>An AD instance is considered valid when either the <see cref="P:ANY.NullFlavor"/> property is null
             or there is at least one <see cref="P:Part"/>.
             </para>
             </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.AD.#cctor">
            <summary>
            Static CTOR
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.AD.#ctor">
            <summary>
            Create a new address instance
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.AD.#ctor(MARC.Everest.DataTypes.PostalAddressUse)">
            <summary>
            Create a new address instance with the specified use
            </summary>
            <param name="use">The use that should constructed address should have</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.AD.#ctor(System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.ADXP})">
            <summary>
            Create a new address instance using the parts specified
            </summary>
            <param name="parts">The parts to create</param>
            <example>
            <code title="Creating an AD using an existing array of parts" lang="cs">
            <![CDATA[
            List<ADXP> parts = new List<ADXP>() {
                new ADXP(),
                new ADXP()
            };
            AD myAddress = new AD(parts);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.AD.#ctor(MARC.Everest.DataTypes.CS{MARC.Everest.DataTypes.PostalAddressUse},System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.ADXP})">
            <summary>
            Create a new address instance using the parts and use specified
            </summary>
            <param name="parts">The parts to create</param>
            <param name="use">Contextual information about the postal address</param>
            <example>
            
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.AD.CreateAD(MARC.Everest.DataTypes.PostalAddressUse,MARC.Everest.DataTypes.ADXP[])">
            <summary>
            Helper method for creating AD instances
            </summary>
            <param name="use">The use of the returned address</param>
            <param name="parts">The parts that make up the address</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.AD.CreateAD(MARC.Everest.DataTypes.SET{MARC.Everest.DataTypes.PostalAddressUse},MARC.Everest.DataTypes.ADXP[])">
            <summary>
            Helper method for creating AD instances
            </summary>
            <param name="use">The use of the returned address</param>
            <param name="parts">The parts that make up the address</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.AD.CreateAD(MARC.Everest.DataTypes.ADXP[])">
            <summary>
            Helper method for creating AD instances
            </summary>
            <param name="use">The use of the returned address</param>
            <param name="parts">The parts that make up the address</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.AD.#ctor(MARC.Everest.DataTypes.SET{MARC.Everest.DataTypes.CS{MARC.Everest.DataTypes.PostalAddressUse}},System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.ADXP})">
            <summary>
            Create a new address instance using the parse and uses specified
            </summary>
            <param name="use">The uses of the address</param>
            <param name="parts">The parts of the address</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.AD.Part">
            <summary>
            A sequence of address parts that makes up the address
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.AD.Use">
            <summary>
            A code advising a system or user which address in a set of like addresses to select for a 
            given purpose
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.AD.UseablePeriod">
            <summary>
            A time specification that dictates the periods of time during which the address can be used.
            </summary>
            <example>
            <code title="Creating an address that is valid for the month of December" lang="cs">
            <![CDATA[
            
            AD myAddress = new AD(
                PostalAddressUse.VacationHome,
                new ADXP[] {
                    new ADXP("123 Main Street West", AddressPartType.StreetAddressLine),
                    new ADXP("Thunder Bay", AddressPartType.City),
                    new ADXP("Ontario", AddressPartType.State)
                }
            );
            myAddress.UseablePeriod = new SET<SXCM<TS>>((a,b)=>a.Value.DateValue.CompareTo(b.Value.DateValue));
            test.UseablePeriod.Add(
                new IVL<TS>(DateTime.Parse("1/12/2010"), DateTime.Parse("31/12/2010"))
            );
            ]]>
            </code>
            </example>
        </member>
        <member name="P:MARC.Everest.DataTypes.AD.IsNotOrdered">
            <summary>
            A boolean value specifying whether the order of the address parts is known or not
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.AD.IsValidBasicFlavor(MARC.Everest.DataTypes.AD)">
            <summary>
            Validates that <paramref name="n"/> conforms to AD.Basic Flavor
            </summary>
            <param name="n">The AD to validate</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.AD.FromSimpleAddress(MARC.Everest.DataTypes.PostalAddressUse,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Create an AD instance from simple address data
            </summary>
            <param name="use">The intended use of the address</param>
            <param name="addressLine1">The first address line of the address</param>
            <param name="addressLine2">The second address line of the address</param>
            <param name="city">The city the address should carry</param>
            <param name="state">The state the address should carry</param>
            <param name="country">The country the address should carry</param>
            <param name="zip">The zip code the address should carry</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.AD.ToString(System.String)">
            <summary>
            Represent this address as a string. Parts are formatted using the standard string.format notation
            </summary>
            <example>
            <code title="Writing AD structure to console" lang="cs">
            <![CDATA[
            Console.Write(test.ToString("{BNR} {STB} {STTYP} {DIR}\r\n{CTY}, 
            {STA}\r\n{CNT}\r\n{ZIP}")); 
            // Output: 
            // 123 Main Street West 
            // Hamilton, Ontario 
            // Canada 
            // L8K3K4 
            ]]>
            </code>
            </example>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.AD.ToString">
            <summary>
            Represent this address as a string. Parts appear in whatever order they appear in the sequence
            </summary>
            <remarks>
            The formatting string is referenced by <see cref="T:MARC.Everest.DataTypes.AddressPartType"/>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.AD.Validate">
            <summary>
            Validate the address
            </summary>
            <returns></returns>
            <remarks>
            Type is valid if:
                <list type="bullet">
                    <item>NullFlavor is not assigned, XOR</item>
                    <item>There is at least one part</item>
                </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.AD.ValidateEx">
            <summary>
            Extended validation method that returns the results of validation
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.AD.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.AD.Equals(MARC.Everest.DataTypes.AD)">
            <summary>
            Determine if this AD equals another
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.AD.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determines if this AD is semantically equal to <paramref name="other"/>
            </summary>
            <remarks>Two non-null, non-null flavored instances of AD are semantically equal when they contain
            the same parts regardless of order, and the <see cref="P:IsNotOrdered"/> and <see cref="P:Use"/> properties are equal to <paramref name="other"/></remarks>
        </member>
        <member name="T:MARC.Everest.DataTypes.AddressPartType">
            <summary>
            Identifies how an address part contributes to the address. 
            </summary>
            <example>
            In the address "123 Main Street W, Hamilton ON", the following address parts contribute to the address
            <list type="bullet">
                <item><b>123</b> - Building Number</item>
                <item><b>Main</b> - Street Name</item>
                <item><b>Street</b> - Street Type</item>
                <item><b>West</b> - Direction</item>
                <item><b>Hamilton</b> - City</item>
                <item><b>ON</b> - State</item>
            </list>
            </example>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.AddressLine">
            <summary>
            An address line is for either an additional locator, a delivery address or a street address.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.AdditionalLocator">
            <summary>
            This can be a unit designator such as apartment number, suite, etc...
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.UnitIdentifier">
            <summary>
            The number or name of a specific unit contained within a building
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.UnitDesignator">
            <summary>
            Indicates the type of specific unit contained within a building
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.DeliveryAddressLine">
            <summary>
            A delivery address line is frequently used instead of breaking out delivery mode, 
            delivery installation, etc...
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.DeliveryInstallationType">
            <summary>
            Indicates the type of delivery installation (facility to which the mail will be delivered prior
            to final shipping)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.DeliveryInstallationArea">
            <summary>
            The location of the delivery location, usually a town or city
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.DeliveryInstallationQualifier">
            <summary>
            A number, letter or name identifying a delivery location (eg: Station A)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.DeliveryMode">
            <summary>
            Indicates the type of service offered, method of delivery. Example: A PO box 
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.DeliveryModeIdentifier">
            <summary>
            Represents the routing information such as a letter carrier route number
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.StreetAddressLine">
            <summary>
            A full streeet address line, including number details and the street name and type 
            as appropriate
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.BuildingNumber">
            <summary>
            The number of a building, house or lot alongside the street
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.BuildingNumberNumeric">
            <summary>
            The numeric portion of a building number
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.BuildingNumberSuffix">
            <summary>
            Any alphabetic character, fraction or other text that may appear after 
            the numeric portion of a building number
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.StreetName">
            <summary>
            The name of the street including the type
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.StreetNameBase">
            <summary>
            The base name of a roadway, or artery recognized by a municipality
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.StreetType">
            <summary>
            The designation given to the street (avenue, crescent, street, etc)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.Direction">
            <summary>
            The direction (N,W,S,E)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.CareOf">
            <summary>
            The name of the party who will take receipt at the specified address
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.CensusTract">
            <summary>
            A geographic sub-unit delineated for demographic purposes
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.Country">
            <summary>
            Country
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.County">
            <summary>
            A sub-unit of a state or province (49 of the United States of America uses county while
            Louisiana uses the term "parish")
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.City">
            <summary>
            The name of the city, town, village, etc...
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.Delimiter">
            <summary>
            Delimiters are printed without framing white space
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.PostBox">
            <summary>
            A numbered box located in a post station
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.Precinct">
            <summary>
            A subsection of a municipality
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.State">
            <summary>
            A sub-unit of a country
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.AddressPartType.PostalCode">
            <summary>
            A postal code designating a region defined by the post service.
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.ADXP">
            <summary>
            A character string that may have a type-tag signifying its role in the address.
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ADXP.#ctor">
            <summary>
            Create a new instance of ADXP
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ADXP.#ctor(System.String,MARC.Everest.DataTypes.AddressPartType)">
            <summary>
            Create a new instance of ADXP using the values specified
            </summary>
            <param name="type">The address part type</param>
            <param name="value">The value of the type</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.ADXP.#ctor(System.String)">
            <summary>
            Create a new instance of ADXP using the value specified
            </summary>
            <param name="value">The value of the ADXP</param>
            <remarks>Type is set to "AddressLine"</remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.ADXP.op_Implicit(System.String)~MARC.Everest.DataTypes.ADXP">
            <summary>
            Convert a string into an address part
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ADXP.op_Implicit(MARC.Everest.DataTypes.ADXP)~System.String">
            <summary>
            Convert an ADXP into a string
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.ADXP.Value">
            <summary>
            The actual string value of the part
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.ADXP.Code">
            <summary>
            A code assigned to the part by some coding system if appropriate
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.ADXP.CodeSystem">
            <summary>
            The code system from which the code is taken
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.ADXP.CodeSystemVersion">
            <summary>
            The version of the coding system if required
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.ADXP.Type">
            <summary>
            Specified whether an address part names the street, city, country, etc.. If not specified, the
            address will appear on the label as is
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ADXP.ToString">
            <summary>
            Represent this value as a string
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ADXP.Validate">
            <summary>
            Validate this type
            </summary>
            <remarks>An address part type is valid if:
                <list type="bullet">
                    <item>NullFlavor is not assigned, XOR</item>          
                    <item>Value property has a value, AND</item>
                    <item>Code AND CodeSystem are Assigned OR Code is not assigned, AND</item>
                    <item>CodeSystemVersion AND CodeSystem are Assigned OR CodeSystemVersion is not assigned</item>             
                </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.ADXP.ValidateEx">
            <summary>
            Extended validation which returns the results of the validation
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ADXP.Equals(MARC.Everest.DataTypes.ADXP)">
            <summary>
            Determines if this ADXP equals another
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ADXP.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.ANY">
            <summary>
            Defines the basic properties of every data value. 
            </summary>
            <remarks>
            This is an abstract type meaning that no value
            can be just a data value without belonging to any concrete type. Every concrete type is a specialization
            of this general abstract data value type    
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.ANY.#ctor">
            <summary>
            Creates a new instance of the ANY class
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.ANY.NullFlavor">
            <summary>
            Gets or sets an exceptional <see cref="T:MARC.Everest.DataTypes.NullFlavor"/> value that identifies why the 
            contents of a datatype are not being processed.
            </summary>
            <remarks>
            Typically, when a null flavor is specified the data value within the instance is not written on the wire. For exceptions to this
            rule see the reference guide.
            <para>
            Null flavors are heirarchical and may imply one another. For example, a NullFlavor or PINF implies OTH which implies NI. <see cref="F:MARC.Everest.DataTypes.NullFlavorUtil.IsChildConcept(MARC.Everest.DataTypes.NullFlavor)"/>
            provides a mechanism for determining the implies relationship between null flavors
            </para>
            </remarks>
        </member>
        <member name="P:MARC.Everest.DataTypes.ANY.UpdateMode">
            <summary>
            Gets or sets the update mode of the datatype
            </summary>
            <remarks>
            the update mode dictates how a receiver will treat this particular data value when posted
            </remarks>
        </member>
        <member name="P:MARC.Everest.DataTypes.ANY.Flavor">
            <summary>
            Gets or sets the flavor identifier for the datatype
            </summary>
            <remarks>The flavor identifier is used by specializations to validate the contents of the datatype according
            to its value
            </remarks>
        </member>
        <member name="P:MARC.Everest.DataTypes.ANY.DataType">
            <summary>
            The data type of the value
            </summary>
            <remarks>Every proper data value implicitly carries information about its datatype
            </remarks>
        </member>
        <member name="P:MARC.Everest.DataTypes.ANY.IsNull">
            <summary>
            A predicate indicating that a value is an exceptional value or a null value
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ANY.Clone">
            <summary>
            Clone this object
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ANY.Equals(MARC.Everest.DataTypes.ANY)">
            <summary>
            Determine if this ANY is equal to another ANY
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ANY.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MARC.Everest.DataTypes.ANY.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)" -->
        <member name="M:MARC.Everest.DataTypes.ANY.Validate">
            <summary>
            Validate the ANY
            </summary>
            <remarks>An ANY is valid if the type is not ANY (is a subclass of ANY), or
            is an ANY, has a nullFlavor and the nullFlavor is not a child of Invalid</remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.ANY.ValidateEx">
            <summary>
            Validate the ANY meets validaton criteria and identifies the problems
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ANY.ToString">
            <summary>
            Represent this ANY instance as a string
            </summary>
            <remarks>Returns the HL7 datatype name and null-flavor if present</remarks>
        </member>
        <member name="T:MARC.Everest.DataTypes.BAG`1">
            <summary>
            An unordered list of collection values where each value can be contained more than once in the collection. 
            </summary>
            <remarks>
            <para>
                This class differs from a <see cref="T:MARC.Everest.DataTypes.LIST()"/> in that no meaning can be inferred from
                the order in which items appear in the BAG.
            </para>
            <para>
            This class behaves like the built in .NET <see cref="T:System.Collections.Generic.List()"/> class
            </para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.#ctor">
            <summary>
            Create a new instance of the BAG class
            </summary>
            
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.#ctor(System.Int32)">
            <summary>
            Create a new instance of the BAG class with the capacity specified
            </summary>
            <param name="capacity">The capacity</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create a new instance of the BAG class using the specified collection and comparator
            </summary>
            <example>
            <code title="Create a BAG object with an enumerable collection." lang="cs">
            <![CDATA[
            // This Bag contains an enumerable collection of Identifiers
            BAG<II> bag = new BAG<II>(new II[] {
                   new II("1.1.1.1", "1"),
                   new II(),
                   });
            // Inserts an Identifier at position one.       
            bag.Insert(1, new II("1.2.1.2", "1234")); 
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.#ctor(System.Collections.IEnumerable)">
            <summary>
            Create a new bag of items using values from another collection
            </summary>
            <param name="collection">The collection of items to add. Note: If an item does not match type <typeparamref name="T"/> it won't be added</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.CreateBAG(`0[])">
            <summary>
            Create a new instance of the BAG class using the specified <paramref name="item"/>
            </summary>
            <param name="items">The items to add to the collection</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.Find(System.Predicate{`0})">
            <summary>
            Find item in the collection that matches <paramref name="match"/>
            </summary>
            <param name="match">The predicate that specifies the criteria of the object to </param>
            <returns>The found object</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.FindAll(System.Predicate{`0})">
            <summary>
            Find all items in the collection that match <paramref name="match"/>
            </summary>
            <param name="match">The predicate that specifies the criteria to match</param>
            <returns>An enumerable collection of all found items</returns>
        </member>
        <member name="P:MARC.Everest.DataTypes.BAG`1.IsEmpty">
            <summary>
            Determine if the bag is empty
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.BAG`1.Items">
            <summary>
            Get the items in the collection
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.IndexOf(`0)">
            <summary>
            Get the index of an item
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.Insert(System.Int32,`0)">
            <summary>
            Insert an item into the collection
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.RemoveAt(System.Int32)">
            <summary>
            Remove an item from the collection
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.BAG`1.Item(System.Int32)">
            <summary>
            Indexor
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.Add(`0)">
            <summary>
            Add an item
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.Clear">
            <summary>
            Clear the items
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.Contains(`0)">
            <summary>
            Determine if the list contains an item
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the contents of this array to an array
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.BAG`1.Count">
            <summary>
            Get the number of items in the collection
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.BAG`1.IsReadOnly">
            <summary>
            Determine if the collection is read only
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.Remove(`0)">
            <summary>
            Remove an item from the collection
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.GetEnumerator">
            <summary>
            Get the enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.Validate">
            <summary>
            Validate the Bag
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.op_Explicit(MARC.Everest.DataTypes.LIST{`0})~MARC.Everest.DataTypes.BAG{`0}">
            <summary>
            Create a bag of T from Array o (shallow copy)
            </summary>
            <param name="o">The array of objects to add</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.Parse(MARC.Everest.DataTypes.LIST{MARC.Everest.Interfaces.IGraphable})">
            <summary>
            Create a set of T from Array o (shallow copy)
            </summary>
            <remarks>Usually called from the formatter</remarks>
            <param name="o">The array of objects to add</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determines if the current instance of BAG is semantically equal to <paramref name="other"/>
            </summary>
            <remarks>
            Two non-null, non null-flavored instances of BAG are semantically equal when they are empty or
            if they contain the same items (semantically) regardless of their order
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.Equals(MARC.Everest.DataTypes.BAG{`0})">
            <summary>
            Determine if this BAG of T equals another BAG of T
            </summary>
            <remarks>
            In this class, you will notice that we use the Find method for each item in this
            BAG within the other (ie: we search for an item matching each item in this bag to appear
            in the other). This is done because the BAG collection is unordered, so in theory
            the following BAGs are equal:
            <para>
                { 0, 2, 3, 1 }
            </para>
            <para>
            is equal to { 0, 1, 2, 3 }
            </para>
            <para>
            However two BAGs are not considered equal of the count of items are different, for example:
            </para>
            <para>
                { 0, 2, 3, 1 }
            </para>
            <para>
            is not equal to { 0, 1, 2, 3, 1 }
            </para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.BAG`1.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.BL">
            <summary>
            A binary value for use in boolean logic
            </summary>
            <remarks>
            <para>
            Business Name : BooleanValue
            </para>
            <para>
            This class provides a wrapper over a nullable boolean and provides three gate logic
            </para>
            </remarks>
            <example>
            <code title="Creating a boolean value three ways" lang="cs">
            <![CDATA[
            BL bool1, bool2, bool3;
            bool1 = false; // from a .NET boolean
            bool2 = new BL(false); // using constructor
            bool3 = coll1.Count > 0; // using logic
            ]]>
            </code>
            <code title="Using the BL class" lang="cs">
            <![CDATA[
            // In an ASPX page, determing if current user is administrator
            BL isAdmin = User.IsInRole("Administrators");
            // where response is an Everest message
            BL patientFound = response.controlActEvent.Subject.Count > 0;
            if(isAdmin && patientFound)
                Console.Write("You may edit this patient");
            else if(!patientFound)
                Console.Write("Could not find the patient");
            else if(!isAdmin)
                Console.Write("You are not an administrator");
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.#ctor">
            <summary>
            Create a new instance of BL
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.#ctor(System.Nullable{System.Boolean})">
            <summary>
            Create a new instance of BL with <paramref name="value"/> as initial value
            </summary>
            <param name="value">The value to set</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.IsValidNonNullFlavor(MARC.Everest.DataTypes.BL)">
            <summary>
            Validator for the NONULL flavor of anything that inherits from this class
            </summary>
            <param name="o">The BL to validate</param>
            <returns>True if validation succeeds</returns>
            <remarks>A BL meets validation criteria of BL.NONULL if
            <list type="bullet">
            <item>Null flavor is not assigned, AND</item>
            <item>Value is assigned</item>
            </list></remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.Not">
            <summary>
            Perform logical negation
            </summary>
            <example>
            <code title="Performing a NOT Operation" lang="cs">
            BL isTrue = true;
            Assert.IsFalse(isTrue.Not());
            </code>
            </example>
            <remarks>
            The Not operator as defined by HL7 has some caveats when dealing with nullFlavors in that a 
            BL with a nullFlavor that is NOTed will contain a NullFlavor (as per HL7v3 specification), however
            when cast to a bool will be false.
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.Xor(MARC.Everest.DataTypes.BL)">
            <summary>
            Perform a logical Xor
            </summary>
            <remarks>
            XOR returns true if b1 OR this is true but not both
            </remarks>
            <example>
            <code title="Performing an XOR" lang="cs">
            <![CDATA[
            BL isTrue = true, isFalse = false;
            BL xor = isTrue.Xor(isFalse);
            BL longCheck = isTrue.Or(isFalse).And(isTrue.And(isFalse).Not());
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.Or(MARC.Everest.DataTypes.BL)">
            <summary>
            Perform a logical or
            </summary>
            <param name="b1">The boolean value to compare to</param>
            <returns>The result of the OR operation</returns>
            <remarks>
            Implements a three gate logical OR, truth table is as follows:
            
            <table border="1">
                <tr>
                    <th>a/b</th>    
                    <th>F</th>
                    <th>T</th>
                    <th>Null</th>
                </tr>
                <tr>
                    <th>F</th>        
                    <td>F</td>
                    <td>T</td>
                    <td>Null</td>
                </tr>
                <tr>
                    <th>T</th>
                    <td>T</td>
                    <td>T</td>
                    <td>T</td>
                </tr>
                <tr>
                    <th>Null</th>
                    <td>Null</td>
                    <td>T</td>
                    <td>Null</td>
                </tr>
            </table>
            </remarks>
            <example>
            <code title="Performing an OR">
            <![CDATA[
            BL isTrue = true, isFalse = false;
            BL result = isTrue.Or(isFalse);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.And(MARC.Everest.DataTypes.BL)">
            <summary>
            Perform logical and
            </summary>
            <param name="b1">The value to compare to</param>
            <returns>The Result of the AND operation</returns>
            <remarks>
            Implements a three gate logical AND, truth table is as follows:
            
            <table border="1">
                <tr>
                    <th>a/b</th>    
                    <th>F</th>
                    <th>T</th>
                    <th>Null</th>
                </tr>
                <tr>
                    <th>F</th>        
                    <td>F</td>
                    <td>F</td>
                    <td>F</td>
                </tr>
                <tr>
                    <th>T</th>
                    <td>F</td>
                    <td>T</td>
                    <td>Null</td>
                </tr>
                <tr>
                    <th>Null</th>
                    <td>F</td>
                    <td>Null</td>
                    <td>Null</td>
                </tr>
            </table>
            </remarks>
            <example>
            <code title="Performing an OR">
            <![CDATA[
            BL isTrue = true, isFalse = false;
            BL result = isTrue.And(isFalse);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.Implies(MARC.Everest.DataTypes.BL)">
            <summary>
            Determines if <paramref name="other"/> implies this instance
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.ToString">
            <summary>
            Represents this BL as a string
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.op_Implicit(System.String)~MARC.Everest.DataTypes.BL">
            <summary>
            Converts a <see cref="T:System.String"/> to a <see cref="T:MARC.Everest.DataTypes.BL"/>
            </summary>
            <param name="s">string to convert</param>
            <returns>Converted BL</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.op_Explicit(MARC.Everest.DataTypes.BL)~System.Boolean">
            <summary>
            Converts a <see cref="T:MARC.Everest.DataTypes.BL"/> to a <see cref="T:System.Boolean"/>
            </summary>
            <param name="o">BL to convert</param>
            <returns>Converted Boolean, false if the original boolean is null or nullFlavored</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.op_Implicit(System.Boolean)~MARC.Everest.DataTypes.BL">
            <summary>
            Converts a <see cref="T:System.Boolean"/> to a <see cref="T:MARC.Everest.DataTypes.BL"/>
            </summary>
            <param name="o">Boolean to convert</param>
            <returns>Converted BL</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.op_Implicit(MARC.Everest.DataTypes.BL)~System.Nullable{System.Boolean}">
            <summary>
            Converts a <see cref="T:MARC.Everest.DataTypes.BL"/> to a <see cref="T:System.Boolean"/>
            </summary>
            <param name="o">BL to convert</param>
            <returns>Converted nullable Boolean</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.op_Implicit(System.Nullable{System.Boolean})~MARC.Everest.DataTypes.BL">
            <summary>
            Converts a <see cref="T:System.Boolean"/> to a <see cref="T:MARC.Everest.DataTypes.BL"/>
            </summary>
            <param name="o">Nullable Boolean to convert</param>
            <returns>Converted BL</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.op_BitwiseAnd(MARC.Everest.DataTypes.BL,MARC.Everest.DataTypes.BL)">
            <summary>
            Preforms a AND operation on two BLs.
            </summary>
            <param name="a">The first BL to AND with the second one.</param>
            <param name="b">The second BL to AND with the first BL.</param>
            <returns>The result of both input BLs ANDed together.</returns>
            <example>
            <code title="Using the &amp; Operator" lang="cs">
            <![CDATA[
            BL isTrue = true, isFalse = false;
            Assert.AreEqual(isTrue.And(isFalse), isTrue &amp;&amp; isFalse);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.op_BitwiseOr(MARC.Everest.DataTypes.BL,MARC.Everest.DataTypes.BL)">
            <summary>
            Preforms a OR operation on two BLs.
            </summary>
            <param name="a">The first BL to OR with the second one.</param>
            <param name="b">The second BL to OR with the first one.</param>
            <returns>The result of both input BLs ORed together.</returns>
            <example>
            <code title="Using the | Operator" lang="cs">
            <![CDATA[
            BL isTrue = true, isFalse = false;
            Assert.AreEqual(isTrue.Or(isFalse), isTrue || isFalse);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.op_ExclusiveOr(MARC.Everest.DataTypes.BL,MARC.Everest.DataTypes.BL)">
            <summary>
            Preforms a XOR operation on two BLs.
            </summary>
            <param name="a">The first BL to XOR with the second one.</param>
            <param name="b">The second BL to XOR with the first one.</param>
            <returns>The result of both input BLs XORed together.</returns>
            <example>
            <code title="Using the ^ Operator" lang="cs">
            <![CDATA[
            BL isTrue = true, isFalse = false;
            Assert.AreEqual(isTrue.Xor(isFalse), isTrue ^ isFalse);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.op_LogicalNot(MARC.Everest.DataTypes.BL)">
            <summary>
            Inverts the state of the input BL.
            </summary>
            <param name="a">A BL to invert.</param>
            <returns>The input BL in a state inverted form.</returns>
            <example>
            <code title="Using the ! Operator" lang="cs">
            <![CDATA[
            BL isTrue = true;
            Assert.AreEqual(isTrue.Not(), !isTrue);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.Equals(MARC.Everest.DataTypes.BL)">
            <summary>
            Determine if this BL is equal to another BL
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.CompareTo(MARC.Everest.DataTypes.BL)">
            <summary>
            Compare this boolean to other
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.BL.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determine if this BL semantically equals another
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.CodingRationale">
            <summary>
            A CD represents any kind of concept usually by giving a code defined in a code system. A CD builds upon a CE by allowing the assignment of qualifiers.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CodingRationale.Original">
            <summary>
            Originally produced code
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CodingRationale.PostCoding">
            <summary>
            Post coding from free text source
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CodingRationale.Required">
            <summary>
            Required by the specification describing the use of the coded concept
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CodingRationale.Source">
            <summary>
            The source of a required code
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.CD`1">
            <summary>
            Represents any kind of concept usually given by a code with qualifications.
            </summary>
            <remarks>
            <para>
            A CD represents any kind of concept usually by giving a code defined in a code system. A CD can contain 
            the original text or phrase that served as the basis of the coding and one or more translations into
            the same or different coding systems. A CD can also contain qualifiers to describe the concept of left foot
            as a postcoordinated term built from the primary code "FOOT"
            </para>
            Concept Descriptors are used to represent complex, codified concepts within an HL7v3 message. 
            </remarks>
            <example>
            <code title="Representing a complex code" lang="cs">
            <![CDATA[
            // Declare the Concept Descriptor (Burn of Skin)
            CD<String> cd = new CD<String>();
            cd.Code = "284196006";
            cd.DisplayName = "Burn of Skin";
            
            // Declare Severity as Severe so code becomes Severe Burn of Skin
            CR<String> severity = new CR<String>();
            severity.Name = new CD<string>();
            severity.Value = new CD<string>();
            cd.Qualifier = new LIST<CR<string>>();
            cd.Qualifier.Add(severity);
            severity.Name.Code = "246112005";
            severity.Name.CodeSystem = "2.16.840.1.113883.6.96";
            severity.Name.CodeSystemName = "SNOMED CT";
            severity.Name.DisplayName = "Severity";
            severity.Value.Code = "24484000";
            severity.Value.CodeSystem = "2.16.840.1.113883.6.96";
            severity.Value.CodeSystemName = "SNOMED CT";
            severity.Value.DisplayName = "Severe";
            
            // Identify the finding site so code becomes Severe Burn of Skin between Fourth and Fifth Toes
            CR findingsite = new CR();
            findingsite.Name = new CD<string>();
            findingsite.Value = new CD<string>();
            cd.Qualifier.Add(findingsite);
            findingsite.Name.Code = "363698007";
            findingsite.Name.CodeSystem = "2.16.840.1.113883.6.96";
            findingsite.Name.CodeSystemName = "SNOMED CT";
            findingsite.Name.DisplayName = "Finding site";
            findingsite.Value.Code = "113185004";
            findingsite.Value.CodeSystem = "2.16.840.1.113883.6.96";
            findingsite.Value.CodeSystemName = "SNOMED CT";
            findingsite.Value.DisplayName = "Skin between Fourth and Fifth Toes";
            
            // Identify the laterality so code becomes Severe Burn of Skin between Fourth and Fifth Toes on Left side
            CR laterality = new CR();
            laterality.Name = new CD<string>();
            laterality.Value = new CD<string>();
            findingsite.Value.Qualifier = new LIST<CR<string>>();
            findingsite.Value.Qualifier.Add(laterality);
            laterality.Name.Code = "272741003";
            laterality.Name.CodeSystem = "2.16.840.1.113883.6.96";
            laterality.Name.CodeSystemName = "SNOMED CT";
            laterality.Name.DisplayName = "Laterality";
            laterality.Value.Code = "7771000";
            laterality.Value.CodeSystem = "2.16.840.1.113883.6.96";
            laterality.Value.CodeSystemName = "SNOMED CT";
            laterality.Value.DisplayName = "Left";
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.CD`1.#ctor">
            <summary>
            Create a new instance of CD
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CD`1.#ctor(`0)">
            <summary>
            Create a new instance of CD with the specified code
            </summary>
            <param name="code">The initial code</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.CD`1.#ctor(`0,System.String)">
            <summary>
            Create a new instance of CD with the specified code and code system
            </summary>
            <param name="code">The initial code of the CS</param>
            <param name="codeSystem">The code system the code was picked from</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.CD`1.#ctor(`0,System.String,System.String,System.String)">
            <summary>
            Create a new instance of CD with the specified parameters
            </summary>
            <param name="code">The initial code</param>
            <param name="codeSystem">The code system the code was picked from</param>
            <param name="codeSystemName">The name of the code system</param>
            <param name="codeSystemVersion">The version of the code system</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.CD`1.#ctor(`0,System.String,System.String,System.String,MARC.Everest.DataTypes.ST,MARC.Everest.DataTypes.ED)">
            <summary>
            Create a new instance of the CD data type with the parameters specified
            </summary>
            <param name="code">The initial code</param>
            <param name="codeSystem">The code system the code was picked from</param>
            <param name="codeSystemName">The name of the code system</param>
            <param name="codeSystemVersion">The version of the code system</param>
            <param name="displayName">The display name for the code</param>
            <param name="originalText">The original text, the reason the code was selected</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.CD`1.#ctor(`0,System.String,System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.CD{`0}})">
            <summary>
            Create a new instance of CD with the specified code and code system
            </summary>
            <param name="code">The initial code of the CS</param>
            <param name="codeSystem">The code system the code was picked from</param>
            <param name="translation">Translations for this concept descriptor</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.CD`1.#ctor(`0,System.String,System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.CD{`0}},System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.CR{`0}})">
            <summary>
            Create a new instance of CD with the specified code and code system
            </summary>
            <param name="code">The initial code of the CS</param>
            <param name="codeSystem">The code system the code was picked from</param>
            <param name="translation">Translations for this concept descriptor</param>
            <param name="qualifier">Specified additional codes that increase the specificity of the primary code</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.CD`1.Qualifier">
            <summary>
            Specifies additonal codes that increase the specificity of the primary code
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CD`1.Validate">
            <summary>
            Validate
            </summary>
            <remarks>A concept descriptor is valid if:
            <list type="bullet">
                <item>All validation criteria from <see cref="T:MARC.Everest.DataTypes.CE{T}"/></item>
                <item>If a qualifier is specified, then a code must be specified</item>
            </list></remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.CD`1.ValidateEx">
            <summary>
            Validates the data type returning the validation errors that occur
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CD`1.DownParse(MARC.Everest.DataTypes.CD{`0})">
            <summary>
            Explicit operator for casting a CD of <typeparamref name="T"/>
            to a string
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CD`1.Parse(MARC.Everest.DataTypes.CD{System.String})">
            <summary>
            Converts a CD to a strongly typed CD
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CD`1.Parse(MARC.Everest.DataTypes.CE{System.String})">
            <summary>
            Converts a CE to a strongly typed CD
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CD`1.Parse(MARC.Everest.DataTypes.CV{System.String})">
            <summary>
            Converts a CV to a strongly typed CD
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CD`1.op_Implicit(MARC.Everest.DataTypes.CD{`0})~`0">
            <summary>
            Converts a <see cref="!:CD"/> to a <typeparamref name="T"/>
            </summary>
            <param name="o">CD`1 to convert</param>
            <returns>Converted T</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.CD`1.op_Implicit(`0)~MARC.Everest.DataTypes.CD{`0}">
            <summary>
            Converts a <typeparamref name="T"/> to a <see cref="!:CD"/>
            </summary>
            <param name="o">T to convert</param>
            <returns>Converted CD`1</returns>
        </member>
        <member name="P:MARC.Everest.DataTypes.CD`1.MARC#Everest#DataTypes#Interfaces#IConceptDescriptor#Qualifier">
            <summary>
            Specifies additonal codes that increase the specificity of the primary code
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CD`1.Comparator">
            <summary>
            Comparator for sets
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CD`1.Equals(MARC.Everest.DataTypes.CD{`0})">
            <summary>
            Determine if this CD of T is equal to another CD of T
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CD`1.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.CDGroup">
            <summary>
            A logically grouped list of related qualifiers
            </summary>
            <example>
            <code title="Creating a group of Qualifiers that have the same methods and properties" lang="cs">
            
            <![CDATA[
                CDGroup cdGroup01 = new CDGroup();
                // qualifier01 and qualifier02 are used from the previous example
                cdGroup01.Qualifier = new LIST<CR<string>> { qualifier01, qualifier02 };
                cdGroup01.Validate();
                cdGroup01.ControlActExt = "1.1.1.1";
            ]]>
            </code>
            </example> 
        </member>
        <member name="M:MARC.Everest.DataTypes.CDGroup.#ctor">
            <summary>
            Creates a new instance of the CDGroup class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CDGroup.#ctor(System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.CR{System.String}})">
            <summary>
            Creates a new instance of the CDGroup class using the specified list of <paramref name="qualifier"/>
            </summary>
            <param name="qualifier">The qualifier list to use</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.CDGroup.#ctor(MARC.Everest.DataTypes.LIST{MARC.Everest.DataTypes.CR{System.String}})">
            <summary>
            Creates a new instance of the CDGroup class using the specified reference to the LIST of <paramref name="qualifier"/>
            </summary>
            <param name="qualifier">A reference to the list of qualifiers to use</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.CDGroup.Qualifier">
            <summary>
            A list of qualifiers this group is composed of
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CDGroup.Validate">
            <summary>
            Validate all qualifiers
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CDGroup.Equals(MARC.Everest.DataTypes.CDGroup)">
            <summary>
            Determine if this CDGroup equals another CDGroup
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CDGroup.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.CE`1">
            <summary>
             Coded with Equalivalents
            </summary>
            <remarks>
            
            <para>Implements the CD.CE flavor.</para>
            <para>Represents a codified value with translations
            to other possible code systems</para>
            </remarks>
            <example>
            <code title="CE With Translation to internal Code System" lang="cs">
            <![CDATA[
            CE ce = new CE();
            ce.Code = "284196006";
            ce.CodeSystem = "2.16.840.1.113883.6.96";
            ce.CodeSystemName = "SNOMED CT";
            ce.DisplayName = "Burn of skin";
            ce.NullFlavor = null;
            ce.Translation = new SET<CD<string>>();
            ce.Translation.Add(
            new CD<string>()
            {
                Code = "15376812",
                CodeSystem = "2.16.840.1.113883.3.232.99.1",
                CodeSystemName = "3M HDD",
                DisplayName = "BurnOfSkinSCT",
                NullFlavor = null
            }
            );
            
            // using these values in the generic constructor CE<T>(T code, string codeSystem, IEnumerable<CD<T>> translation
            CE<String> practice2 = new CE<String>(ce.Code, ce.CodeSystem, ce.Translation);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.CE`1.#ctor">
            <summary>
            Create a new instance of CE
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CE`1.#ctor(`0)">
            <summary>
            Create a new instance of CE with the specified code
            </summary>
            <param name="code">The initial code</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.CE`1.#ctor(`0,System.String)">
            <summary>
            Create a new instance of CE with the specified code and code system
            </summary>
            <param name="code">The initial code of the CS</param>
            <param name="codeSystem">The code system the code was picked from</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.CE`1.#ctor(`0,System.String,System.String,System.String)">
            <summary>
            Create a new instance of CE with the specified parameters
            </summary>
            <param name="code">The initial code</param>
            <param name="codeSystem">The code system the code was picked from</param>
            <param name="codeSystemName">The name of the code system</param>
            <param name="codeSystemVersion">The version of the code system</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.CE`1.#ctor(`0,System.String,System.String,System.String,MARC.Everest.DataTypes.ST,MARC.Everest.DataTypes.ED)">
            <summary>
            Create a new instance of the CE data type with the parameters specified
            </summary>
            <param name="code">The initial code</param>
            <param name="codeSystem">The code system the code was picked from</param>
            <param name="codeSystemName">The name of the code system</param>
            <param name="codeSystemVersion">The version of the code system</param>
            <param name="displayName">The display name for the code</param>
            <param name="originalText">The original text, the reason the code was selected</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.CE`1.#ctor(`0,System.String,System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.CD{`0}})">
            <summary>
            Create a new instance of CE with the specified code and code system
            </summary>
            <param name="code">The initial code of the CS</param>
            <param name="codeSystem">The code system the code was picked from</param>
            <param name="translation">Translations for this concept descriptor</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.CE`1.Translation">
            <summary>
            Gets or sets a set of other concept descriptors that provide a translation of this concept descriptor in other code
            systems or a synonym to the code
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CE`1.Validate">
            <summary>
            Determines if the CE is valid.
            </summary>
            <remarks>
            A CE is valid when:
            <list type="bullet">
                <item><term>The base type is valid</term></item>
                <item><term>When a translation is specified, a code is specified</term></item>
                <item><item>None of the translations contain an original text, are valid and don't contain translations</item></item>
            </list>
            </remarks>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.CE`1.ValidateEx">
            <summary>
            Validate the data type returning the results of valiation
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CE`1.op_Implicit(MARC.Everest.DataTypes.CE{`0})~`0">
            <summary>
            Converts a <see cref="T:MARC.Everest.Datatypes.CE`1"/> to a <typeparamref name="T"/>
            </summary>
            <param name="o">CE`1 to convert</param>
            <returns>Converted T</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MARC.Everest.DataTypes.CE`1.op_Implicit(`0)~MARC.Everest.DataTypes.CE{`0}" -->
        <member name="M:MARC.Everest.DataTypes.CE`1.Parse(MARC.Everest.DataTypes.CE{System.String})">
            <summary>
            Converts a CE to a strongly typed CE
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CE`1.DownParse(MARC.Everest.DataTypes.CE{`0})">
            <summary>
            Explicit operator for casting a CE of <typeparamref name="T"/>
            to a string
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CE`1.Comparator">
            <summary>
            Comparator for sets
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.CE`1.MARC#Everest#DataTypes#Interfaces#ICodedEquivalents#Translation">
            <summary>
            Translations of the original code. 
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CE`1.Equals(MARC.Everest.DataTypes.CE{`0})">
            <summary>
            Determine if this CE of T equals another CE of T
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CE`1.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.CO">
            <summary>
            Represents data where coded values are associated with a specific order. 
            </summary>
            <remarks>
            <para>
            CO may be used for things that model rankings and scores (for example: pain, APGAR values, etc) where there
            is an implied ordering, no implication of the distance betweeen each value is constant and the
            total number of values is finite.
            </para>
            <para>
            The CO data type seems to completely change meaning in DT R2.  In DT R1, CO was an extension of CV
            with no added functionality. In DT R2, CO is a QTY with attached CD. This should be taken into account 
            by developers when writing structures that use the CO data type
            </para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.CO.#ctor">
            <summary>
            Creates a new instance of the CO class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CO.#ctor(System.Nullable{System.Decimal})">
            <summary>
            Creates a new instance of the CO class with the specified <paramref name="value"/>
            </summary>
            <param name="value">The initial value of the CO</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.CO.#ctor(MARC.Everest.DataTypes.CD{System.String})">
            <summary>
            Creates a new instance of the CO class with the specified <paramref name="code"/>
            </summary>
            <remarks>
            Recommended constructor call when using only R1 formatter
            </remarks>
            <param name="code">A code value that defines the CO ordinal</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.CO.#ctor(System.Nullable{System.Decimal},MARC.Everest.DataTypes.CD{System.String})">
            <summary>
            Creates a new instance of the CO class with the specified <paramref name="code"/> and <paramref name="value"/>
            </summary>
            <param name="value">The initial value of the CO instance</param>
            <param name="code">A code value that defines the CO ordinal</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.CO.Code">
            <summary>
            Gets or sets the code that represents the definition of the ordinal item
            </summary>
            <remarks>
            When using datatypes R1 formatter, this will be the only data that is serialized
            to the wire. All other properties are ignored by the R1 formatter
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.CO.Validate">
            <summary>
            Validate to invariant rules, checks to make sure that things that are supposed to be set are set
            </summary>
            <remarks>A CO is valid when either a nullflavor is specified or 
            a value and code are specified (but not both)</remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.CO.ValidateEx">
            <summary>
            Validate the data type returning the validation errors that occur
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CO.Equals(MARC.Everest.DataTypes.CO)">
            <summary>
            Determine if this CO equals another CO
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CO.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CO.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determine semantic equality to a coded simple
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.COLL`1">
            <summary>
            An abstract type intended to collect common functionality related to collections
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.COLL`1.Items">
            <summary>
            Gets the contents of the collection
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.COLL`1.IncludesAll(MARC.Everest.DataTypes.Interfaces.IColl{`0})">
            <summary>
            Returns true if <paramref name="other"/> contains all the items 
            in this list
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.COLL`1.ExcludesAll(MARC.Everest.DataTypes.Interfaces.IColl{`0})">
            <summary>
            Returns true if <paramref name="other"/> does not contain any of the 
            items in this list
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.COLL`1.Validate">
            <summary>
            Validate the collection. 
            </summary>
            <remarks>
            A collection is considered valid when <see cref="P:NullFlavor"/> is set xor
            the collection is not empty.
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.COLL`1.Find(System.Predicate{`0})">
            <summary>
            Find all items that match the given predicate
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.COLL`1.FindAll(System.Predicate{`0})">
            <summary>
            Find all occurences of <paramref name="match"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.COLL`1.ValidateEx">
            <summary>
            Validate the data type returning the validation errors that occur
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.COLL`1.IndexOf(`0)">
            <summary>
            Gets the index of the specified <paramref name="item"/> 
            within the collection.
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.COLL`1.Insert(System.Int32,`0)">
            <summary>
            Inserts <paramref name="item"/> at the specified 
            <paramref name="index"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.COLL`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item at the specified <paramref name="index"/>
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.COLL`1.Item(System.Int32)">
            <summary>
            Indexer property for the collection
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.COLL`1.Add(`0)">
            <summary>
            Adds <paramref name="item"/> to the collection
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.COLL`1.Clear">
            <summary>
            Clears the collection
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.COLL`1.Contains(`0)">
            <summary>
            Returns true if the current collection contains <paramref name="item"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.COLL`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the contents of this collection to <paramref name="array"/>
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.COLL`1.Count">
            <summary>
            Gets the number of items that are in the collection
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.COLL`1.IsReadOnly">
            <summary>
            Gets a value indicating if the collection is in a read only state
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.COLL`1.Remove(`0)">
            <summary>
            Removes the specified <paramref name="item"/> from the collection
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.COLL`1.GetEnumerator">
            <summary>
            Gets the enumerator for the collection
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.COLL`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get the enumerator for the collection
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.COLL`1.IsEmpty">
            <summary>
            Returns a value that indicates if the item is empty
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.COLL`1.Equals(MARC.Everest.DataTypes.COLL{`0})">
            <summary>
            Determine if this SET of T equals another SET of T
            </summary>
            <remarks>
            This equality method differs from the <see cref="T:MARC.Everest.DataTypes.BAG{T}"/> and <see cref="T:MARC.Everest.DataTypes.LIST{T}"/>
            in that it not only compares the contents of each set to ensure that all data is present in both sets, it uses the comparator of 
            this set to determine if the "item" is the same (rather than the equality method)
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.COLL`1.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Converters.SimpleSiUnitConverter">
            <summary>
            An implementation of the IUnitConverter for converting
            SI units
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Converters.SimpleSiUnitConverter.CanConvert(MARC.Everest.DataTypes.PQ,System.String)">
            <summary>
            Returns true if <paramref name="from"/> can be converted
            to the <paramref name="unitTo"/>
            </summary>
            <exception cref="T:System.ArgumentNullException">If any of the arguments are Null or NullFlavored</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.Converters.SimpleSiUnitConverter.GetSiUnit(System.String)">
            <summary>
            Get SI portions of the specified unit
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Converters.SimpleSiUnitConverter.Convert(MARC.Everest.DataTypes.PQ,System.String)">
            <summary>
            Convert <paramref name="original"/> to a new instance
            of PQ with the unit <paramref name="unitTo"/>
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IAny">
            <summary>
            Identifies an interface that the ANY data type implements
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Interfaces.IAny.Validate">
            <summary>
            Validates the instance 
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IAny.IsNull">
            <summary>
            Predicate that determines if the instance is logically null
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IAny.DataType">
            <summary>
            Gets the data type of the instance 
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IAny.Flavor">
            <summary>
            Gets or sets the flavor of the type
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Interfaces.IAny.ValidateEx">
            <summary>
            Validates the type and returns the detected issues with the data type instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IBooleanValue">
            <summary>
            Indicates a class implements a boolean value
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.ICodedEquivalents">
            <summary>
            Summary for ICodedExtended
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ICodedEquivalents.Translation">
            <summary>
            A set of other concept descriptors that provide a translation of this concept descriptor in other code
            systems or a synonym to the code
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.ICodedSimple">
            <summary>
            Represents basic data for a coded simple
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ICodedSimple.CodeValue">
            <summary>
            Get the code value
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.ICodedSimple`1">
            <summary>
            Identifies a class as implementing coded simple
            </summary>
            <typeparam name="T">The code system the codes may come from</typeparam>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ICodedSimple`1.Code">
            <summary>
            The code mnemonic
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.ICodedValue">
            <summary>
            Represents a coded value
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ICodedValue.CodeSystem">
            <summary>
            The code system this code mnemonic comes from
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ICodedValue.CodeSystemName">
            <summary>
            The name of the code system
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ICodedValue.CodeSystemVersion">
            <summary>
            The version of the code system
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ICodedValue.DisplayName">
            <summary>
            Display name for the code
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ICodedValue.ValueSet">
            <summary>
            Identifies the value set that was applicable at the time of coding
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ICodedValue.ValueSetVersion">
            <summary>
            Identifies the version of the value set that was applicable at the time of coding
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ICodedValue.CodingRationale">
            <summary>
            Coding rationale
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IColl">
            <summary>
            Identfies a class that can determine if it is empty
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IColl.IsEmpty">
            <summary>
            Determine if the collection is empty
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IColl`1">
            <summary>
            Identifies a class as implementing the ICollection interface
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IColl`1.Items">
            <summary>
            Items to be represented
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Interfaces.IColl`1.IncludesAll(MARC.Everest.DataTypes.Interfaces.IColl{`0})">
            <summary>
            Returns true if this instance of IColl contains all the elements of <paramref name="other"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Interfaces.IColl`1.ExcludesAll(MARC.Everest.DataTypes.Interfaces.IColl{`0})">
            <summary>
            Returns true if this instance of IColl contains none of the elements of <paramref name="other"/>
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IConceptDescriptor">
            <summary>
            Identifies a class as implementing a concept descriptor
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IConceptDescriptor.Qualifier">
            <summary>
            Specifies additonal codes that increase the specificity of the primary code
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IConceptQualifier">
            <summary>
            Identifies an entity as implementing the concept qualifier
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IConceptQualifier.Name">
            <summary>
            Specifies the manner in which the concept role value contributes to the meaning of a code phrase
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IConceptQualifier.Value">
            <summary>
            The concept that modifies the primary code of a code phrase through the role relation
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IConceptQualifier.Inverted">
            <summary>
            Indicatestif the sense of name is inverted
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IDistanceable`1">
            <summary>
            This interface is implemented by classes 
            where the distance between two instances 
            can be calculated
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Interfaces.IDistanceable`1.Distance(`0)">
            <summary>
            Calculate the distance between 
            this and <paramref name="other"/>
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.EncapsulatedDataCompression">
            <summary>
            Supported data compression algorithms
            </summary>
            <remarks>
            Only the two formats supported by the system are listed
            </remarks>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.EncapsulatedDataCompression.DF">
            <summary>
            Deflate
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.EncapsulatedDataCompression.GZ">
            <summary>
            GZIP
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.EncapsulatedDataCompression.ZL">
            <summary>
            ZLib
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.EncapsulatedDataCompression.Z">
            <summary>
            Compress
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.EncapsulatedDataCompression.BZ">
            <summary>
            BZIP
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.EncapsulatedDataCompression.Z7">
            <summary>
            7z Compression
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.EncapsulatedDataRepresentation">
            <summary>
            Representation of the encapsulated data
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.EncapsulatedDataRepresentation.TXT">
            <summary>
            Data should be represented in plain text
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.EncapsulatedDataRepresentation.B64">
            <summary>
            Data should be base64 encoded
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.EncapsulatedDataRepresentation.XML">
            <summary>
            Data is xml encoded
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.EncapsulatedDataIntegrityAlgorithm">
            <summary>
            Representation of how an ED should be checksummed
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.EncapsulatedDataIntegrityAlgorithm.SHA1">
            <summary>
            Using a SHA1 hash
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.EncapsulatedDataIntegrityAlgorithm.SHA256">
            <summary>
            Using a SHA256 hash
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IEncapsulatedData">
            <summary>
            Identifies that a class implements (or is compatible with) an IEncapsulatedData 
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IEncapsulatedData.Data">
            <summary>
            Represents the data contained within the encapsulated data
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IEncapsulatedData.Representation">
            <summary>
            Get or set the desired representation
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IEncapsulatedData.Language">
            <summary>
            Get or set the language
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IEncapsulatedData.MediaType">
            <summary>
            Get or set the media type
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IEncapsulatedData.IntegrityCheck">
            <summary>
            Get the integrity check
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IEncapsulatedData.IntegrityCheckAlgorithm">
            <summary>
            Get or set the integrity check algorithm  to use
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IEncapsulatedData.Thumbnail">
            <summary>
            Get or set a thumbnail represetnation of this ED
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IEncapsulatedData.Reference">
            <summary>
            Get or set the reference to the data
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IEncapsulatedData.Compression">
            <summary>
            Get or set the compression algorithm used for the data
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IImplicitInterval`1">
            <summary>
            Identifies that the type has a precision that can be
            turned into an interval
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Interfaces.IImplicitInterval`1.ToIVL">
            <summary>
            Convert the object to an interval
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IListContainer">
            <summary>
            Represents a structure that contains a set
            </summary>
            <remarks>
            This interface is primarily used by formatters which must be able to populate
            a list of a known interface (IGraphable) without knowing the specific 
            types in the constructed instance.
            </remarks>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IListContainer.ContainedList">
            <summary>
            The contained list
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.INormalizable">
            <summary>
            Classes the implement the INormalizable interface
            represent a hybrid where the structure needs to be 
            normalized prior to serialization
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Interfaces.INormalizable.Normalize">
            <summary>
            Normalize the structure
            </summary>
            <returns></returns>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IOrderedDataType`1">
            <summary>
            Identifies that a data type is ordered
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Interfaces.IOrderedDataType`1.NextValue">
            <summary>
            Increment the current instance into a new instance of <typeparamref name="T"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Interfaces.IOrderedDataType`1.PreviousValue">
            <summary>
            Decrement the current instance into a new instance of <typeparamref name="T"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IInstanceIdentifier">
            <summary>
            Identifies a class as an instance Identifier
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IInstanceIdentifier.Root">
            <summary>
            The root of the instance identifier
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IInstanceIdentifier.Extension">
            <summary>
            The extension of the instance identifier
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IInstanceIdentifier.Use">
            <summary>
            The use of the instance identifier
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IInstanceIdentifier.Displayable">
            <summary>
            True if the instance identifier is intended for display
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IInstanceIdentifier.AssigningAuthorityName">
            <summary>
            The name of the authority that assigned the identifier
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IIntegerValue">
            <summary>
            Identifies a class implements the integer value structure
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IInterval`1">
            <summary>
            Identifies an interval
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IInterval`1.Low">
            <summary>
            Low value in the set
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IInterval`1.LowClosed">
            <summary>
            True if the bottom bounds is inclusive of the set
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IInterval`1.High">
            <summary>
            High value in the set
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IInterval`1.HighClosed">
            <summary>
            True if the top bound is inclusive of the set
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IInterval`1.Width">
            <summary>
            Width of the interval
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IOriginalText">
            <summary>
            Identifies that a particular data type has an original text value
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IOriginalText.OriginalText">
            <summary>
            the original text for the item
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IPointInTime">
            <summary>
            Identifies a class that implements a point in time (TS) specification
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IPqScalar`1">
            <summary>
            Identifies classes that can be scaled 
            by another PQ
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Interfaces.IPqScalar`1.Scale(MARC.Everest.DataTypes.PQ)">
            <summary>
            Scale the current instance by
            the specified <paramref name="scale"/>
            </summary>
            <remarks>Results in a new <paramref name="T"/> scaled by
            <paramref name="scale"/></remarks>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IPqTranslatable`1">
            <summary>
            Identifies classes that can be translated
            by a PQ value
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Interfaces.IPqTranslatable`1.Translate(MARC.Everest.DataTypes.PQ)">
            <summary>
            Translates the value by the specified 
            <paramref name="translation"/> by adding
            the PQ to the current instance.
            </summary>
            <remarks>Results in a new instance of <typeparamref name="T"/> 
            that is translated by the specified amount</remarks>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IPrimitiveDataValue">
            <summary>
            Primitive data value
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IPrimitiveDataValue.Value">
            <summary>
            Get the value of the primitive data vlaue
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IPrimitiveDataValue`1">
            <summary>
            Identifies that a class is a PDV
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IPrimitiveDataValue`1.Value">
            <summary>
            Get or set the value of the primitive data value
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IProbability">
            <summary>
            Represents a value with the probability the value is accurate
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IProbability.Probability">
            <summary>
            Gets or sets the probability that the value
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.QuantityUncertaintyType">
            <summary>
            Identifies type of uncertainty distributions
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.QuantityUncertaintyType.Uniform">
            <summary>
            The The uniform distribution assigns a constant probability over the entire interval 
            of possible outcomes
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.QuantityUncertaintyType.Normal">
            <summary>
            This is the well-known bell-shaped normal distribution
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.QuantityUncertaintyType.LogNormal">
            <summary>
            The logarithmic normal distribution is used to transform skewed random variable X into a normally
            distributed random variable
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.QuantityUncertaintyType.Gamma">
            <summary>
            The gamma-distribution used for data that is skewed and bounded to the right
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.QuantityUncertaintyType.Exponential">
            <summary>
            Used for data that describes extinction
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.QuantityUncertaintyType.X2">
            <summary>
            Used to describe the sum of squares of random variables that occurs when a varience is estimated
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.QuantityUncertaintyType.TDistribution">
            <summary>
            Used to describe the quotient of a normal random variable and the square root of a X^2 random variable
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.QuantityUncertaintyType.F">
            <summary>
            Used to describe the quotient of two X^2 random variables
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.QuantityUncertaintyType.Beta">
            <summary>
            The beta distribution is used for data that is bounded on both sides and may or may not be skewed.
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IQuantity">
            <summary>
            Non-genericized interface that dictates a class as a quantity
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IQuantity.Expression">
            <summary>
            The expression that represents the quantity
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IQuantity.OriginalText">
            <summary>
            Get or set the original text from which the text was derived
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IQuantity.Uncertainty">
            <summary>
            Get or set the uncertaint of the quantity using a distribution function
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IQuantity.UncertaintyType">
            <summary>
            Get or set the uncertainty type
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IQuantity.UncertainRange">
            <summary>
            Uncertainty range
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Interfaces.IQuantity.ToDouble">
            <summary>
            Convert the fractional number to a double
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IBag`1">
            <summary>
            Identifies that a class implements an unordered list of values
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IRealValue">
            <summary>
            Identifies a class which contains a number with floting point precision
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.IRealValue.Precision">
            <summary>
            Get or set the precision
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.ISampledList">
            <summary>
            Sampled list
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ISampledList.Origin">
            <summary>
            Gets or sets the origin
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ISampledList.Scale">
            <summary>
            Gets or sets the scale
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ISampledList.Items">
            <summary>
            Gets or sets the digits
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.ISemanticEquatable">
            <summary>
            Identifies a class that has the ability to compare itself
            not only on Equals but on semantic equality
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Interfaces.ISemanticEquatable.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determines if the instance is equal to <paramref name="other"/>
            </summary>
            <param name="other">The other object to compare to</param>
            <returns>True if the two objects are semantically equal</returns>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.ISequence`1">
            <summary>
            Identifies a class as implementing a sequence of items whereby the order of items has meaning
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ISequence`1.First">
            <summary>
            First item in the sequence
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ISequence`1.Last">
            <summary>
            Last item in the sequence
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Interfaces.ISequence`1.SubSequence(System.Int32,System.Int32)">
            <summary>
            Select a sub-section of the list
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Interfaces.ISequence`1.SubSequence(System.Int32)">
            <summary>
            Select a sub-section of the list
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.ISet`1">
            <summary>
            Identifies a set that contains distinct values in no order
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ISet`1.Comparator">
            <summary>
            The comparator for this set
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.ISetComponent`1">
            <summary>
            Represents a set component that can be used as part of
            a DataTypes R1 SXPR or DataTypes R2 QSET
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.TelecommunicationCabability">
            <summary>
            Identifies mechanisms that are supported by a telecommunications address
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.TelecommunicationCabability.Voice">
            <summary>
            The device can receive voice calls
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.TelecommunicationCabability.Fax">
            <summary>
            The device can receive fax data
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.TelecommunicationCabability.Data">
            <summary>
            The device can receive a data stream
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.TelecommunicationCabability.Text">
            <summary>
            The device can receive text telephone calls 
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.TelecommunicationCabability.SMS">
            <summary>
            The device can receive SMS messages
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.TelecommunicationAddressUse">
            <summary>
            Identifies ways in which a telecommunications address can be used
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.TelecommunicationAddressUse.Home">
            <summary>
            Identifies a communication address at a home. Should not be used 
            for business purposes.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.TelecommunicationAddressUse.PrimaryHome">
            <summary>
            The primary address to reach a contact after business hours
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.TelecommunicationAddressUse.VacationHome">
            <summary>
            A vacation home to reach a person while on vacation
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.TelecommunicationAddressUse.WorkPlace">
            <summary>
            An office address, should be used for business communications
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.TelecommunicationAddressUse.Direct">
            <summary>
            Indicates a workplace address that reaches the person directly without
            intermediaries (for example a private line)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.TelecommunicationAddressUse.Public">
            <summary>
            Indicates an address that is a standard address that may be 
            subject to a switchboard or operator prior to reaching the intended
            entity.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.TelecommunicationAddressUse.BadAddress">
            <summary>
            When set, indicates that an address is bad and is useless
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.TelecommunicationAddressUse.TemporaryAddress">
            <summary>
            A temporary address that may be good for visiting or mailing
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.TelecommunicationAddressUse.AnsweringService">
            <summary>
            An automatic answering machine that can be used for less urgent communications
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.TelecommunicationAddressUse.EmergencyContact">
            <summary>
            A contact that is designated for contact in case of an emergency
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.TelecommunicationAddressUse.MobileContact">
            <summary>
            A telecommunication device that is kept with the entity as they move such as a
            mobile device
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Interfaces.TelecommunicationAddressUse.Pager">
            <summary>
            A paging device that can be used to solicit a callback
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.ITelecommunicationAddress">
            <summary>
            Indicates that a class implements a telecommunications address
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ITelecommunicationAddress.Value">
            <summary>
            The value of the communications
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ITelecommunicationAddress.Use">
            <summary>
            Indicates how the tel address can be used
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Interfaces.ITelecommunicationAddress.UseablePeriod">
            <summary>
            Indicates the period that this particular telecommunications address is valid
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.IUnitConverter">
            <summary>
            Identifies a structure that the PQ data type
            can use to convert units to/from other units
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Interfaces.IUnitConverter.CanConvert(MARC.Everest.DataTypes.PQ,System.String)">
            <summary>
            Returns true if the <paramref name="from"/> can be converted
            to <paramref name="unitTo"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Interfaces.IUnitConverter.Convert(MARC.Everest.DataTypes.PQ,System.String)">
            <summary>
            Converts <paramref name="original"/> to a new
            instance of PQ with the <paramref name="unitTo"/>
            unit
            </summary>
            <remarks>Implementers must create a new PQ during this process</remarks>
        </member>
        <member name="T:MARC.Everest.DataTypes.Interfaces.NamespaceDoc">
            <summary>
            The namespace in which data type interfaces reside 
            </summary>
            <remarks>
            <para>The interfaces within the MARC.Everest.Interfaces namespace
            are used by the data types to establish common functionality between
            data types. These interfaces can then be used by formatters to 
            and populate instances of classes easily.</para>
            <para>Also, these interfaces can be used by developers to use
            common functionality between like classes. For example, the 
            <see cref="T:MARC.Everest.DataTypes.LIST{T}"/> and <see cref="T:MARC.Everest.DataTypes.BAG{T}"/>
            are both collections, and thus, both implement the <see cref="T:MARC.Everest.Interfaces.IColl{T}"/></para>
            </remarks>
        </member>
        <member name="T:MARC.Everest.DataTypes.CR`1">
            <summary>
            A concept qualifier code with optionally named role. 
            </summary>
            <remarks>
            Both the qualifier role and value codes must 
            be defined by the coding system of the CD containing the concept qualifier.
            </remarks>
            <example>
            An example of the use of CR can be seen in the <see cref="T:MARC.Everest.DataTypes.CD{}"/> datatype
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.CR`1.#ctor">
            <summary>
            Default constructor for the CR type
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CR`1.#ctor(MARC.Everest.DataTypes.CV{`0},MARC.Everest.DataTypes.CD{`0})">
            <summary>
            Creates a CR instance with the specified <paramref name="name"/> and <paramref name="value"/>
            </summary>
            <param name="name">The name of the qualifier</param>
            <param name="value">The value of the qualifier</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.CR`1.Name">
            <summary>
            Specifies the manner in which the concept role value contributes to the meaning of a code phrase
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.CR`1.Value">
            <summary>
            The concept that modifies the primary code of a code phrase through the role relation
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.CR`1.Inverted">
            <summary>
            Indicates if the sense of the name is inverted
            </summary>
            <remarks>
            <para>To be used when a code system supports inversion but does not provide inverted concepts. For example, the concept of "causes" could be
            inverted to "caused-by" by setting the inverted flag to true if the concept domain does not provide
            a "caused-by" code.</para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.CR`1.Validate">
            <summary>
            Validate this item
            </summary>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.CR`1.ValidateEx">
            <summary>
            Validates this instance of the data type and returns the validations errors
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.CR`1.MARC#Everest#DataTypes#Interfaces#IConceptQualifier#Name">
            <summary>
            Specifies the manner in which the concept role value contributes to the meaning of a code phrase
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.CR`1.MARC#Everest#DataTypes#Interfaces#IConceptQualifier#Value">
            <summary>
            The concept that modifies the primary code of a code phrase through the role relation
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CR`1.Comparator">
            <summary>
            Comparator for sets
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CR`1.Parse(MARC.Everest.DataTypes.CR{System.String})">
            <summary>
            Operator casts a <see cref="T:CR"/> to a genericized CR
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CR`1.DownParse(MARC.Everest.DataTypes.CR{`0})">
            <summary>
            Operator casts a <see cref="T:CR"/> to a non-genericized CR
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CR`1.Equals(MARC.Everest.DataTypes.CR{`0})">
            <summary>
            Determine if this CR of T is equal to another CR of T
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CR`1.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.CS`1">
            <summary>
            Coded data in its simplest form where only the code is not predetermined. 
            </summary>
            <remarks>
            The code system and code system version are implied and fixed by the context in which the CS value occurs.
            </remarks>
            <example>
            <code lang="cs">
            <![CDATA[
               // Creating an instance
               PRLO_IN202010CA instance = new PRLO_IN202010CA();
               // Using direct assignment
               instance.ResponseModeCode = new CS<ResponseMode>(ResponseMode.Queue);
               // Using properties
               instance.ResponseModeCode = new CS<ResponseMode>();
               instance.ResponseModeCode.Code = ResponseMode.Queue;
            ]]>
            </code>
            </example>
        </member>
        <member name="F:MARC.Everest.DataTypes.CS`1.m_code">
            <summary>
            The code that is being used in this coded simple
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CS`1.#ctor">
            <summary>
            Create a new instance of CS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CS`1.#ctor(`0)">
            <summary>
            Create a new instance of CS with the specified code
            </summary>
            <param name="code">The initial code</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.CS`1.Code">
            <summary>
            The plain code symbol defined by the code system
            </summary>
            <remarks>The type of this property is a CodeValue&lt;<typeparam name="T"/>. This allows
            codes outside of the bound code system to be specified. 
            <example>
                <code title="Using codes outside of bound code system" lang="cs">
            <![CDATA[
               CS<AdministrativeGender> adminCode = Util.Convert<CS<AdministrativeGender>>("MAN");
            ]]>
                </code>
            </example>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.CS`1.ToString">
            <summary>
            Represent this as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.CS`1.Validate">
            <summary>
            Validate
            </summary>
            <remarks>
            A coded simple is valid if:
            <list type="bullet">
                <item>NullFlavor is specified, XOR</item>
                <item>
                    <list type="bullet">
                        <item>Code is specified, AND</item>
                        <item>If Alternate (not in bound domain) code is specified, a CodeSystem is specified</item>
                    </list>
                </item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.CS`1.ValidateEx">
            <summary>
            Validate the CS is valid, returning the detected issues
            </summary>
            <remarks>
            An instance of CS is valid when:
            <list type="number">
                <item><description>All validation from <see cref="T:ANY"/> succeeds</description></item>
                <item><description>This instance of CS contains a <see cref="P:Code"/> or <see cref="P:NullFlavor"/> but not both, and</description></item>
                <item><description>The <see cref="P:Code"/> specified is in the <typeparamref name="T"/> domain</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.CS`1.Parse(MARC.Everest.DataTypes.CS{System.String})">
            <summary>
            Converts a <see cref="!:CS"/> to a <see cref="!:CS"/>
            </summary>
            <param name="cs">CS to convert</param>
            <returns>Converted CS`1</returns>
            <remarks>Is a parse function as the string must be parsed by util</remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.CS`1.Parse(System.String)">
            <summary>
            Converts a <see cref="T:System.String"/> to a <see cref="!:CS"/>
            </summary>
            <param name="s">string to convert</param>
            <returns>Converted CS`1</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.CS`1.op_Implicit(MARC.Everest.DataTypes.CS{`0})~`0">
            <summary>
            Converts a <see cref="!:CS"/> to a <typeparamref name="T"/>
            </summary>
            <param name="o">CS`1 to convert</param>
            <returns>Converted T</returns>
            <exception cref="T:System.InvalidCastException">When the code value is null</exception>
            <exception cref="T:System.InvalidOperationException">When the code is bound to an enumerated vocabulary set and the value lies outside of the acceptable range (example: MMALE for AdministrativeGender)</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.CS`1.op_Implicit(`0)~MARC.Everest.DataTypes.CS{`0}">
            <summary>
            Converts a <typeparamref name="T"/> to a <see cref="!:CS"/>
            </summary>
            <param name="o">T to convert</param>
            <returns>Converted CS</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.CS`1.GetType">
            <summary>
            Hides the default implementation of GetType
            </summary>
            <remarks>This is used to force formatters to "cast"
            data from the bound data type <typeparamref name="T"/>
            to a CS&lt;T></remarks>
        </member>
        <member name="P:MARC.Everest.DataTypes.CS`1.CodeValue">
            <summary>
            Get the code value as a generic object
            </summary>
            <remarks>
            Used primarily for formatters
            </remarks>
        </member>
        <member name="F:MARC.Everest.DataTypes.CS`1.Comparator">
            <summary>
            Default comparator for CS
            </summary>
            <remarks>This should be used when creating sets of CS</remarks>
            <example>
            <code title="Set of CS" lang="cs">
            <![CDATA[
            SET<CS<String>> csSet = new SET<CS<String>>(CS<String>.Comparator);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.CS`1.Equals(MARC.Everest.DataTypes.CS{`0})">
            <summary>
            Determine if this CS is equal to another CS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CS`1.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CS`1.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determines semantic equality of this instance with another
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CS`1.Equals(`0)">
            <summary>
            Determine if this equals
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.CV`1">
            <summary>
            Represents codified data whereby the codified value and code system are unknown
            </summary>
            <remarks>
            The coded value data type is an example of a flavor that has been mapped into a full class in order to remain compatible with R1 data types. In R2 the CV data type is actually the CD (Concept Descriptor) data type with a flavor of CV.
            CV extends the CS data type by adding display name, coding rationale, and original text.
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.CV`1.#ctor">
            <summary>
            Create a new instance of CV
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CV`1.#ctor(`0)">
            <summary>
            Create a new instance of CV with the specified code
            </summary>
            <param name="code">The initial code</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.CV`1.#ctor(`0,System.String)">
            <summary>
            Create a new instance of CV with the specified code and code system
            </summary>
            <param name="code">The initial code of the CS</param>
            <param name="codeSystem">The code system the code was picked from</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.CV`1.#ctor(`0,System.String,System.String,System.String)">
            <summary>
            Create a new instance of CV with the specified parameters
            </summary>
            <param name="code">The initial code</param>
            <param name="codeSystem">The code system the code was picked from</param>
            <param name="codeSystemName">The name of the code system</param>
            <param name="codeSystemVersion">The version of the code system</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.CV`1.#ctor(`0,System.String,System.String,System.String,MARC.Everest.DataTypes.ST,MARC.Everest.DataTypes.ED)">
            <summary>
            Create a new instance of the CV data type with the parameters specified
            </summary>
            <param name="code">The initial code</param>
            <param name="codeSystem">The code system the code was picked from</param>
            <param name="codeSystemName">The name of the code system</param>
            <param name="codeSystemVersion">The version of the code system</param>
            <param name="displayName">The display name for the code</param>
            <param name="originalText">The original text, the reason the code was selected</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.CV`1.Code">
            <summary>
            Gets or sets the code of the coded value
            </summary>
            <remarks>
            Setting a strongly bound CV (a CV that is bound to an enumeration) with
            no code system set will set the <see cref="P:CodeSystem"/> property to
            the specified code system.
            <example>
            <code lang="cs" title="Effects of Code property on CV">
            <![CDATA[
            CV<MARC.Everest.DataTypes.NullFlavor> nullFlavor = new CV<MARC.Everest.DataTypes.NullFlavor>();
            nullFlavor.Code = MARC.Everest.DataTypes.NullFlavor.NoInformation;
            Console.WriteLine(nullFlavor.CodeSystem);
            // output: 2.16.840.1.113883.5.1008
            nullFlavor = new CV<MARC.Everest.DataTypes.NullFlavor>();
            nullFlavor.CodeSystem = "Hello";
            nullFlavor.Code = MARC.Everest.DataTypes.NullFlavor.NoInformation;
            Console.WriteLine(nullFlavor.CodeSystem);
            // output: Hello
            ]]>
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.CV`1.GetDisplayName(MARC.Everest.DataTypes.Primitives.CodeValue{`0})">
            <summary>
            Get the display name for the enumeration
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CV`1.GetCodeSystem(MARC.Everest.DataTypes.Primitives.CodeValue{`0})">
            <summary>
            Get code system for the specified value
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.CV`1.CodeSystem">
            <summary>
            The OID representing the system from which the code was drawn
            </summary>
            <remarks>
            This property is set automatically when a mnemonic is drawn from 
            the bound enumeration (ie: if <typeparam name="T"/> is an enumeration 
            and the enumeration value has a <see cref="T:MARC.Everest.Attributes.EnumerationAttribute"/>
            associated with it then the codeSystem is set to the supplierDomain property
            of that attribute).
            </remarks>
        </member>
        <member name="P:MARC.Everest.DataTypes.CV`1.CodeSystemName">
            <summary>
            The name of the code system
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.CV`1.CodeSystemVersion">
            <summary>
            The code system version
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.CV`1.DisplayName">
            <summary>
            Gets or sets the name or title for the code
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.CV`1.OriginalText">
            <summary>
            Gets or sets the text as seen and or selected by the user who entered the data
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.CV`1.CodingRationale">
            <summary>
            Gets or sets the reason the code was provided
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.CV`1.ValueSet">
            <summary>
            Identifies the value set that was applicable at the time of coding
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.CV`1.ValueSetVersion">
            <summary>
            Identifies the version of the value set that was applicable at the time of coding
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CV`1.Validate">
            <summary>
            Validate the code is in the proper format
            </summary>
            <remarks>
            A code is valid when
            <list type="bullet">
                <item>NullFlavor is specified, XOR</item>
                <item><list type="bullet">
                    <item>Code, CodeSystem, DisplayName or CodeSystemName is populated, AND</item>
                    <item>Code is Specified, AND</item>
                    <item>If CodeSystemName is specified, CodeSystem is Specified, AND</item>
                    <item>If CodeSystemVersion is specified, CodeSystem is specified, AND</item>
                    <item>If CodeSystem is specified, Code is specified, AND</item>
                    <item>If DisplayName is specified, Code is specified</item>
                </list></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.CV`1.ValidateEx">
            <summary>
            Validate the data type and return the validation errors that have been detected in the validation
            </summary>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.CV`1.op_Implicit(MARC.Everest.DataTypes.CV{`0})~`0">
            <summary>
            Converts a <see cref="!:CV"/> to a <typeparamref name="T"/>
            </summary>
            <param name="o">CV`1 to convert</param>
            <returns>Converted T</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.CV`1.op_Implicit(`0)~MARC.Everest.DataTypes.CV{`0}">
            <summary>
            Converts a <typeparamref name="T"/> to a <see cref="!:CV"/>
            </summary>
            <param name="o">T to convert</param>
            <returns>Converted CV`1</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.CV`1.Parse(MARC.Everest.DataTypes.CV{System.String})">
            <summary>
            Converts a CV to a strongly typed CV
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CV`1.DownParse(MARC.Everest.DataTypes.CV{`0})">
            <summary>
            Converts a strongly typed CV to a generic CV
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CV`1.Equals(MARC.Everest.DataTypes.CV{`0})">
            <summary>
            Determine if this CV of T equals another CV of T
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CV`1.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.CV`1.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determines if this instance of CV is semantically equal to another
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.DatePrecision">
            <summary>
            Date precision
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DatePrecision.Year">
            <summary>
            Year precision
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DatePrecision.Month">
            <summary>
            Month precision
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DatePrecision.Day">
            <summary>
            Day precision
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DatePrecision.HourNoTimezone">
            <summary>
            Hour precision with no timezone
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DatePrecision.MinuteNoTimezone">
            <summary>
            Minute no timezone
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DatePrecision.SecondNoTimezone">
            <summary>
            Second no timezone
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DatePrecision.FullNoTimezone">
            <summary>
            Full timestamp with no timezone
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DatePrecision.Hour">
            <summary>
            Hour precision
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DatePrecision.Minute">
            <summary>
            Minute precision
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DatePrecision.Second">
            <summary>
            Second precision
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DatePrecision.Full">
            <summary>
            Full precision
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.DatePrecisionUtil">
            <summary>
            Date precision utilities
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.DatePrecisionUtil.HasTimeZone(MARC.Everest.DataTypes.DatePrecision)">
            <summary>
            Returns true if date precision has a timezone
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.ED">
            <summary>
            Encapsulated data is used to transport larger portions of text, binary and XML data within an instance. 
            </summary>
            <example>Loading a PDF into an ED
            <code lang="cs" title="ED datatype">
            <![CDATA[
            // Using constructor
            ED t = new ED(File.ReadAllBytes(@"test.pdf"),"application/pdf");
            t.Language = "en-US";
            t.MediaType = "text/plain";
            t.Reference = "http://www.google.com";
            ]]>
            </code>
            <code lang="cs" title="Compressing an ED">
            <![CDATA[
            // The ED data type provides an easy mechanism to automatically compute checksums for the 
            // data contained within. Computing an integrity check is simple. All the developer needs to do,
            // is set the IntegrityCheckAlgorithm property, and set the integrity check to the result of the 
            // ComputeHash function. If an integrity check algorithm is specified, and no integrity check is 
            // assigned, it will be automatically generated when the IntegrityCheck value is retrieved.
            ED test = new ED(File.ReadAllBytes("C:\\output.pdf"), "text/xml"); 
            Console.WriteLine("Original: {0}", test.Data.Length); 
             
            // Setup compression 
            test.Compression = EncapsulatedDataCompression.GZ; 
            test.Data = test.Compress(); 
            Console.WriteLine("Compressed: {0}", test.Data.Length); 
             
            // Setup integrity check 
            test.IntegrityCheckAlgorithm = EncapsulatedDataIntegrityAlgorithm.SHA256; 
            test.IntegrityCheck = test.ComputeIntegrityCheck(); 
             
            // Validate 
            if (!test.ValidateIntegrityCheck()) 
            Console.WriteLine("Integrity check doesn't match!"); 
            else 
            { 
                test.Data = test.UnCompress(); 
                Console.WriteLine("UnCompressed: {0}", test.Data.Length); 
            }
            ]]>
            </code>
            </example>
            <remarks>
            <para>The ED data type can be used to encapsulate any binary data within an HL7v3 instance. The ED data type
            within Everest will be formatted appropriately for whatever particular ITS is used (for example: Binary data in 
            XML would be formatted as Base64)</para>
            <para>
            The key to the ED data type representation on the wire is the <see cref="P:Representation"/> property. This property
            is set automatically based on the method in which data within the ED is set. For example, if you set the content
            of the ED as a string, then the Representation property is automatically set to "Text" (which is represented in 
            RAW format in XML). However, if you set the contents of the ED to a byte array, then the representation is set
            to Base64
            </para>
            <para>
            The ED datatype provides many mechanisms of populating data within an instace. For example, one could use 
            the byte array property of Data, however for convenience, using the string property Value may work better if
            you are populating your ED to a string.
            </para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.#ctor">
            <summary>
            Create a new instance of ED
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.#ctor(System.Byte[],System.String)">
            <summary>
            Create a new instance of ED with initial value of <paramref name="Data"/>. Sets representation to B64
            </summary>
            <param name="data">Initial data</param>
            <param name="mediaType">The media type of the binary data</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.#ctor(System.String)">
            <summary>
            Create a new instance of ED with an initial value of <paramref name="Data"/>. Sets representation to TXT
            </summary>
            <param name="data">The data string to contain</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.#ctor(System.String,System.String)">
            <summary>
            Create a new instance of ED with initial value of <paramref name="data"/> in the language <paramref name="language"/>
            </summary>
            <param name="data"></param>
            <param name="language"></param>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.#ctor(MARC.Everest.DataTypes.TEL)">
            <summary>
            Create an instance of ED that links to a real location <paramref name="reference"/>
            </summary>
            <param name="reference">The reference to the real data</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.ED.Data">
            <summary>
            Get or set the data that is encapsulated by this object. 
            </summary>
            <remarks>Not included in formatted output</remarks>
        </member>
        <member name="P:MARC.Everest.DataTypes.ED.Compression">
            <summary>
            Identifies how data should be compressed
            </summary>
            <remarks>
            Note that setting this property does not compress the data, it merely informs
            receiving systems that the data is to be compressed.
            <para>
            When compressing data using the compress method, it is recommended that this value be set
            via the compression parameter. The only reason this property is read/write is to allow
            specification of compression on referenced data.
            </para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.Compress(MARC.Everest.DataTypes.Interfaces.EncapsulatedDataCompression)">
             <summary>
             Compress the data in this object according to the set parameters
             </summary>
             <returns>A new instance of ED with compressed data</returns>
             <example>ED with compressed data
             <code lang="cs" title="ED compression">
             <![CDATA[
             // Create instance
             ED test = new ED(File.ReadAllBytes("C:\\output.pdf"), "text/xml");
             Console.WriteLine("Original: {0}", test.Data.Length);
            
             // Setup compression
             compressed = test.Compress(EncapsulatedDataCompression.GZ);
             Console.WriteLine("Compressed: {0}", compressed.Data.Length);
             // Setup integrity check
             compressed.IntegrityCheckAlgorithm = EncapsulatedDataIntegrityAlgorithm.SHA256;
             compressed.IntegrityCheck = compressed.ComputeIntegrityCheck();
             // Validate
             if (!compressed.ValidateIntegrityCheck())
             Console.WriteLine("Integrity check doesn't match!");
             else
             {
             test = compressed.UnCompress();
             Console.WriteLine("UnCompressed: {0}", test.Data.Length);
             }
             ]]>
             </code>
             </example>
             <exception cref="T:System.InvalidOperationException">When <paramref name="compressionMethod"/> is not supported by this function</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.UnCompress">
            <summary>
            Decompresses the data from the this ED and places the result in a 
            new ED.
            </summary>
            <remarks>
            If an integrity check algorithm is specified, then this method will update
            the IntegrityCheck property to contain the value of integrity check.
            </remarks>
            <returns>A new ED instance containing uncompressed data.</returns>
            <exception cref="T:System.InvalidOperationException">When the compression algorithm for the instance is not supported by this method</exception>
        </member>
        <member name="P:MARC.Everest.DataTypes.ED.Description">
            <summary>
            Gets or sets an alternative description of the media where the context is
            not suitable for rendering the media
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.ED.Representation">
             <summary>
             Identifies how the encapsulated data is represented when formatted
             </summary>
             <remarks>The default value for this property is always to encode in Base64</remarks>
             <example>
             <code title="XML Representation" lang="cs">
             <![CDATA[
            
                // Encapsulated Data 
                ED xmlEd = new ED();
            
            
                 XmlDocument doc = new XmlDocument();
                 XmlElement xmlElem = doc.CreateElement("ROOT");
                 xmlElem.InnerText = "This is the text of the root element";
                 doc.AppendChild(xmlElem);
            
                // We want the encapsulated data to be represented as XML
            
                
                // When formatted, the output of this ed will be
                // <text representation="XML" mediaType="text/xml"><ROOT>This is the text of the root element</ROOT></text>
                xmlEd.Representation = EncapsulatedDataRepresentation.XML;
                xmlEd.MediaType = "text/xml";
             ]]>
             </code>
             <code title="Text Representation" lang="cs">
             <![CDATA[
                // When formatted, the output of this ed will be
                // <text representation="TXT" mediaType="text/xml">This is my text&lt;/ROOT></text>
                ED txtEd = "This is my text";
                txtEd.MediaType = "text/plain";
                txtEd.Representation = EncapsulatedDataRepresentation.TXT;
             ]]>
             </code>
             <code title="Base64 Encoding" lang="cs">
             <![CDATA[
                // When formatted, the output of this ed will be
                // <text representation="B64" mediaType="text/xml">VGhpcyBpcyBteSB0ZXh0</text>
                ED b64Ed = "This is my text";
                b64Ed.Representation = EncapsulatedDataRepresentation.B64;
             ]]>
             </code>        
             </example>
        </member>
        <member name="P:MARC.Everest.DataTypes.ED.Language">
            <summary>
            The human language of the content. Valid codes are taken from the IETF. 
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.ED.Translation">
            <summary>
            Alternative renditions of the same content translated into a different language
            </summary>
            <remarks>Included to help assist with DataTypes R2 implementation. Note that this property will not appear in datatypes r1</remarks>
        </member>
        <member name="P:MARC.Everest.DataTypes.ED.MediaType">
            <summary>
            Identifies the type of encapsulated data and identifies a method to interpret or render the content. 
            The IANA defined domain of media types is established by the IETF RFC 2045 and 2046
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.ComputeIntegrityCheck">
            <summary>
            Compute hash for the data in this object and set the hash and integrity check algorithm used
            </summary>
            <returns>The computed hash</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.ComputeIntegrityCheck(System.Byte[])">
            <summary>
            Compute integrity check for the specified data
            </summary>
            <param name="data">The data to calculate integrity check</param>
            <returns>The calculated integrity check for <paramref name="data"/></returns>
            <exception cref="T:System.InvalidOperationException">When integrityCheckAlgorithm is not set</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.ComputeIntegrityCheck(System.Byte[],MARC.Everest.DataTypes.Interfaces.EncapsulatedDataIntegrityAlgorithm)">
            <summary>
            Compute integrity check for the specified <paramref name="data"/> using the specified <paramref name="algorithm"/>
            </summary>
            <param name="data">The data which is to have its checksum calculated</param>
            <param name="algorithm">The algorithm to use for calculating the integrity check</param>
            <returns>A byte array containing the computed integrity check</returns>
            <exception cref="T:System.ArgumentNullException">When data is null</exception>
        </member>
        <member name="P:MARC.Everest.DataTypes.ED.IntegrityCheck">
            <summary>
            The Integrity check is a short binary value representing a cryptographically strong checksum of the data
            </summary>
            <remakrs>
            If data is populated and a check algorithm is subsequently populated, and no value is stored in <see cref="P:MARC.Everest.DataTypes.ED.IntegrityCheck"/>, then
            the IntegrityCheck property will be computed and assigned automatically
            </remakrs>
            <example>Using integrity checks
            <code lang="cs" title="ED integrity check">
            <![CDATA[
            ED edTest = new ED(File.ReadAllBytes("test.xml"),"text/xml");
            edTest.Representation = EncapsulatedDataRepresentation.XML;
            edTest.IntegrityCheckAlgorithm = EncapsulatedDataIntegrityAlgorithm.SHA1;
            // This will be auto-generated if you don't explicity call it
            edTest.IntegrityCheck = edTest.ComputeIntegrityCheck();
            Console.WriteLine(Convert.ToBase64String(edTest.IntegrityCheck));
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.UnCompressInternal">
            <summary>
            Uncompress the data in this object according to the set parameters
            </summary>
            <returns>The decompressed data</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.CompressInternal">
            <summary>
            Compression utility to be used internally
            </summary>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.ValidateIntegrityCheck">
            <summary>
            Validate the hash that the data within this ED is valid according to the set
            integrity check algorithm and integrity check
            </summary>
            <remarks>If Data is not set (ie: ED is a reference), then the result of this function is true</remarks>
        </member>
        <member name="P:MARC.Everest.DataTypes.ED.IntegrityCheckAlgorithm">
            <summary>
            Specifies the algorithm used to compute the checksum
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.ED.Thumbnail">
            <summary>
            An abbreviated rendition of the full content.
            </summary>
            <example>Reference with thumbnail
            <code lang="cs" title="ED thumbnail">
            <![CDATA[
            ED t = new ED((TEL)"http://1.2.12.32/images/big.tif");
            t.Thumbnail = new ED(File.ReadAllBytes(@"C:\small.png"),"image/png");
            ]]>
            </code>
            </example>
        </member>
        <member name="P:MARC.Everest.DataTypes.ED.Reference">
            <summary>
            A telecommunications address such as a url for HTTP or FTP which resolve to precisely the same binary
            content that could as well have been provided inline.
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.IsValidTextFlavor(MARC.Everest.DataTypes.ED)">
            <summary>
            ED.Text validator
            </summary>
            <remarks>
            Ensures that the specified ED is properly setup to be represented as Text. Changes
            Representation to TXT, sets compression and integritycheck to null.
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.IsValidImageFlavor(MARC.Everest.DataTypes.ED)">
            <summary>
            ED.Image validator
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.IsValidSignatureFlavor(MARC.Everest.DataTypes.ED)">
            <summary>
            ED.SIGNATURE validator
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.ED.Value">
            <summary>
            Get the string representation of the value
            </summary>
            <remarks>By setting this property, the Representation property is updated to TXT</remarks>
            <seealso cref="P:Representation"/>
        </member>
        <member name="P:MARC.Everest.DataTypes.ED.Base64Data">
            <summary>
            Base64 representation of the value
            </summary>
            <remarks>By setting this property, the Representation property is updated to B64</remarks>
            <seealso cref="P:Representation"/>
        </member>
        <member name="P:MARC.Everest.DataTypes.ED.XmlData">
            <summary>
            XML Representation of the data
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.Validate">
            <summary>
            Validate ED
            </summary>
            <remarks>
            An ED is valid if
            <list type="bullet">
                <item>Data is set, XOR</item>
                <item>NullFlavor is provided</item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.ValidateEx">
            <summary>
            Validatethe data type returning the validation errors that occurred
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.op_Implicit(MARC.Everest.DataTypes.ED)~System.String">
            <summary>
            Convert this string into an ED
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.op_Implicit(MARC.Everest.DataTypes.ED)~System.Byte[]">
            <summary>
            Convert an ED into a byte array
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.op_Implicit(System.String)~MARC.Everest.DataTypes.ED">
            <summary>
            Convert the string into an ED
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.ToString">
            <summary>
            Convert this ED to a string
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.ByteEquality(System.Byte[],System.Byte[])">
            <summary>
            Determines if data in <paramref name="a"/> equals <paramref name="b"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.Equals(MARC.Everest.DataTypes.ED)">
            <summary>
            Determine if this ED is equal to another ED
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ED.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
             <summary>
             Determine semantic equality between this instance of ED and other
             </summary>
             <remarks>Two non-null flavored instances of ED are semantically equal when their MediaType and raw data properties are equal. 
            When performing semantic equality between compressed instances of ED, the equality will be performed on the uncompressed data.
            <para>
             Instances of ED can be semantically equal to instances of ST or SC if the mediaType of the ED it "text/plain" and 
             the binary contents of the ED and ST/SC match.
             </para>
             </remarks>
        </member>
        <member name="T:MARC.Everest.DataTypes.DomainTimingEventType">
            <summary>
            Domain timing event type
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DomainTimingEventType.BeforeMeal">
            <summary>
            before meal (from lat. ante cibus)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DomainTimingEventType.BeforeLunch">
            <summary>
            before lunch (from lat. ante cibus diurnus)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DomainTimingEventType.BeforeBreakfast">
            <summary>
            before breakfast (from lat. ante cibus matutinus)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DomainTimingEventType.BeforeDinner">
            <summary>
            before dinner (from lat. ante cibus vespertinus)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DomainTimingEventType.HourOfSleep">
            <summary>
            the hour of sleep
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DomainTimingEventType.BetweenMeals">
            <summary>
            between meals (from lat. inter cibus)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DomainTimingEventType.BetweenLunchAndDinner">
            <summary>
            between lunch and dinner
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DomainTimingEventType.BetweenBreakfastAndLunch">
            <summary>
            between breakfast and lunch
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DomainTimingEventType.BetweenDinnerAndSleep">
            <summary>
            between dinner and the hour of sleep
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DomainTimingEventType.AfterMeal">
            <summary>
            after meal (from lat. post cibus)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DomainTimingEventType.AfterLunch">
            <summary>
            after lunch (from lat. post cibus diurnus)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DomainTimingEventType.AfterBreakfast">
            <summary>
            after breakfast (from lat. post cibus matutinus)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DomainTimingEventType.AfterDinner">
            <summary>
            after dinner (from lat. post cibus vespertinus)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DomainTimingEventType.Breakfast">
            <summary>
            The meal of breakfast
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DomainTimingEventType.Lunch">
            <summary>
            The meal of lunch
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DomainTimingEventType.Dinner">
            <summary>
            The meal of dinner
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DomainTimingEventType.Meal">
            <summary>
            Any meal
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.DomainTimingEventType.UponWaking">
            <summary>
            upon waking
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.EIVL`1">
             <summary>
             Specifies a periodic interval of time where the recurrence is based on the activities of daily living
             or other important events that are time related but not fully determined by time
             </summary>
             <remarks>
             <para>Represents an Event Related Periodic Interval of Time</para>
             <para>EIVL has been implemented as a generic as the XSD for the HL7 data types defines
             EIVL as either EIVL&lt;TS> (EIVL_TS) or EIVL&lt;NPPD&lt;TS>> (EIVL_NPPD_TS).</para></remarks>
             <example>
             <code title="XML Representation" lang="cs">
             <![CDATA[
             // Event driven interval, in this case after breakfast
             // Specifies a periodic interval: At most 12 hours
                IVL<PQ> effectiveTime1 = new IVL<PQ>() { High = new PQ(12, "h") };
            
                // the recurrence is based on this activity of daily living
                CS<DomainTimingEventType> event1 = new CS<DomainTimingEventType>(DomainTimingEventType.BeforeBreakfast);
                
                // patient must perform action within 12 hours of eating breakfast
                EIVL<TS> id = new EIVL<TS>();
                id.Offset = effectiveTime1;
                id.Event = event1;
             ]]>
             </code>        
             </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.EIVL`1.#ctor">
            <summary>
            Create a new instance of the EIVL class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.EIVL`1.#ctor(MARC.Everest.DataTypes.DomainTimingEventType,MARC.Everest.DataTypes.IVL{MARC.Everest.DataTypes.PQ})">
            <summary>
            Create a new instance of the EIVL class with the specified <paramref name="operatorType"/>, <paramref name="eventType"/> and <paramref name="offset"/>
            </summary>
            <param name="eventType">The type of event that this interval relates to</param>
            <param name="offset">The offset (time interval)</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.EIVL`1.Value">
            <summary>
            Override of the value so that developers don't see it
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.EIVL`1.Event">
            <summary>
            A code for a common, periodical activity of daily living
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.EIVL`1.Offset">
            <summary>
            An interval of elapsed time (duration, not absolute point in time) that marks the offsets for the 
            beginning width and end of the event related periodic interval
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.EIVL`1.OriginalText">
            <summary>
            Gets or sets the textual description of why the particular EIVL was conveyed
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.EIVL`1.Validate">
            <summary>
            Validate this EIVL
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.EIVL`1.ValidateEx">
            <summary>
            Validate the data type and return the validation errors detected
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.EIVL`1.Equals(MARC.Everest.DataTypes.EIVL{`0})">
            <summary>
            Determines if this instance of EIVL of T is equal to another instance of EIVL of T
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.EIVL`1.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.EIVL`1.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determine semantic equality between this and <paramref name="other"/>
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.EntityNameUse">
            <summary>
            Enumeration of entity name uses.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNameUse.Legal">
            <summary>
            The name the entity uses in a legal context.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNameUse.OfficialRecord">
            <summary>
            The formal name as registered in an official registry
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNameUse.License">
            <summary>
            As recorded on a license, record, certificate
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNameUse.MaidenName">
            <summary>
            A name used prior to marriage
            </summary>
            <remarks>
            This use code is used for applications that collect and store maiden names
            </remarks>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNameUse.Indigenous">
            <summary>
            eg: (From HL7 ISO DOC) Chief Red Cloud
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNameUse.Pseudonym">
            <summary>
            A self asserted name that the person is using
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNameUse.Artist">
            <summary>
            Includes writer's pseudonym/stage name
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNameUse.Religious">
            <summary>
            eg: Sister Mary Francis
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNameUse.Assigned">
            <summary>
            A named assigned to a person. This is an ALIAS
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNameUse.Alphabetic">
            <summary>
            Alphabetic transcription (eg: Romaji in Japan)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNameUse.Ideographic">
            <summary>
            Ideographic representation (eg: Kanji in Japan)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNameUse.Syllabic">
            <summary>
            Syllabic transcription (eg: Hangul in Korea)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNameUse.Soundex">
            <summary>
            An address spelled according to the SoundEx algorithm
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNameUse.Phonetic">
            <summary>
            The address as understood by the datacenter. (eg: A close proximity to)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNameUse.Anonymous">
            <summary>
            Anonymously assigned name
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNameUse.Search">
            <summary>
            A name intended to be used in search or matching
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.EN">
             <summary>
             A name for a person, organization, place or thing
             </summary>
             <example>
             <code lang="cs" title="Using EN">
             <![CDATA[
             // EntityNameUse: as recorded on a license
             EN name = new EN(
             EntityNameUse.Legal, new ENXP[] { 
             new ENXP("James", EntityNamePartType.Given), 
             new ENXP("Tiberius", EntityNamePartType.Given), 
             new ENXP("Kirk", EntityNamePartType.Family) });
            
             LIST<ENXP> part = new LIST<ENXP>(new ENXP[] {
             new ENXP("Tiberius", EntityNamePartType.Given),
             new ENXP("Kirk", EntityNamePartType.Prefix)});
             part[0].Qualifier = EntityNamePartQualifier.Academic;
             part[1].Qualifier = EntityNamePartQualifier.Nobility;
             name.Part.Add(part[0]);
             name.Part.Add(part[1]);
             Console.Write(name.ToString("{FAM}, {GIV}"));
             ]]>
             </code>
             </example>
        </member>
        <member name="F:MARC.Everest.DataTypes.EN.PartTypeMap">
            <summary>
            Part type map
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.EN.#cctor">
            <summary>
            Static CTOR
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.EN.#ctor">
            <summary>
            Create a new instance of EN
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.EN.#ctor(MARC.Everest.DataTypes.EntityNameUse,System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.ENXP})">
            <summary>
            Create a new entity named instance using the specified values
            </summary>
            <param name="parts">The parts of the names</param>
            <param name="use">The uses of this name</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.EN.#ctor(MARC.Everest.DataTypes.SET{MARC.Everest.DataTypes.CS{MARC.Everest.DataTypes.EntityNameUse}},System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.ENXP})">
            <summary>
            Create a new entity named instance using the specified values
            </summary>
            <param name="parts">The parts of the names</param>
            <param name="use">The uses of this name</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.EN.CreateEN(MARC.Everest.DataTypes.EntityNameUse,MARC.Everest.DataTypes.ENXP[])">
            <summary>
            Helper method for creating EN instances
            </summary>
            <param name="use">The use of the returned name</param>
            <param name="parts">The parts that make up the name</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.EN.FromFamilyGiven(MARC.Everest.DataTypes.EntityNameUse,System.String,System.String[])">
            <summary>
            Creates an EN instance from a family and given name
            </summary>
            <param name="family">The family name the <see cref="T:PN"/> should carry</param>
            <param name="given">The given name(s) the <see cref="T:PN"/> should carry</param>
            <param name="use">The intended use of the name</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.EN.Use">
            <summary>
            The uses of this name
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.EN.Part">
            <summary>
            Gets the parts that make up this entity name
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.EN.Validate">
            <summary>
            Validates this EntityName to ensure that it represents a valid instance of EN
            </summary>
            <remarks>
            An instance of EN is valid if:
            <list type="bullet">
                <list>NullFlavor is specified, XOR</list>
                <list>The Name contains at least one part</list>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.EN.ValidateEx">
            <summary>
            Extended validation function which returns the details of the validation
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.EN.ToString(System.String)">
            <summary>
            Represent this entity name as a string. Parts are formatted using the standard string.format notation
            </summary>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.EN.ToString">
            <summary>
            Represent this address as a string. Parts appear in whatever order they appear in the sequence
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.EN.Equals(MARC.Everest.DataTypes.EN)">
            <summary>
            Determine if this EN equals another instance of EN
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.EN.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.EN.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determine semantic equality of this type
            </summary>
            <remarks>Two non-null non-nullflavored instance of EN are considered semantically equal when
            they both contain the same parts in the same order.</remarks>
        </member>
        <member name="T:MARC.Everest.DataTypes.EntityNamePartType">
             <summary>
             An enumeration of part types.
             </summary>
             <example>
             <code lang="cs" title="Using EN">
             <![CDATA[
            
             // EntityNameUse: as recorded on a license
             EN name = new EN(
                 EntityNameUse.Legal, new ENXP[] { 
                     new ENXP("James", EntityNamePartType.Given), 
                         new ENXP("Tiberius", EntityNamePartType.Given), 
                         new ENXP("Kirk", EntityNamePartType.Family) });
            
             LIST<ENXP> part = new LIST<ENXP>(new ENXP[] {
                 new ENXP("Tiberius", EntityNamePartType.Given),
                 new ENXP("Kirk", EntityNamePartType.Prefix)});
                 part[0].Qualifier = EntityNamePartQualifier.Academic;
                 part[1].Qualifier = EntityNamePartQualifier.Nobility;
                 name.Part.Add(part[0]);
                 name.Part.Add(part[1]);
                 Console.Write(name.ToString("{FAM}, {GIV}"));
             ]]>
             </code>
             </example>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartType.Family">
            <summary>
            The family name that links to the genealogy
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartType.Given">
            <summary>
            Given name (first, middle or other given names)
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartType.Prefix">
            <summary>
            A prefix has a string association to the immediately following name part
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartType.Suffix">
            <summary>
            A suffix has a strong association to the part immediately before the name part
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartType.Title">
            <summary>
            Part of a name acquired due to an academic, legal, employment or certification
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartType.Delimiter">
            <summary>
            A delimiter has no meaning other than being literally printed in this name representation
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.EntityNamePartQualifier">
            <summary>
            An enumeration of part qualifiers.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartQualifier.LegalStatus">
            <summary>
            For organizations indicating legal status
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartQualifier.Academic">
            <summary>
            Indicates that a prefix like "Dr" or a suffix like "M.D." is an 
            academic title
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartQualifier.Nobility">
            <summary>
            In Europe and Asia there are some individuals with titles of nobility
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartQualifier.Professional">
            <summary>
            Primarily in the British imperial culture people tend to have an abbreviation of their professional
            organizations as part of the credential suffixes.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartQualifier.Honorific">
            <summary>
            An honorific
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartQualifier.Birth">
            <summary>
            A name the person had shortly after being born
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartQualifier.Acquired">
            <summary>
            A name part a person acquired through adoption, or a chosen name
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartQualifier.Spouse">
            <summary>
            The name assumed from the partner in a marital relationship
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartQualifier.CallMe">
            <summary>
            A call me name is usually a given name that is preferred when the person is addressed
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartQualifier.Initial">
            <summary>
            Indicates that a name part is just an initial
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartQualifier.Middle">
            <summary>
            Identifies a middle name
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartQualifier.Prefix">
            <summary>
            Identifies a prefix
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.EntityNamePartQualifier.Suffix">
            <summary>
            Identifies a suffix
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.ENXP">
            <summary>
            A character string token representing a part of a name
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.ENXP.validation">
            <summary>
            A collection of EntityNamePartTypes paired to a EntityNamePartQualifier in a dictionary.
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ENXP.#cctor">
            <summary>
            Static CTOR
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ENXP.#ctor">
            <summary>
            Create a new instance of the ENXP type
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ENXP.#ctor(System.String)">
            <summary>
            Create a new instance of the ENXP type
            </summary>
            <param name="value"></param>
            <remarks>Type set to Given</remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.ENXP.#ctor(System.String,MARC.Everest.DataTypes.EntityNamePartType)">
            <summary>
            Create a new instance of the ENXP type
            </summary>
            <param name="value">The value of the name part</param>
            <param name="type">The type of name part</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.ENXP.Value">
            <summary>
            The value of the ENXP
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.ENXP.Code">
            <summary>
            A code assigned to the name part by a coding system if applicable
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.ENXP.CodeSystem">
            <summary>
            The code system from which the code is taken
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.ENXP.CodeSystemVersion">
            <summary>
            The version of the coding system
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.ENXP.Type">
            <summary>
            The type of entity name part
            </summary>
            <remarks>
            Two of the part types, namely <see cref="P:EntityNamePartType.Suffix"/> and <see cref="P:EntityNamePartType.Prefix"/> are not supported in the latest 
            version of the ISO data types (DT R2). Whenever the DT R2 formatter encounters a type named Suffix or Prefix, it will not render the type attribute, rather
            it will translate the instance to a PART with no type and a qualifier of SFX or PFX. Conversely, whenever an instance is received that has no part type
            and a qualifier of SFX or PFX, then type is set to PFX or SFX and Qualifier is kept.
            </remarks>
        </member>
        <member name="P:MARC.Everest.DataTypes.ENXP.Qualifier">
            <summary>
            The qualifier is a set of codes each of which specifies a certain sub-category
            </summary>
            <remarks>
            Qualifier is supported only by Data Types R2, however it modifies the manner in which Data Types R1 formatters 
            graph the data to the wire. This is because of changes to <see cref="T:EntityNamePartType"/> enumeration. The rules when formatting
            R1 are as follows:
            <list type="bullet">
                <item><description>When Qualifier is set and is SUFFIX, no matter what <see cref="P:Type"/> is set to, the element is rendered as a Suffix</description></item>
                <item><description>When Qualifier is set and is PREFIX, no matter what <see cref="P:Type"/> is set to, the element is rendered as a Prefix</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.ENXP.op_Implicit(MARC.Everest.DataTypes.ENXP)~System.String">
            <summary>
            Translate to the string
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ENXP.Validate">
            <summary>
            Validate
            </summary>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.ENXP.ValidateEx">
            <summary>
            Extended validation function which returns the details of the validation
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ENXP.Equals(MARC.Everest.DataTypes.ENXP)">
            <summary>
            Determine if this ENXP equals another instance of ENXP
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ENXP.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.GTS">
             <summary>
             A set of points in time, specifying the timing of events and actions and the cyclical validity patterns that may exist
             for certain kinds of information
             </summary>
             <example>
             <code title="A GTS representing Mondays between September 1 and September 8 every other year" lang="cs">
             <![CDATA[
             GTS test = new GTS();
             SXPR<TS> labourDayDates = new SXPR<TS>();
             // Labour day can occur in between September 1 and September 8 of every year
             PIVL_TS labourDayWeek = new PIVL_TS(
                // this is the week between September 1 and September 8
                new IVL<TS>(DateTime.Parse("09/01/1987"), DateTime.Parse("09/08/1987")),
                new PQ(1.0f, "a")); 
             labourDayWeek.Phase.LowClosed = false; // Including 09/01/1987
             labourDayWeek.Phase.HighClosed = true; // Not including 09/08/1987
            
                
             // Labour day must occur on the Monday of the week above
             PIVL_TS mondayDayOfTheWeek = new PIVL_TS(
                // this date is a Monday
                new IVL<TS>(DateTime.Parse("01/04/2010"), DateTime.Parse("01/05/2010")),
                new PQ(1.0f, "wk"));
             // set Monday to intersect with labour day week
             mondayDayOfTheWeek.Operator = SetOperator.Intersect; // intersect every Monday with the LabourDayWeek period
             mondayDayOfTheWeek.Phase.LowClosed = false;
             mondayDayOfTheWeek.Phase.HighClosed = true;
            
             // Find Labour Day in alternate years 
             PIVL_TS alternateYear = new PIVL_TS(
                // this is every other year
                new IVL<TS>(DateTime.Parse("01/01/2010"), DateTime.Parse("01/01/2011")),
                new PQ(2.0f, "a"));
             alternateYear.Operator = SetOperator.Intersect; // intersect the Labour Day Monday with every other year
             alternateYear.Phase.LowClosed = false;
             alternateYear.Phase.HighClosed = true;
            
             labourDayDates.Add(labourDayWeek);
             labourDayDates.Add(mondayDayOfTheWeek);
             labourDayDates.Add(alternateYear);
            
             test.Hull = labourDayDates;
             ]]>
             </code>
             
             </example>
             <seealso cref="T:MARC.Everest.DataType.EIVL&lt;>"/>
             <seealso cref="T:MARC.Everest.DataType.IVL_TS"/>
             <seealso cref="T:MARC.Everest.DataType.SXCM&lt;>"/>
             <seealso cref="T:MARC.Everest.DataType.PIVL_TS"/>
        </member>
        <member name="P:MARC.Everest.DataTypes.GTS.Hull">
            <summary>
            Represents the "hull" of the General Timing Specification object
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.#ctor">
            <summary>
            Create a new instance of this GTS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.#ctor(MARC.Everest.DataTypes.EIVL{MARC.Everest.DataTypes.TS})">
            <summary>
            Create a new instance of the GTS class with the specified <paramref name="hull"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.#ctor(MARC.Everest.DataTypes.QSET{MARC.Everest.DataTypes.TS})">
            <summary>
            Create a new instance of the GTS class with the specified <paramref name="hull"/>
            </summary>
            <param name="hull">The SXPR&lt;TS> to set as the hull</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.#ctor(MARC.Everest.DataTypes.IVL{MARC.Everest.DataTypes.TS})">
            <summary>
            Create a new instance of the GTS class with the specified <paramref name="hull"/>
            </summary>
            <param name="hull">The IVL&lt;TS> to set as the hull</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.#ctor(MARC.Everest.DataTypes.PIVL{MARC.Everest.DataTypes.TS})">
            <summary>
            Create a new instance of the GTS class with the specified <paramref name="hull"/>
            </summary>
            <param name="hull">A PIVL&lt;TS> to set as the hull</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.#ctor(MARC.Everest.DataTypes.QSS{MARC.Everest.DataTypes.TS})">
            <summary>
            Create a new instance of the GTS class with the specified <paramref name="hull"/>
            </summary>
            <param name="hull"></param>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.#ctor(MARC.Everest.DataTypes.QSI{MARC.Everest.DataTypes.TS})">
            <summary>
            Create a new instance of the GTS class with the specified <paramref name="hull"/>
            </summary>
            <param name="hull"></param>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.#ctor(MARC.Everest.DataTypes.QSD{MARC.Everest.DataTypes.TS})">
            <summary>
            Create a new instance of the GTS class with the specified <paramref name="hull"/>
            </summary>
            <param name="hull"></param>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.#ctor(MARC.Everest.DataTypes.QSU{MARC.Everest.DataTypes.TS})">
            <summary>
            Create a new instance of the GTS class with the specified <paramref name="hull"/>
            </summary>
            <param name="hull"></param>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.#ctor(MARC.Everest.DataTypes.SXCM{MARC.Everest.DataTypes.TS})">
            <summary>
            Create a new instance of the GTS class with the specified <paramref name="hull"/>
            </summary>
            <param name="hull"></param>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.#ctor(MARC.Everest.DataTypes.SXPR{MARC.Everest.DataTypes.TS})">
            <summary>
            Create a new instance of the GTS class with the specified <paramref name="hull"/>
            </summary>
            <param name="hull"></param>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.op_Implicit(MARC.Everest.DataTypes.QSET{MARC.Everest.DataTypes.TS})~MARC.Everest.DataTypes.GTS">
            <summary>
            Explicitly casts QSET of TS <paramref name="a"/> to a GTS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.op_Implicit(MARC.Everest.DataTypes.SXCM{MARC.Everest.DataTypes.TS})~MARC.Everest.DataTypes.GTS">
            <summary>
            Explicitly casts SXCM of TS <paramref name="a"/> to a GTS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.op_Implicit(MARC.Everest.DataTypes.SXPR{MARC.Everest.DataTypes.TS})~MARC.Everest.DataTypes.GTS">
            <summary>
            Explicitly casts SXPR of TS <paramref name="a"/> to a GTS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.op_Implicit(MARC.Everest.DataTypes.IVL{MARC.Everest.DataTypes.TS})~MARC.Everest.DataTypes.GTS">
            <summary>
            Explicitly casts IVL of TS <paramref name="a"/> to a GTS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.op_Implicit(MARC.Everest.DataTypes.EIVL{MARC.Everest.DataTypes.TS})~MARC.Everest.DataTypes.GTS">
            <summary>
            Explicitly casts EIVL of TS <paramref name="a"/> to a GTS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.op_Implicit(MARC.Everest.DataTypes.QSI{MARC.Everest.DataTypes.TS})~MARC.Everest.DataTypes.GTS">
            <summary>
            Explicitly casts QSI of TS <paramref name="a"/> to a GTS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.op_Implicit(MARC.Everest.DataTypes.QSD{MARC.Everest.DataTypes.TS})~MARC.Everest.DataTypes.GTS">
            <summary>
            Explicitly casts QSD of TS <paramref name="a"/> to a GTS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.op_Implicit(MARC.Everest.DataTypes.QSP{MARC.Everest.DataTypes.TS})~MARC.Everest.DataTypes.GTS">
            <summary>
            Explicitly casts QSP of TS <paramref name="a"/> to a GTS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.op_Implicit(MARC.Everest.DataTypes.QSS{MARC.Everest.DataTypes.TS})~MARC.Everest.DataTypes.GTS">
            <summary>
            Explicitly casts QSS of TS <paramref name="a"/> to a GTS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.op_Implicit(MARC.Everest.DataTypes.QSU{MARC.Everest.DataTypes.TS})~MARC.Everest.DataTypes.GTS">
            <summary>
            Explicitly casts QSU of TS <paramref name="a"/> to a GTS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.op_Implicit(MARC.Everest.DataTypes.PIVL{MARC.Everest.DataTypes.TS})~MARC.Everest.DataTypes.GTS">
            <summary>
            Explicitly casts PIVL of TS <paramref name="a"/> to a GTS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.IsValidBoundedPivlFlavor(MARC.Everest.DataTypes.GTS)">
            <summary>
            Flavor validator for the GTS.BOUNDEDPIVL
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.Validate">
            <summary>
            Validate this GTS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.ValidateEx">
            <summary>
            Validates the GTS and returns the detected issues with the data type instance
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.ToString">
            <summary>
            Represent this object as a string
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.Equals(MARC.Everest.DataTypes.GTS)">
            <summary>
            Determine if this GTS equals another instance of GTS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.GTS.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.HXIT`1">
            <summary>
            This implementation of the HXIT type is used for R1 data types compatibility. 
            </summary>
            <remarks>
            <para>
            In the MIF for R1 data types, HXIT&lt;<typeparamref name="T"/>&gt; is referenced when a data type can 
            use the HXIT members. In the R1 formatter, no HXIT data types are serialized or parsed by 
            default (as all DTs in the class lib have HXIT attributes, but not all DTs in R1 can 
            use HXIT attributes). When a HXIT&lt;T&gt; is used, it marks the core DT as being allowed
            to use the HXIT properties at the base of the inheritence tree.
            </para>
            <para>
            R1 can't represent the ValidTimeLow property of the CS because R1 doesn't allow all DTs to 
            carry history data. When this CS is formatted, only the Code attribute will be serialized. By
            wrapping the CS class in an HXIT the formatter is instructed to use the HXIT members of the CS
            </para><para>
            The serialization will include the code and valid time low property
            </para>
            </remarks>
            <example>
            
            <code lang="cs" title="CS in DT R1 has all the HXIT data, so theoretically">
            CS p = new CS();
            p.ValidTimeLow = DateTime.Now;
            p.Code = "M";
            </code>
            </example>
            <example>
            <code>
            HXIT&lt;CS&gt; p = new HXIT&lt;CS&gt;();
            p.ValidTimeLow = DateTime.Now;
            </code>
            </example>
            <typeparam name="T">The type to mark as using the HXIT parameters</typeparam>
        </member>
        <member name="M:MARC.Everest.DataTypes.HXIT`1.#ctor">
            <summary>
            Create a new instance of HXIT
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.HXIT`1.#ctor(`0)">
            <summary>
            Create a new instance of HXIT using the value <paramref name="value"/>
            </summary>
            <param name="value">The initial value of the HXIT</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.HXIT`1.Value">
            <summary>
            The value of the HXIT
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.HXIT`1.op_Implicit(MARC.Everest.DataTypes.HXIT{`0})~`0">
            <summary>
            Converts a <see cref="T:MARC.Everest.DataTypes.HXIT"/> to a <typeparamref name="T"/>
            </summary>
            <param name="o">HXIT`1 to convert</param>
            <returns>Converted T</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.HXIT`1.op_Implicit(`0)~MARC.Everest.DataTypes.HXIT{`0}">
            <summary>
            Converts a <typeparamref name="T"/> to a <see cref="T:MARC.Everest.DataTypes.HXIT"/>
            </summary>
            <param name="o">T to convert</param>
            <returns>Converted HXIT`1</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.HXIT`1.Validate">
            <summary>
            Validate this HXIT
            </summary>
            <returns></returns>
        </member>
        <member name="T:MARC.Everest.DataTypes.HXIT">
            <summary>
            The HistoryItem or HXIT is a generic data type extension that tags a time range and control
            act event to any datatype. The time range is the time in which the information represented
            by the value is (was) valid and which control act event modified the value
            </summary>
            <remarks>
            <para>Business Name: HistoryItem</para>
            <para>
            HXIT class in ITS. This implementation is in the style of ITS R2 HXIT. This is because of 
            a severe implementation problem with the R1 HXIT class
            </para>
            </remarks>
        </member>
        <member name="P:MARC.Everest.DataTypes.HXIT.ValidTimeLow">
            <summary>
            Identifies the time that the given information has or will become valid
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.HXIT.ValidTimeHigh">
            <summary>
            Identifies the time that the given information has or will no longer be valid
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.HXIT.ControlActRoot">
            <summary>
            Identifies the root of the identifier of the event associated with the setting of the data type to the value
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.HXIT.ControlActExt">
            <summary>
            Identifies the extension of the identifier of the event associated with the setting of the data type to the value
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.HXIT.Validate">
            <summary>
            When overriden in a derived class, this method validates that the contents of the data type
            are valid.
            </summary>
            <remarks>
            An HXIT passes validation when a ControlActRoot and ControlActExt are populated or 
            neither ControlActRoot and ControlActExt are populated.
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.HXIT.ValidateEx">
            <summary>
            Validates the structure is conformant, returning the result details that are in violation
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.IdentifierScope">
            <summary>
            Identifies the scope to which an II applies
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.IdentifierScope.BusinessIdentifier">
            <summary>
            An identifier that is associated with the object due to the business practices associated with the object
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.IdentifierScope.ObjectIdentifier">
            <summary>
            ObjectIdentifier: An identifier associated with a particular object
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.IdentifierScope.VersionIdentifier">
            <summary>
            VersionIdentifier: An identifier that references a particular object
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.IdentifierScope.ViewSpecificIdentifier">
            <summary>
            ViewSpecificIdentifier: An identifier for a particular snapshot of a version of the object
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.IdentifierReliability">
            <summary>
            Identifies the reliability of the II
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.IdentifierReliability.IssuedBySystem">
            <summary>
            IssuedBySystem: The identifier was issued by the system responsible for constructing the instance
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.IdentifierReliability.VerifiedBySystem">
            <summary>
            VerifiedBySystem: The identifier was not issued by the system responsible for constructing the instance but
            was verified by it
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.IdentifierReliability.UsedBySystem">
            <summary>
            UsedBySystem: The identifier was provided to the system that constructed the instance but can't be verified.
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.IdentifierUse">
            <summary>
            Identifies how the II should be used
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.IdentifierUse.Business">
            <summary>
            Business: The identifier belongs to an object that is associated with specific business practices.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.IdentifierUse.Version">
            <summary>
            Version: The identifier is used with a specific instance of an object.
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.II">
            <summary>
            A unique reference number that identifies a thing or object.
            </summary>
            <remarks>
            <para>As stated within HL7 documentation, information processing systems claiming conformance to HL7v3
            shall never assume receiving applications can infer the identity of an issuing authority.
            </para>
            <para>
            An identifier allows a system to uniquely identify not only the object, but what domain (root)
            that particular object was assigned within. 
            </para>
            <para>
            Some examples of an instance identifier are a health care identifier number where by the number
            itself is meaningless without knowing the domain 
            </para>
            </remarks>
            <example>
            <code title="Creating a new II" lang="cs">
            <![CDATA[
                II instance = new II(new OID("1.1.1.2"), "123987");
                		instance.AssigningAuthorityName = "Dr. Acula";
                        instance.Use = IdentifierUse.Business;
                        instance.Scope = IdentifierScope.BusinessIdentifier;
                        instance.Validate();
                   		Console.WriteLine(instance.Root + instance.Extension);
                		Console.ReadKey();
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.#ctor">
            <summary>
            Create a new instance of the II
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.#ctor(MARC.Everest.DataTypes.Primitives.OID)">
            <summary>
            Create a new instance of an instance identifier with the specified root
            </summary>
            <param name="root">The root of the new II</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.#ctor(MARC.Everest.DataTypes.Primitives.OID,System.String)">
            <summary>
            Create a new instance identifier with the specified root and extension
            </summary>
            <param name="root">The root of the new II</param>
            <param name="extension">The extension of the new II</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.#ctor(System.Guid)">
            <summary>
            Creates a new instance identifier with a GUID as the root
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.II.Root">
            <summary>
            A unique identifier that guarantees the global uniqueness of the instance identifier
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.II.Extension">
            <summary>
            A character string as a unqiue identifier within the scope of the identifier root
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.II.IdentifierName">
            <summary>
            The human readable name of the identifier (ITS DT R2 only)
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.II.Displayable">
            <summary>
            Specifies if the identifier is intended for human display and data entry
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.II.Scope">
            <summary>
            Specifies the scope in which the identifier applies to the object
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.II.Reliability">
            <summary>
            Specifies the reliability of the instance identifier
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.II.AssigningAuthorityName">
            <summary>
            The authority responsible for assigning the II
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.II.Use">
            <summary>
            How the identifier is intended to be used
            </summary>
            <remarks>In Everest 1.0 this property is being deprecated in favour of
            the Scope property.</remarks>
            <example cref="T:System.InvalidOperationException">When the Scope property value cannot be translated to IdentifierUse</example>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.IsRootOid(MARC.Everest.DataTypes.II)">
            <summary>
            Helper function, returns true if the specified II has an OID
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.IsRootGuid(MARC.Everest.DataTypes.II)">
            <summary>
            Determines if the root is a guid
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.Validate">
            <summary>
            Validate
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.ValidateEx">
            <summary>
            Validate the instance identifier is valid, returning the detected issues
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.IsValidTokenFlavor(MARC.Everest.DataTypes.II)">
            <summary>
            Flavor validator for Token, only needs a root
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.IsValidPublicFlavor(MARC.Everest.DataTypes.II)">
            <summary>
            Flavor validator for Public
            </summary>
            <param name="ii">The instance to validate</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.IsValidOidFlavor(MARC.Everest.DataTypes.II)">
            <summary>
            Flavor validator for OID
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.IsValidBusFlavor(MARC.Everest.DataTypes.II)">
            <summary>
            BUS flavor validator
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.IsValidVerFlavor(MARC.Everest.DataTypes.II)">
            <summary>
            VER flavor validator
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.IsValidBusAndVerFlavor(MARC.Everest.DataTypes.II)">
            <summary>
            Bus and Ver validator
            </summary>
            <remarks>Is this just II.BUS and II.VER? If so that doesn't make sense as the use for each of these is specified
            as BUS for BUS and VER for VER ..</remarks>
        </member>
        <member name="F:MARC.Everest.DataTypes.II.Comparator">
            <summary>
            Default comparator for II
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.op_Implicit(System.Guid)~MARC.Everest.DataTypes.II">
            <summary>
            Allows the developer to cast a <see cref="T:System.Guid"/> instance into an II instance
            instance
            </summary>
            <param name="g">The guid that is being cast</param>
            <returns>The created II instance</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.op_Implicit(MARC.Everest.DataTypes.Primitives.OID)~MARC.Everest.DataTypes.II">
            <summary>
            Allows the developer to cast a <see cref="T:MARC.Everest.DataTypes.Primitives.OID"/> to an II instance
            </summary>
            <param name="o">The OID to cast to an II</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.CreateToken(System.Guid)">
            <summary>
            Creates an II.TOKEN from the specified <paramref name="root"/>
            </summary>
            <param name="root">The GUI to create as the token's value</param>
            <returns>The instantiated II.TOKEN</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.CreateBus(System.Guid)">
            <summary>
            Creates an II.BUS with the specified <paramref name="root"/>
            </summary>
            <param name="root">The GUID representing the root of the II.BUS</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.CreatePublic(MARC.Everest.DataTypes.Primitives.OID,System.String)">
            <summary>
            Creates an II.PUBLIC with the specified <paramref name="root"/> and <paramref name="extension"/>
            </summary>
            <param name="root">The OID representing the root of the II.PUBLIC</param>
            <param name="extension">The extension of the II.PUBLIC</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.CreateBus(MARC.Everest.DataTypes.Primitives.OID,System.String)">
            <summary>
            Creates an II.BUS from the specified <paramref name="root"/> and <paramref name="extension"/>
            </summary>
            <param name="root">The root of the II.BUS</param>
            <param name="extension">The extension of the II.BUS</param>
            <remarks>Extension can only be present when the root is an OID</remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.Equals(MARC.Everest.DataTypes.II)">
            <summary>
            Determine if this II equals another instance of an II
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.II.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Semantic equals
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.INT">
            <summary>
            Integer numbers are precise numbers that are results of counting and enumerating.
            </summary>
            <remarks>
            Integer numbers are discrete, the set of integers is infinite but countable. No arbitrary limit is imposed on the range 
            of integer numbers. 
            <para>
            This implementation of the INT class (since Everest 1.0) contains operators that enable 
            us to perform arithmetic operations against the data within.
            <example>
            <code lang="cs" title="Integer division">
            <![CDATA[
            INT i1 = 10, input = 0;
            do
            {
                Console.WriteLine("Enter a positive number to divide 10 by:");
                input = (INT)Console.ReadLine();
            } while(input <= 0);
            Console.WriteLine("10/{0} = {1}", input, i1 / input);
            ]]>
            </code>
            </example>
            </para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.#ctor">
            <summary>
            Creates a new instance of the INT class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the INT class with the specified initial value
            </summary>
            <param name="value">The initial value of the INT instance</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.IsValidPosFlavor(MARC.Everest.DataTypes.INT)">
            <summary>
            Validates that <paramref name="i"/> meets criteria for flavor INT.POS
            </summary>
            <param name="i">The INT to validate</param>
            <remarks>i.Value > 0</remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.IsValidNonNegFlavor(MARC.Everest.DataTypes.INT)">
            <summary>
            Validates that <paramref name="i"/> meets criteria for flavor INT.NONNEG
            </summary>
            <remarks>i.Value >= 0</remarks>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_Explicit(MARC.Everest.DataTypes.INT)~System.Int32">
            <summary>
            Converts an <see cref="T:MARC.Everest.DataTypes.INT"/> to an <see cref="T:System.Int32"/>
            </summary>
            <param name="o">INT to convert</param>
            <returns>Converted int</returns>
            <exception cref="T:System.InvalidCastException">When the valueof the INT is null</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_Implicit(MARC.Everest.DataTypes.INT)~MARC.Everest.DataTypes.REAL">
            <summary>
            Converts a REAL to INT
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_Implicit(System.Int32)~MARC.Everest.DataTypes.INT">
            <summary>
            Converts an <see cref="T:System.Int32"/> to an <see cref="T:MARC.Everest.DataTypes.INT"/>
            </summary>
            <param name="o">int to convert</param>
            <returns>Converted INT</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_Explicit(System.String)~MARC.Everest.DataTypes.INT">
            <summary>
            Converts a <see cref="T:System.String"/> to a <see cref="T:MARC.Everest.DataTypes.INT"/>
            </summary>
            <param name="s">String to convert</param>
            <returns>Converted INT</returns>
            <remarks>If the string is not in a valid form then the result is populated with a nullflavor of NI</remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_Implicit(MARC.Everest.DataTypes.INT)~System.Nullable{System.Int32}">
            <summary>
            Converts an <see cref="T:MARC.Everest.DataTypes.INT"/> to a <see cref="T:System.Int32"/>
            </summary>
            <param name="i">INT to convert</param>
            <returns>Converted nullable int</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_LessThan(MARC.Everest.DataTypes.INT,MARC.Everest.DataTypes.INT)">
            <summary>
            Compares <paramref name="a"/> with <paramref name="b"/> to ensure that
            <paramref name="a"/> is less than <paramref name="b"/>.
            </summary>
            <remarks>If either value is null then no comparison is made and the result is false</remarks>
            <param name="a">The value being compared</param>
            <param name="b">The value against which <paramref name="a"/> is being compared</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_GreaterThan(MARC.Everest.DataTypes.INT,MARC.Everest.DataTypes.INT)">
            <summary>
            Compares <paramref name="a"/> with <paramref name="b"/> to ensure that
            <paramref name="a"/> is greater than <paramref name="b"/>.
            </summary>
            <remarks>If either value is null then no comparison is made and the result is false</remarks>
            <param name="a">The value being compared</param>
            <param name="b">The value against which <paramref name="a"/> is being compared</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_LessThanOrEqual(MARC.Everest.DataTypes.INT,MARC.Everest.DataTypes.INT)">
            <summary>
            Compares <paramref name="a"/> with <paramref name="b"/> to ensure that
            <paramref name="a"/> is less than or equal to <paramref name="b"/>.
            </summary>
            <remarks>If either value is null then no comparison is made and the result is false</remarks>
            <param name="a">The value being compared</param>
            <param name="b">The value against which <paramref name="a"/> is being compared</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_GreaterThanOrEqual(MARC.Everest.DataTypes.INT,MARC.Everest.DataTypes.INT)">
            <summary>
            Compares <paramref name="a"/> with <paramref name="b"/> to ensure that
            <paramref name="a"/> is greater than or equal to <paramref name="b"/>.
            </summary>
            <remarks>If either value is null then no comparison is made and the result is false</remarks>
            <param name="a">The value being compared</param>
            <param name="b">The value against which <paramref name="a"/> is being compared</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.Equals(MARC.Everest.DataTypes.INT)">
            <summary>
            Determine if this INT equals another INT
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.Max(MARC.Everest.DataTypes.INT)">
            <summary>
            Get the maximum of this integer and <paramref name="other"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.Min(MARC.Everest.DataTypes.INT)">
            <summary>
            Get the maximum of this integer and <paramref name="other"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_Addition(MARC.Everest.DataTypes.INT,MARC.Everest.DataTypes.INT)">
            <summary>
            Adds <paramref name="a"/> to <paramref name="b"/>
            </summary>
            <remarks>
            The following rules are applied to this arithmetic operation:
            <list type="bullet">
                <item><description>If either operand is null, the result is null</description></item>
                <item><description>If either operand is null flavored, the result is a new instance of <see cref="T:INT"/> with the null flavor of NoInformation</description></item>
                <item><description>If either operand does not have a value associated with it (ie: not null and not null flavored with a null value) the result is a new instance of <see cref="T:INT"/> with a null flavor of Other</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_UnaryNegation(MARC.Everest.DataTypes.INT)">
            <summary>
            Negates <paramref name="a"/>
            </summary>
            <remarks>
            The following rules are applied to this arithmetic operation:
            <list type="bullet">
                <item><description>If the operand is null, the result is null</description></item>
                <item><description>If the operand is null flavored, the result is a new instance of <see cref="T:INT"/> with the null flavor of NoInformation</description></item>
                <item><description>If the operand does not have a value associated with it (ie: not null and not null flavored with a null value) the result is a new instance of <see cref="T:INT"/> with a null flavor of Other</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_Subtraction(MARC.Everest.DataTypes.INT,MARC.Everest.DataTypes.INT)">
            <summary>
            Subtracts <paramref name="a"/> to <paramref name="b"/>
            </summary>
            <remarks>
            The following rules are applied to this arithmetic operation:
            <list type="bullet">
                <item><description>If either operand is null, the result is null</description></item>
                <item><description>If either operand is null flavored, the result is a new instance of <see cref="T:INT"/> with the null flavor of NoInformation</description></item>
                <item><description>If either operand does not have a value associated with it (ie: not null and not null flavored with a null value) the result is a new instance of <see cref="T:INT"/> with a null flavor of Other</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_Subtraction(MARC.Everest.DataTypes.INT,MARC.Everest.DataTypes.REAL)">
            <summary>
            Subtracts <paramref name="b"/> from <paramref name="a"/>
            </summary>
            <remarks>
            The following rules are applied to this arithmetic operation:
            <list type="bullet">
                <item><description>If either operand is null, the result is null</description></item>
                <item><description>If either operand is null flavored, the result is a new instance of <see cref="T:REAL"/> with the null flavor of NoInformation</description></item>
                <item><description>If either operand does not have a value associated with it (ie: not null and not null flavored with a null value) the result is a new instance of <see cref="T:REAL"/> with a null flavor of Other</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_Addition(MARC.Everest.DataTypes.INT,MARC.Everest.DataTypes.REAL)">
            <summary>
            Adds <paramref name="b"/> to <paramref name="a"/>
            </summary>
            <remarks>
            The following rules are applied to this arithmetic operation:
            <list type="bullet">
                <item><description>If either operand is null, the result is null</description></item>
                <item><description>If either operand is null flavored, the result is a new instance of <see cref="T:REAL"/> with the null flavor of NoInformation</description></item>
                <item><description>If either operand does not have a value associated with it (ie: not null and not null flavored with a null value) the result is a new instance of <see cref="T:REAL"/> with a null flavor of Other</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_Multiply(MARC.Everest.DataTypes.INT,MARC.Everest.DataTypes.INT)">
            <summary>
            Multiplies <paramref name="a"/> with <paramref name="b"/>
            </summary>
            <remarks>
            The following rules are applied to this arithmetic operation:
            <list type="bullet">
                <item><description>If either operand is null, the result is null</description></item>
                <item><description>If either operand is null flavored, the result is a new instance of <see cref="T:INT"/> with the null flavor of NoInformation</description></item>
                <item><description>If either operand does not have a value associated with it (ie: not null and not null flavored with a null value) the result is a new instance of <see cref="T:INT"/> with a null flavor of Other</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_Multiply(MARC.Everest.DataTypes.INT,MARC.Everest.DataTypes.REAL)">
            <summary>
            Mutliplies <paramref name="a"/> by <paramref name="b"/>
            </summary>
            <remarks>
            The following rules are applied to this arithmetic operation:
            <list type="bullet">
                <item><description>If either operand is null, the result is null</description></item>
                <item><description>If either operand is null flavored, the result is a new instance of <see cref="T:REAL"/> with the null flavor of NoInformation</description></item>
                <item><description>If either operand does not have a value associated with it (ie: not null and not null flavored with a null value) the result is a new instance of <see cref="T:REAL"/> with a null flavor of Other</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_Division(MARC.Everest.DataTypes.INT,MARC.Everest.DataTypes.INT)">
            <summary>
            Divides <paramref name="a"/> with <paramref name="b"/>
            </summary>
            <remarks>
            The following rules are applied to this arithmetic operation:
            <list type="bullet">
                <item><description>If either operand is null, the result is null</description></item>
                <item><description>If either operand is null flavored, the result is a new instance of <see cref="T:INT"/> with the null flavor of NoInformation</description></item>
                <item><description>If either operand does not have a value associated with it (ie: not null and not null flavored with a null value) the result is a new instance of <see cref="T:INT"/> with a null flavor of Other</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_Division(MARC.Everest.DataTypes.INT,MARC.Everest.DataTypes.REAL)">
            <summary>
            Divides <paramref name="a"/> to <paramref name="b"/>
            </summary>
            <remarks>
            The following rules are applied to this arithmetic operation:
            <list type="bullet">
                <item><description>If either operand is null, the result is null</description></item>
                <item><description>If either operand is null flavored, the result is a new instance of <see cref="T:REAL"/> with the null flavor of NoInformation</description></item>
                <item><description>If either operand does not have a value associated with it (ie: not null and not null flavored with a null value) the result is a new instance of <see cref="T:REAL"/> with a null flavor of Other</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_Modulus(MARC.Everest.DataTypes.INT,MARC.Everest.DataTypes.INT)">
            <summary>
            Modulus of <paramref name="a"/> and<paramref name="b"/>
            </summary>
            <remarks>
            The following rules are applied to this arithmetic operation:
            <list type="bullet">
                <item><description>If either operand is null, the result is null</description></item>
                <item><description>If either operand is null flavored, the result is a new instance of <see cref="T:INT"/> with the null flavor of NoInformation</description></item>
                <item><description>If either operand does not have a value associated with it (ie: not null and not null flavored with a null value) the result is a new instance of <see cref="T:INT"/> with a null flavor of Other</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_Increment(MARC.Everest.DataTypes.INT)">
            <summary>
            Increment Unary operator on <paramref name="i"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.op_Decrement(MARC.Everest.DataTypes.INT)">
            <summary>
            Decrement unary operator on <paramref name="i"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.CompareTo(MARC.Everest.DataTypes.INT)">
            <summary>
            Compare this integer to another
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determine if <paramref name="other"/> is semantically equal to the current instance
            of <see cref="T:INT"/>
            </summary>
            <param name="other">The other instance of <see cref="T:INT"/> to compare</param>
            <returns>A <see cref="T:BL"/> indicating whether the two instance of <see cref="T:INT"/> are equivalent</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.NextValue">
            <summary>
            Gets the next value of INT given this value of INT
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.INT.PreviousValue">
            <summary>
            Gets the previous value of INT given this value of INT
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.IVL`1">
            <summary>
            A set of consecutive values of an ordered base datatype. Any ordered type can be the basis of an IVL
            </summary>
            <example>
            <code lang="cs" title="Interval from Oct 1 2009 - Nov 15 2009">
            <![CDATA[
            // Example: Patient must visit doctor between these dates
            IVL<TS> effectiveTime = new IVL<TS> 
            ( 
                DateTime.Parse("October 1, 2009"),  
            DateTime.Parse("November 15, 2009") 
            ); 
            effectiveTime.LowClosed = true; 
            effectiveTime.HighClosed = true; 
            effectiveTime.Operator = SetOperator.Inclusive; 
            ]]>
            </code>
            </example>
            <seealso cref="T:MARC.Everest.DataTypes.SXCM{T}"/>
        </member>
        <member name="M:MARC.Everest.DataTypes.IVL`1.#ctor">
            <summary>
            Create a new instance of IVL
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.IVL`1.#ctor(`0)">
            <summary>
            Create a new instance of IVL with the value <paramref name="value"/>
            </summary>
            <param name="value">The parameter</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.IVL`1.#ctor(`0,`0)">
            <summary>
            Create a new instance of IVL using the range specified
            </summary>
            <param name="low">The lower bound of the range</param>
            <param name="high">The upper bound of the range</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.IVL`1.OriginalText">
            <summary>
            Text indicating where this interval was derived
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.IVL`1.Low">
            <summary>
            This is the low limit. If the low limit is not known a null flavor should be specified
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.IVL`1.LowClosed">
            <summary>
            Specifies wheter low is included in the IVL or excluded from the IVL
            </summary>
            <remarks>
            For some reason this is described in HL7v3 Data Types R2 but not in R1. However, in R1
            the <see cref="P:Low"/> and <see cref="P:High"/> properties are of type IVXB, however in R2
            IVXB is never defined. This property will be used in place of the IVXB "inclusive" attribute.
            </remarks>
        </member>
        <member name="P:MARC.Everest.DataTypes.IVL`1.High">
            <summary>
            The high limit. If the hign limit is not known, a null flavour should be specified
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.IVL`1.HighClosed">
            <summary>
            Specifies whether high is inlcluded in the IVL or excluded in the IVL
            </summary>
            <remarks>
            For some reason this is described in HL7v3 Data Types R2 but not in R1. However, in R1
            the <see cref="P:Low"/> and <see cref="P:High"/> properties are of type IVXB, however in R2
            IVXB is never defined. This property will be used in place of the IVXB "inclusive" attribute.
            </remarks>
        </member>
        <member name="P:MARC.Everest.DataTypes.IVL`1.Center">
            <summary>
            The arithmetic mean of the interval
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.IVL`1.Width">
            <summary>
            The difference between the high and low bondary. Width is used when the size of the interval is known
            but the actual start and end points are not known. 
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.IVL`1.IsValidWidthFlavor(MARC.Everest.DataTypes.IVL{`0})">
            <summary>
            Flavor validator for IVL.WIDTH
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.IVL`1.IsValidHighFlavor(MARC.Everest.DataTypes.IVL{`0})">
            <summary>
            Flavor validator for IVL.HIGH
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.IVL`1.IsValidLowFlavor(MARC.Everest.DataTypes.IVL{`0})">
            <summary>
            Flavor validator for IVL.LOW
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.IVL`1.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determines semantic equality between this IVL and <paramref name="other"/>
            </summary>
            <remarks>
            Two instances of IVL are considered semantically equal when their <see cref="P:Low"/> and <see cref="P:High"/> bounds
            are semantically equal with one another. The following rules apply:
            <list type="number">
                <item><description>If the <see cref="P:High"/> property is null or positive infinity in both instances of <see cref="T:IVL"/> or if the <see cref="P:Low"/> property
                is null or negative infinity in both IVLs they can be semantically equal</description></item>
                <item><description>Two <see cref="T:IVL"/> instances that are not bound (<see cref="P:Low"/>/<see cref="P:High"/> null) will never be considered equal even if their <see cref="P:Value"/> and <see cref="P:Width"/> properties are semantically equal</description></item>
                
            </list>
            <para>
            Because IVL describes a set, an instance of IVL can be semantically equal to a SET with the same members. For example a <see cref="T:SET"/> instance containing
            the numbers {1,2,3,4,5} can be semantically equal to an <see cref="T:IVL{INT}"/> describing {1-5}. Note that when comparing an <see cref="T:IVL"/> to a <see cref="T:SET"/>
            the <see cref="F:ToSet()"/> method is called which can be quite costly in terms of CPU resources.
            </para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.IVL`1.SemanticEqualsInternal(MARC.Everest.DataTypes.SET{`0})">
            <summary>
            Determine if this IVL when represented as a <see cref="T:SET{T}"/>
            is semantically equivalent to <paramref name="set"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.IVL`1.Validate">
            <summary>
            Validates the IVL data type
            </summary>
            <remarks>
            Either the IVL is assigned a null flavor, or one of value, low, high or width is set and
            when lowIncluded is set, low is set and
            when highIncluded is set, high is set
            </remarks>
            <returns>True if the item is valid</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.IVL`1.ValidateEx">
            <summary>
            Validates the instance of IVL and returns the detected issues
            </summary>
            <remarks>
            An instance of IVL is valid if:
            <list type="bullet">
                <item><description>When <see cref="P:NullFlavor"/> is specified <see cref="P:Low"/>, <see cref="P:Width"/>, <see cref="P:High"/> and <see cref="P:Value"/> are null, and</description></item>
                <item><description>When <see cref="P:LowClosed"/> is specified <see cref="P:Low"/> is specified, and </description></item>
                <item><description>When <see cref="P:HighClosed"/> is specified <see cref="P:High"/> is specified, and </description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.IVL`1.Equals(MARC.Everest.DataTypes.IVL{`0})">
            <summary>
            Determine if this IVL of T is equal to another IVL of T
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.IVL`1.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.IVL`1.Contains(`0)">
            <summary>
            Determine if the interval described by this IVL
            contains the specified member
            </summary>
            <remarks>This function can only be called on IVL instances
            with a low and high</remarks>
            <exception cref="T:System.ArgumentException">Thrown when <typeparamref name="T"/> does not implement IComparable</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when either the Low or High properties is null and the 
            Width property is null or <typeparamref name="T"/> does not implement <see cref="T:MARC.Everest.DataTypes.Interfaces.IPqTranslatable"/>. Basically
            the set bounds cannot be determined.</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.IVL`1.Translate(MARC.Everest.DataTypes.PQ)">
            <summary>
            Translates this IVL by the specified quantity
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when the function cannot determine the
            a reliable translation point (ie: either low or high are null)</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.IVL`1.ToBoundIVL">
            <summary>
            Creates a new instance of <see cref="T:IVL{T}"/> with the details of <see cref="P:Low"/> and <see cref="P:High"/> using 
            <see cref="P:Low"/> and <see cref="P:High"/> or <see cref="P:Low"/> and <see cref="P:Width"/> or 
            <see cref="P:High"/> and <see cref="P:Low"/> from this instance
            </summary>
            <returns>
            A new instance of <see cref="T:IVL{T}"/> containing a low/high pair in place of low/width, high/width
            </returns>
            <exception cref="T:System.InvalidOperationException">When <typeparamref name="T"/> does not implement <see cref="T:MARC.Everest.DataTypes.Interfaces.IPqTranslatable{T}"/></exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.IVL`1.ToSet">
            <summary>
            Creates a set from a bound IVL
            </summary>
            <remarks>This function will call <see cref="F:FillInDetails"/> prior to construction of the set as it 
            needs to ensure that low and high bounds are known</remarks>
            <exception cref="T:System.InvalidOperationException">When <typeparamref name="T"/> does not implement <see cref="T:MARC.Everest.DataTypes.Interfaces.IOrderedDataType{T}"/></exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.IVL`1.ToString">
            <summary>
            Represent the set as a string
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.IVL`1.FromString(System.String)">
            <summary>
            Get parse an instance of IVL from a string representation
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.HIST`1">
            <summary>
            A collection of items that are ordered based on their history
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.HIST`1.#ctor">
            <summary>
            Create a new instance of a list
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.HIST`1.#ctor(System.Int32)">
            <summary>
            Create a new instance of the list with a specified capacity
            </summary>
            <param name="capacity">The initial capacity of the LIST</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.HIST`1.#ctor(System.Collections.IEnumerable)">
            <summary>
            Create a new list of items using values from another collection
            </summary>
            <param name="collection">The collection of items to add. Note: If an item does not match type <typeparamref name="T"/> it won't be added</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.HIST`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create a new list of items using values from another collection
            </summary>
            <param name="collection">The collection to add from</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.HIST`1.CreateHIST(`0[])">
            <summary>
            Create a new list of items using the specified items
            </summary>
            <param name="item">The collection to add from</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.HIST`1.Parse(MARC.Everest.DataTypes.LIST{MARC.Everest.Interfaces.IGraphable})">
            <summary>
            Create a hist of T from Array of graphable (shallow copy)
            </summary>
            <remarks>Usually, this is called when formatting</remarks>
            <param name="o">The array of objects to add</param>
        </member>
        <member name="T:MARC.Everest.DataTypes.LIST`1">
            <summary>
            A collection that contains other discrete (but not necessarily distinct) values in a defined sequence.
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.#ctor">
            <summary>
            Create a new instance of a list
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.#ctor(System.Int32)">
            <summary>
            Create a new instance of the list with a specified capacity
            </summary>
            <param name="capacity">The initial capacity of the LIST</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.#ctor(System.Collections.IEnumerable)">
            <summary>
            Create a new list of items using values from another collection
            </summary>
            <param name="collection">The collection of items to add. Note: If an item does not match type <typeparamref name="T"/> it won't be added</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create a new list of items using values from another collection
            </summary>
            <param name="collection">The collection to add from</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.CreateList(`0[])">
            <summary>
            Creates a new LIST containing the specified <paramref name="items"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.op_Implicit(System.Collections.Generic.List{`0})~MARC.Everest.DataTypes.LIST{`0}">
            <summary>
            Cast any IEnumerable to this list
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.SubSequence(System.Int32,System.Int32)">
            <summary>
            Return a portion of the list
            </summary>
            <param name="Start">The first item to include</param>
            <param name="End">The last item to include</param>
            <example>
            <code title="Using sub-sequence" lang="cs">
            <![CDATA[
            // Create list of identifiers (Person, Place, or Thing)
            // The first Item in the list has a zero Index
            LIST<II> set1 = new LIST<II>(new II[] 
            { 
                new II("1.1.1.1","1"), // set1[0] 
                new II("1.1.1.1","2"), 
                new II("1.1.1.1","3"), 
                new II("1.1.1.1","3"), 
                new II("1.1.1.1","4") 
            }); 
            LIST<II> set2 = (LIST<II>)set1.SubSequence(1, 2); // contains 1 items 
            set2 = (LIST<II>)set1.SubSequence(1); // set2 will hold the last four identifiers in the list       
            ]]>
            </code>
            </example>
            <exception cref="T:System.IndexOutOfRangeException">Thrown when either <paramref name="start"/> or <paramref name="end"/> are outside the bounds of the array</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="start"/> is greater than <paramref name="end"/></exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.SubSequence(System.Int32)">
            <summary>
            Return a portion of the list starting from the specified item
            </summary>
            <param name="start">The start index</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.LIST`1.IsEmpty">
            <summary>
            Determine if the collection is empty
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.IndexOf(`0)">
            <summary>
            Get the index of an item
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.Insert(System.Int32,`0)">
            <summary>
            Insert an item at a specified index
            </summary>
            <param name="index">The index to add <paramref name="item"/> at</param>
            <param name="item">The item to add</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.RemoveAt(System.Int32)">
            <summary>
            Remove a specific item
            </summary>
            <param name="index">The index to remove at</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.LIST`1.Item(System.Int32)">
            <summary>
            Indexer properter
            </summary>
            <param name="index">The index of the item to retrieve</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.AddRange(MARC.Everest.DataTypes.LIST{`0})">
            <summary>
            Add a range of values to this list
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.Add(`0)">
            <summary>
            Add an item to the set
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.Clear">
            <summary>
            Clear this set
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.Contains(`0)">
            <summary>
            Determine if this set contains another item
            </summary>
            <param name="item">The item to search for</param>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy this to an array
            </summary>
            <param name="array">The destination array</param>
            <param name="arrayIndex">The array index</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.LIST`1.Count">
            <summary>
            Return the number of items in the set
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.LIST`1.IsReadOnly">
            <summary>
            Return if the set is read only
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.Remove(`0)">
            <summary>
            Remove an item from the set
            </summary>
            <param name="item">The item to remove</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.GetEnumerator">
            <summary>
            Get this set's enumerator
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.LIST`1.Items">
            <summary>
            Items contained in this set
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determine if the two items are semantically equal
            </summary>
            <remarks>Two instances of LIST are semantically equal when they contain the same items in the same sequence</remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.Parse(MARC.Everest.DataTypes.LIST{MARC.Everest.Interfaces.IGraphable})">
            <summary>
            Create a set of T from Array o (shallow copy)
            </summary>
            <remarks>Usually called from the formatter</remarks>
            <param name="o">The array of objects to add</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.LIST`1.First">
            <summary>
            Get the first item from the collection
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.LIST`1.Last">
            <summary>
            Get the last item from the collection
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.Equals(MARC.Everest.DataTypes.LIST{`0})">
            <summary>
            Determine if this LIST of T is the same as another LIST of T
            </summary>
            <remarks>
            This equals method differs form the equals method in <see cref="T:MARC.Everest.DataTypes.BAG{T}"/> as it ensures that not only
            every element within the <paramref name="other"/> list appears in the current list, but it appears in the same order. So
            <para>
                { 2, 3, 0, 1 }
            </para>
            <para>
            is equal to { 2, 3, 0, 1 }
            </para>
            <para>
            but not to { 2, 0, 1, 3 }
            </para>
            <para>Also, this method ensures that both lists are the same size</para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.IncludesAll(MARC.Everest.DataTypes.Interfaces.IColl{`0})">
            <summary>
            Returns true if <paramref name="other"/> contains all the items 
            in this list
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.LIST`1.ExcludesAll(MARC.Everest.DataTypes.Interfaces.IColl{`0})">
            <summary>
            Returns true if <paramref name="other"/> does not contain any of the 
            items in this list
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.MO">
             <summary>
             An MO is a quantity expressing the amount of money in some currency
             </summary>
             <remarks>
             The monetary amount class in Everest 1.0 contains methods that allow
             for arithmetic operations to be performed against instances for example:
             <example>
             <code lang="cs" title="Change Problem">
            Console.Write("Enter an Amount:$");
            MO amount = new MO(decimal.Parse(Console.ReadLine()), "CAD");
            MO loonies = new MO((int)(amount / 1), "CAD");
            amount -= loonies;
            MO quarters = new MO((decimal)(0.25 * (int)(amount / 0.25)), "CAD");
            amount -= quarters;
            MO dimes = new MO((decimal)(0.10 * (int)(amount / 0.10)), "CAD");
            amount -= dimes;
            MO nickels = new MO((decimal)(0.05 * (int)(amount / 0.05)), "CAD");
            amount -= nickels;
            Console.WriteLine("Total Change:\r\n{0} in loonies\r\n{1} in quarters\r\n{2} in dimes\r\n{3} in nickels\r\n{4} in pennies",
                loonies, quarters, dimes, nickels, amount);
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.#ctor">
            <summary>
            Creates a new instance of the MO class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.#ctor(System.Decimal)">
            <summary>
            Creates a new instance of the MO class with the specified value
            </summary>
            <param name="value">The initial value of the MO</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.#ctor(System.Decimal,System.String)">
            <summary>
            Creates a new instance of the MO class with the specified <paramref name="value"/> in the specified <paramref name="currency"/>
            </summary>
            <param name="value">The initial value of the MO</param>
            <param name="currency">The currency of the MO</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.MO.Currency">
            <summary>
            The currency code as defined by ISO 4217
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.MO.Precision">
            <summary>
            The number of significant digits of the decimal representation.
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.ToString">
            <summary>
            Represent this MO as a string
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.Validate">
            <summary>
            Validate
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.ValidateEx">
            <summary>
            Validate returning a list of detected issues
            </summary>
            <remarks>
            An instance of MO is considered valid when:
            <list type="number">
                <item><description>If the <see cref="P:NullFlavor"/> property has a value and the <see cref="P:Value"/> and <see cref="P:UncertainRange"/> properties are not set, and</description></item>
                <item><description>If the <see cref="P:Value"/> property is set, the <see cref="P:NullFlavor"/> and <see cref="P:UncertainRange"/> properties have no value, and</description></item>
                <item><description>If the <see cref="P:UncertainRange"/> property is set, the <see cref="P:NullFlavor"/> and <see cref="P:Value"/> properties are not set, and</description></item>
                <item><description>If the <see cref="P:NullFlavor"/> property is not set then <see cref="P:Currency"/> property is set</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.Equals(MARC.Everest.DataTypes.MO)">
            <summary>
            Determine if this MO is equal to another MO
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.op_UnaryNegation(MARC.Everest.DataTypes.MO)">
            <summary>
            Negates <paramref name="a"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.op_Subtraction(MARC.Everest.DataTypes.MO,MARC.Everest.DataTypes.MO)">
            <summary>
            Subtracts <paramref name="b"/> from <paramref name="a"/>
            </summary>
            <exception cref="T:System.InvalidOperationException">When the currency of <paramref name="a"/> does not match the currency of <paramref name="b"/></exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.op_Addition(MARC.Everest.DataTypes.MO,MARC.Everest.DataTypes.MO)">
            <summary>
            Adds <paramref name="b"/> to <paramref name="a"/>
            </summary>
            <exception cref="T:System.InvalidOperationException">When the currency of <paramref name="a"/> does not match the currency of <paramref name="b"/></exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.op_Multiply(MARC.Everest.DataTypes.MO,MARC.Everest.DataTypes.MO)">
            <summary>
            Multiplies <paramref name="b"/> with <paramref name="a"/>
            </summary>
            <exception cref="T:System.InvalidOperationException">When the currency of <paramref name="a"/> does not match the currency of <paramref name="b"/></exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.op_Multiply(MARC.Everest.DataTypes.REAL,MARC.Everest.DataTypes.MO)">
            <summary>
            Multiplies <paramref name="b"/> by <paramref name="a"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.op_Multiply(MARC.Everest.DataTypes.MO,MARC.Everest.DataTypes.REAL)">
            <summary>
            Multiplies <paramref name="b"/> by <paramref name="a"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.op_Division(MARC.Everest.DataTypes.MO,MARC.Everest.DataTypes.MO)">
            <summary>
            Divides <paramref name="b"/> with <paramref name="a"/>
            </summary>
            <exception cref="T:System.InvalidOperationException">When the currency of <paramref name="a"/> does not match the currency of <paramref name="b"/></exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.op_Division(MARC.Everest.DataTypes.REAL,MARC.Everest.DataTypes.MO)">
            <summary>
            Divides <paramref name="a"/> by <paramref name="b"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.op_Division(MARC.Everest.DataTypes.MO,MARC.Everest.DataTypes.REAL)">
            <summary>
            Divides <paramref name="a"/> by <paramref name="b"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determines if this instance of MO semantically equals <paramref name="other"/>
            </summary>
            <remarks>Two non-null non-null flavored instance of MO are considered equal when their currencies and values are equal or if their uncertain range properties
            are non-null, not null-flavored and equal.</remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.MO.CompareTo(MARC.Everest.DataTypes.MO)">
            <summary>
            Compare this MO to another MO
            </summary>
            <exception cref="T:System.ArgumentException">If the currencies of both MO instances don't match</exception>
        </member>
        <member name="T:MARC.Everest.DataTypes.NamespaceDoc">
            <summary>
            The namespace in which data types exist
            </summary>
            <remarks>
            <para>Data Types are a major portion of any HL7v3 system. Data types
            represent the foundational classes from which more complex classes can 
            be constructed.</para>
            <para>The MARC-HI Everest Framework contains a series of data types classes
            that are a hand written combination of R1 and R2 HL7 data types structures. They
            contain methods that aim to assist developers in the creation of their instances
            and all attempts have been made to sheild developers from the complexities of 
            the data types.</para>
            <example>
            <code lang="cs" title="Sheilded Data Types">
            // Note how a developer is sheilded from using data types directly
            REPC_IN000076CA instance = new REPC_IN000076CA();
            instance.Id = Guid.NewGuid();
            instance.CreationTime = DateTime.Now;
            instance.ProcessingMode = ProcessingID.Immediate;
            </code>
            </example>
            <para>The data types themselves may be formatted using one or more
            data type formatters. This makes it possible to use the same data types
            classes in instances that use R1 or R2 data types.</para>
            </remarks>
        </member>
        <member name="T:MARC.Everest.DataTypes.NPPD`1">
            <summary>
            Non-Parametric Probability Distribution
            </summary>
            <remarks>
            The NPPD data type represents a set of probabilities to form a histogram. All 
            of the elements in the set of <see cref="T:UVP{T}"/> are considered alternative
            values.
            <para>
            Typcially, NPPD is used where the sum of the probabilities of the <see cref="P:Items"/>
            should be less than or equal to one. This means that only one value for <typeparam name="T"/> may be true. 
            </para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.NPPD`1.#ctor">
            <summary>
            Creates a new instance of the non-parametric probability distribution
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.NPPD`1.#ctor(System.Collections.IEnumerable)">
            <summary>
            Creates a new instance of the non-parametric probability distribution 
            with the specified <paramref name="items"/>
            </summary>
            <param name="items">An enumerable source of items from which to construct the inital set of <see cref="P:Items"/></param>
        </member>
        <member name="M:MARC.Everest.DataTypes.NPPD`1.#ctor(System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.UVP{`0}})">
            <summary>
            Creates a new instance of the non-parametric probability distribution 
            with the specified <paramref name="items"/>
            </summary>
            <param name="items">An enumerable source of items from which to construct the inital set of <see cref="P:Items"/></param>
        </member>
        <member name="M:MARC.Everest.DataTypes.NPPD`1.CreateNPPD``1(MARC.Everest.DataTypes.UVP{``0}[])">
            <summary>
            Creates a new instance of the NPPD class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.NPPD`1.GetEnumerator">
            <summary>
            Get the enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.NPPD`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get the enumerator
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.NPPD`1.Validate">
            <summary>
            Validate this instance of NPPD
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.NPPD`1.Parse(MARC.Everest.DataTypes.LIST{MARC.Everest.Interfaces.IGraphable})">
            <summary>
            Create a set of T from Array o (shallow copy)
            </summary>
            <remarks>Usually called from the formatter</remarks>
            <param name="o">The array of objects to add</param>
        </member>
        <member name="T:MARC.Everest.DataTypes.NullFlavorUtil">
            <summary>
            Null Flavor utility
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.NullFlavorUtil.IsChildConcept(MARC.Everest.DataTypes.NullFlavor,MARC.Everest.DataTypes.NullFlavor)">
            <summary>
            Returns true if <paramref name="a"/> implies <paramref name="implied"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.NullFlavorUtil.GetCommonParent(MARC.Everest.DataTypes.NullFlavor,MARC.Everest.DataTypes.NullFlavor)">
            <summary>
            Gets a common ancestor
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.NullFlavorUtil.GetCommonParent(MARC.Everest.DataTypes.CS{MARC.Everest.DataTypes.NullFlavor},MARC.Everest.DataTypes.CS{MARC.Everest.DataTypes.NullFlavor})">
            <summary>
            Gets a common ancestor
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.NullFlavor">
            <summary>
            Indicates why a value is not present.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.NullFlavor.AskedUnknown">
            <summary>
            Information was sought but not found (e.g., patient was asked but didn't know).
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.NullFlavor.Derived">
            <summary>
            An actual value may exist, but it must be derived from the provided information (usually an EXPR generic data type extension will be used to convey the derivation expressionexpression ..
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.NullFlavor.Invalid">
            <summary>
            The value as represented in the instance is not a member of the set of permitted data values in the constrained value domain of a variable..
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.NullFlavor.Masked">
            <summary>
            There is information on this item available but it has not been provided by the sender due to security, privacy or other reasons. There may be an alternate mechanism for gaining access to this information. Note: using this null flavor does provide information that may be a breach of confidentiality, even though no detail data is provided. Its primary purpose is for those circumstances where it is necessary to inform the receiver that the information does exist without providing any detail. .
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.NullFlavor.NotApplicable">
            <summary>
            Known to have no proper value (e.g., last menstrual period for a male)..
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.NullFlavor.NotAsked">
            <summary>
            This information has not been sought (e.g., patient was not asked).
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.NullFlavor.Unavailable">
            <summary>
            Information is not available at this time but it is expected that it will be available later..
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.NullFlavor.NoInformation">
            <summary>
            No information whatsoever can be inferred from this exceptional value. This is the most general exceptional value. It is also the default exceptional value..
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.NullFlavor.NegativeInfinity">
            <summary>
            Negative infinity of numbers..
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.NullFlavor.Other">
            <summary>
            The actual value is not an element in the value domain of a variable. (e.g., concept not provided by required code system)..
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.NullFlavor.PositiveInfinity">
            <summary>
            Positive infinity of numbers..
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.NullFlavor.SufficientQuantity">
            <summary>
            The specific quantity is not known, but is known to be non-zero and is not specified because it makes up the bulk of the material. 'Add 10mg of ingredient X, 50mg of ingredient Y, and sufficient quantity of water to 100mL.' The null flavor would be used to express the quantity of water. .
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.NullFlavor.Trace">
            <summary>
            The content is greater than zero, but too small to be quantified..
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.NullFlavor.UnEncoded">
            <summary>
            The actual value has not yet been encoded within the approved valueset for the domain..
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.NullFlavor.Unknown">
            <summary>
            A proper value is applicable, but not known..
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.ON">
            <summary>
            A name for an organization
            </summary>
            <remarks>
            Organization Name
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.ON.#ctor">
            <summary>
            Create a new instance of EN
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ON.#ctor(MARC.Everest.DataTypes.EntityNameUse,System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.ENXP})">
            <summary>
            Create a new entity named instance using the specified values
            </summary>
            <param name="parts">The parts of the names</param>
            <param name="use">The uses of this name</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.ON.#ctor(MARC.Everest.DataTypes.SET{MARC.Everest.DataTypes.CS{MARC.Everest.DataTypes.EntityNameUse}},System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.ENXP})">
            <summary>
            Create a new entity named instance using the specified values
            </summary>
            <param name="parts">The parts of the names</param>
            <param name="use">The uses of this name</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.ON.CreateON(MARC.Everest.DataTypes.EntityNameUse,MARC.Everest.DataTypes.ENXP[])">
            <summary>
            Creates an organization name
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ON.CreateON(MARC.Everest.DataTypes.SET{MARC.Everest.DataTypes.CS{MARC.Everest.DataTypes.EntityNameUse}},MARC.Everest.DataTypes.ENXP[])">
            <summary>
            Creates an organization name
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ON.Validate">
            <summary>
            Validate the organization name
            </summary>
            <remarks>
            An organization name is valid if:
            <list type="bullet">
                <item>All validation rules from <see cref="T:MARC.Everest.DataTypes.EN"/> are satisfied</item>
                <item>The <see cref="!:Use"/> property is not one of {Indigenous, Pseudonym, Anonymous, Artist, Religious, MaidenName }</item>
                <item>The <see cref="F:MARC.Everest.DataTypes.ENXP.Type"/> property of each <see cref="!:Part"/> is not in { Given, Family }</item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.ON.ValidateEx">
            <summary>
            Extended validation with reported problems
            </summary>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.ON.Parse(MARC.Everest.DataTypes.EN)">
            <summary>
            Parse the data from an EN into an ON
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ON.Equals(MARC.Everest.DataTypes.ON)">
            <summary>
            Determine if this ON equals another ON
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ON.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.PDV`1">
            <summary>
            The primitive data value  (PDV) data type is not explicitly defined by HL7, however it is used here as a 
            shortcut to allow many types to share functionality
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PDV`1.#ctor">
            <summary>
            Create a new instance of PDV
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PDV`1.#ctor(`0)">
            <summary>
            Create a new instance of PDV with <paramref name="value"/> as initial value
            </summary>
            <param name="value">Initial value</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.PDV`1.Value">
            <summary>
            Gets or sets the value encapsulated by this object
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PDV`1.Validate">
            <summary>
            Validate this class
            </summary>
            <remarks>
            The instance is valid if either the nullFlavor is set XOR the value is set and all 
            validation rules from the base class are succeed.
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.PDV`1.ValidateEx">
            <summary>
            Validate the PDV passes conformance and return the detected issues
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PDV`1.ToString">
            <summary>
            Return this PDV as a string
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.PDV`1.Comparator">
            <summary>
            Comparator for sets
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PDV`1.Equals(MARC.Everest.DataTypes.PDV{`0})">
            <summary>
            Determine if this PDV of T is equal to another PDV of T
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PDV`1.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.PDV`1.MARC#Everest#DataTypes#Interfaces#IPrimitiveDataValue#Value">
            <summary>
            Gets or sets the value of the primitive
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.CalendarCycle">
            <summary>
            Specifies how the repetitions of the Periodic Interval are aligned to the cycles of the underlying calendar. A non-aligned periodic interval recurs independently from the calendar(e.g every 30 days). An aligned periodic interval is synchronized with the calendar(e.g the 5th day of every month).
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CalendarCycle.Year">
            <summary>
            The calendar cycle is aligned to years continuosly.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CalendarCycle.MonthOfYear">
            <summary>
            The calendar cycle is aligned to each month of the year.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CalendarCycle.Month">
            <summary>
            The calendar cycle is aligned to months continuously.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CalendarCycle.Week">
            <summary>
            The calendar cycle is aligned to weeks continuously.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CalendarCycle.WeekOfYear">
            <summary>
            The calendar cycle is aligned to each week of the year.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CalendarCycle.DayOfMonth">
            <summary>
            The calendar cycle is aligned to each day of the month.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CalendarCycle.Day">
            <summary>
            The calendar cycle is aligned to days continuously.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CalendarCycle.DayOfYear">
            <summary>
            The calendar cycle is aligned to each day of the year.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CalendarCycle.DayOfWeek">
            <summary>
            The calendar cycle is aligned to each day of the week.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CalendarCycle.HourOfDay">
            <summary>
            The calendar cycle is aligned to each hour of the day.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CalendarCycle.Hour">
            <summary>
            The calendar cycle is aligned to hours continuously.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CalendarCycle.MinuteOfHour">
            <summary>
            The calendar cycle is aligned to each minute of the hour.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CalendarCycle.Minute">
            <summary>
            The calendar cycle is aligned to minutes continuously.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CalendarCycle.SecondOfMinute">
            <summary>
            The calendar cycle is aligned to each second of the minute.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.CalendarCycle.Second">
            <summary>
            The calendar cycle is aligned to seconds continuously.
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.PIVL`1">
            <summary>
            An interval of time that recurs periodically. PIVL has two properties phase and period.
            </summary>
            <example>
            <code lang="cs" title="Repeat Oct 1 2009 - Nov 15 2009 every year">
            <![CDATA[
                //Set the interval width, the "phase".
                IVL<TS> phase = new IVL<TS> 
                ( 
                DateTime.Parse("October 1, 2009"),  
                DateTime.Parse("November 15, 2009") 
                ); 
                phase.Operator = SetOperator.Inclusive;      
                //Repeat the interval every year, the "period".
                PQ period = new PQ(1.0f, "y");
                //Create the periodic interval using the phase and period.
                PIVL<TS> pInterval = new PIVL<TS>(phase, period); 
                //Align the interval with the calendar year
                pInterval.Alignment = CalendarCycle.Year;
            ]]>
            </code>
            </example>
            <seealso cref="T:MARC.Everest.DataTypes.SXCM{T}"/>
        </member>
        <member name="P:MARC.Everest.DataTypes.PIVL`1.Phase">
            <summary>
            A prototype of the repeating interval
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.PIVL`1.Period">
            <summary>
            A time duration specifying as a reciprocal measure of the frequency at which the PIVL
            repeats
            </summary>
            <remarks>
            When specified, should be a reciprocal of the what the <see cref="P:Frequency"/> would have been. For example, 
            if the frequency would have been 2/10 mo (2 per 10 months) then the period is 10 mo/2 (or 5 mo). Alternatively if
            the frequency is 3/1 d, then the period is 1 d/3 (or 0.333... d). 
            <para>Only <see cref="P:Frequency"/> OR <see cref="P:Period"/> should be specified</para>
            </remarks>
        </member>
        <member name="P:MARC.Everest.DataTypes.PIVL`1.Alignment">
            <summary>
            Specifies if and how the repetitions are aligned to the cycles of the underlying calendar
            </summary>
            <remarks>CalendarCycles starting with "C" are continuous.</remarks>
        </member>
        <member name="P:MARC.Everest.DataTypes.PIVL`1.InstitutionSpecified">
            <summary>
            Indicates whether the exact timing is up to the party executing the schedule.
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.PIVL`1.Value">
            <summary>
            Indicates the value of the PIVL
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.PIVL`1.Count">
            <summary>
            Indicates the maximum number of times the interval can occur. Must be a valid INT.POS
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:MARC.Everest.DataTypes.PIVL`1.Frequency" -->
        <member name="P:MARC.Everest.DataTypes.PIVL`1.OriginalText">
            <summary>
            Gets or sets the reason why the specified interval was supplied
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PIVL`1.#ctor">
            <summary>
            Create a new instance of the PIVL type
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PIVL`1.#ctor(MARC.Everest.DataTypes.IVL{`0},MARC.Everest.DataTypes.PQ)">
            <summary>
            Create a new instance of the PIVL type using the phase and period specified
            </summary>
            <param name="phase">The phase of the PIVL</param>
            <param name="period">The period of the PIVL</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.PIVL`1.#ctor(MARC.Everest.DataTypes.IVL{`0},MARC.Everest.DataTypes.RTO{MARC.Everest.DataTypes.INT,MARC.Everest.DataTypes.PQ})">
            <summary>
            Create a new instance of the PIVL type using the phase and period specified
            </summary>
            <param name="phase">The phase of the PIVL</param>
            <param name="frequency">The period of the PIVL</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.PIVL`1.#ctor(MARC.Everest.DataTypes.IVL{`0},MARC.Everest.DataTypes.RTO{MARC.Everest.DataTypes.INT,MARC.Everest.DataTypes.PQ},MARC.Everest.DataTypes.INT)">
            <summary>
            Create a new instance of the PIVL type using the phase and period specified
            </summary>
            <param name="phase">The phase of the PIVL</param>
            <param name="frequency">The period of the PIVL</param>
            <param name="count">The maximum number of times the PIVL can repreat</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.PIVL`1.#ctor(MARC.Everest.DataTypes.IVL{`0},MARC.Everest.DataTypes.PQ,MARC.Everest.DataTypes.INT)">
            <summary>
            Create a new instance of the PIVL type using the phase and period specified
            </summary>
            <param name="phase">The phase of the PIVL</param>
            <param name="period">The period of the PIVL</param>
            <param name="count">The maximum number of times the PIVL can repreat</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.PIVL`1.Validate">
            <summary>
            Validate the PIVL
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PIVL`1.Equals(MARC.Everest.DataTypes.PIVL{`0})">
            <summary>
            Determine if this PIVL of T equals another PIVL of T
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PIVL`1.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PIVL`1.Contains(`0)">
            <summary>
            Determine if this instance of PIVL contains <paramref name="member"/> according 
            to the PIVL's definition
            </summary>
            <remarks>
            <para>Please note that the contains method does not adhere to the <see cref="P:Alignment"/> property and
            the determination of containment is defined strictly on <see cref="P:Phase"/> and <see cref="P:Period"/>.</para>
            <para>The algorithm for determining containment is as follows:</para>
            <list type="number">
                <item><description>Distance <paramref name="member"/> from the low bound of <see cref="P:Phase"/></description></item>
                <item><description>Divide the result of the previous operation by <see cref="P:Period"/></description></item>
                <item><description>Round the result of the previous operation to a whole number based on the unit specified in <see cref="P:Period"/></description></item>
                <item><description>Multiply the result of the previous operation by the <see cref="P:Period"/></description></item>
                <item><description>Translate <see cref="P:Phase"/> by the result of the previous operation</description></item>
                <item><description>Determine if <paramref name="member"/> resides in the translated <see cref="P:Phase"/> from the previous operation</description></item>
            </list>
            </remarks>
            <param name="member">The proposed member of the set</param>
            <returns>True if the PIVL contains <paramref name="member"/></returns>
            <exception cref="T:System.ArgumentException">When the distance between two instances of <typeparamref name="T"/> is not calculable. This occurs when
            <typeparamref name="T"/> does not implement <see cref="T:MARC.Everest.DataTypes.Interfaces.IDistanceable{T}"/></exception>
            <exception cref="T:System.InvalidOperationException">When the <see cref="P:Phase"/> property is not populated</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MARC.Everest.DataTypes.PIVL`1.ValidateEx" -->
        <member name="M:MARC.Everest.DataTypes.PIVL`1.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determine semantic equality between this and <paramref name="other"/>
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.PN">
            <summary>
             A name for a person. A sequence of name parts, such as given name or family name, prefix, suffix, etc. PN differs from EN because the qualifier type cannot include LS (Legal Status).
            </summary>
            <seealso cref="T:MARC.Everest.DataTypes.EN"/>
            <example>Example of PN, which is a restriction of EN
            <code lang="us" title="Creating a PN">
            <![CDATA[
                           PN name = new PN(
                                   EntityNameUse.Legal, 
                                   new List<ENXP> 
                                       { 
                                           new ENXP("James", EntityNamePartType.Given), 
                                           new ENXP("T", EntityNamePartType.Given),
                                           new ENXP("Kirk", EntityNamePartType.Family)
                                       }
                                   );
                   Console.Write(name.ToString("{FAM}, {GIV}")); // Output is Kirk, JamesT
                   Console.ReadKey();
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.PN.#ctor">
            <summary>
            Create a new instance of the PN class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PN.#ctor(System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.ENXP})">
            <summary>
            Create a new instance of the PN class using the parts specified
            </summary>
            <param name="parts">The parts</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.PN.#ctor(MARC.Everest.DataTypes.EntityNameUse,System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.ENXP})">
            <summary>
            Create a new instance of the PN class using the parts and use type specified
            </summary>
            <param name="use">The use type of the PN</param>
            <param name="parts">The parts</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.PN.#ctor(System.String)">
            <summary>
            Create a new instance of a simple PN
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PN.#ctor(MARC.Everest.DataTypes.EntityNameUse,System.String)">
            <summary>
            Create a new instance of a simple PN
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PN.CreatePN(MARC.Everest.DataTypes.EntityNameUse,MARC.Everest.DataTypes.ENXP[])">
            <summary>
            Create a new instance of PN
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PN.FromFamilyGiven(MARC.Everest.DataTypes.EntityNameUse,System.String,System.String[])">
            <summary>
            Creates an EN instance from a family and given name
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PN.IsValidBasicFlavor(MARC.Everest.DataTypes.PN)">
            <summary>
            TODO: Find a proper definition for PN.Basic
            </summary>
            <param name="p">The PN to validate</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.PN.Validate">
            <summary>
            Validate this instance
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PN.ValidateEx">
            <summary>
            Extended validation with additional data
            </summary>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.PN.Parse(MARC.Everest.DataTypes.EN)">
            <summary>
            Parse the data from an EN into a PN
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PN.Equals(MARC.Everest.DataTypes.PN)">
            <summary>
            Determine if this PN equals another PN
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PN.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.PQ">
            <summary>
            A dimensioned quantity expressing the result of measuring
            </summary>
            <remarks>
            <para>
            A physical quantity is used primarily for the storage of decimal values
            with UCUM (<a href="http://unitsofmeasure.org/">http://unitsofmeasure.org/</a>) units describing
            their unit of measure.
            </para>
            <para><b>Conversion of Units</b></para>
            <para>The PQ type only contains builtin support for the conversion of time units (min, mo, s, hr, etc...). However
            the PQ type can utilize unit converters via <see cref="T:MARC.Everest.DataTypes.Interfaces.IUnitConverter"/> instances 
            attached to the <b>UnitConverters</b> array. A default implementation exists for
            SI units called <see cref="T:MARC.Everest.DataTypes.Converters.SimpleSiUnitConverter"/>.</para>
            <example>
            <code lang="cs" name="Attaching an SI unit converter">
            <![CDATA[
            PQ.UnitConverters.Add(new SimpleSiUnitConverter());
            PQ length = new PQ(1, "km");
            length -= new PQ(1, "m");
            // results in 
            // length = 0.999 km
            ]]>
            </code>
            </example>
            <para><b>PQ with Time</b></para>
            <para>
            The physical quantity class contained within the Everest Framework contains several useful functions
            for the handling of date values and the addition of time spans with time stamps (TS + PQ). The calculation
            these provisioned quantities is derived from the <see cref="T:System.TimeSpan"/> class. To calculate these
            Quantites, the PQ datatype will take the system ticks (100 nanosecond units) and convert them
            using the following unit conversion table (where <i>S</i> is 1 second or 0x989680 ticks)
            </para>
            <list type="table">
            <listheader>
                <term>UCUM Measure</term>
                <description>Ticks / Notes</description>
            </listheader>
            <item><term>us (Microseconds)</term><description>0xA = <i>S</i> / 1,000,000</description></item>
            <item><term>ms (Milliseconds)</term><description>0x2710 = <i>S</i> / 1,000</description></item>
            <item><term>s (Seconds)</term><description>0x989680 = <i>S</i></description></item>
            <item><term>ks (Killoseconds)</term><description>0x2540be400 = <i>S</i> * 1,000 : used when attempting to reduce extremely large second values from cast operators (approx 3 hr)</description></item>
            <item><term>Ms (Megaseconds)</term><description>0x9184e72a000 = <i>S</i> * 1,000,000 : used when attempting to reduce extremely large killosecond values from cast operators (approx 2 mo)</description></item>
            <item><term>Gs (Gigaseconds)</term><description>0x2386f26fc1000 = <i>S</i> * 1,000,000,000 : used when attempting to reduce extremely large megasecond values from cast operators (approx 31 a)</description></item>
            <item><term>min (Minutes)</term><description>0x23c34600 = <i>S</i> * 60</description></item>
            <item><term>hr (Hours)</term><description>0x861c46800 = <i>S</i> * 3,600</description></item>
            <item><term>d (Days)</term><description>0xc92a69c000 = <i>S</i> * 3,600 * 24</description></item>
            <item><term>wk (Weeks)</term><description>0x58028e44000 = <i>S</i> * 3,600 * 24 * 7</description></item>
            <item><term>mo (Months)</term><description>0x17e6ca109000 = <i>S</i> * 3,600 * 24 * 30.416 : since month duration vaires, and since given just a timespan it is impossible to calculate which months were used to get the PQ, we take 365 / 12 to be the length of a month</description></item>
            <item><term>a (Annum)</term><description>0x11ed178C6C000 = <i>S</i> * 3,600 * 24 * 365</description> or 31,536,000 seconds. Note there is some drifting associated with leap years, this can be corrected with <see cref="F:TS.GetLeapDays"/></item>
            </list>
            </remarks>
            <seealso cref="T:MARC.Everest.DataTypes.QTY"/>
        </member>
        <member name="F:MARC.Everest.DataTypes.PQ.s_tickMap">
            <summary>
            Units of measure to tick map
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.PQ.UnitConverters">
            <summary>
            Gets a list of unit converters that can be used for 
            converting units
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.#ctor">
            <summary>
            Default ctor for PQ
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.#ctor(System.Decimal,System.String)">
            <summary>
            Create new instance of PQ using supplied values
            </summary>
            <param name="value">The value of the PQ</param>
            <param name="units">The units of the value</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.#ctor(System.TimeSpan,System.String)">
            <summary>
            Create a new instance of PQ using the supplied timestamp and unit of time
            </summary>
            <param name="value">The value of the provisioned quantity</param>
            <param name="unit">A valid unit of time to use from the timespan</param>
            <remarks>This is different from using the cast operator from a timestamp as it allows
            the developer to specify the desired unit measure to use. 
            <para>
            Note: Since it is impossible to reliably calculate the value when using months (ie unit "mo") a month is considered to be 30.375 days
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">If <paramref name="unit"/> is not a valid unit of time</exception>
        </member>
        <member name="P:MARC.Everest.DataTypes.PQ.Unit">
            <summary>
            The unit of measure specified in a UCUM code. 
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.PQ.Precision">
            <summary>
            The number of significant digits of the decimal representation.
            </summary>
            <remarks>
            <para>Setting the precision has an effect on the graphing of the instance and is populated in the R1 formatter by 
            the processing of parsing.</para>
            </remarks>
            <seealso cref="P:MARC.Everest.Datatypes.REAL.Precision"/>
        </member>
        <member name="P:MARC.Everest.DataTypes.PQ.CodingRationale">
            <summary>
            The reason that this quantity was provided
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.PQ.Translation">
            <summary>
            An alternative representation of the physcial quantity
            </summary>
            <example>PQ with metric and imperial measures
            <code lang="cs" title="PQ translation">
            <![CDATA[
            // 2.1 Meters
            PQ h = new PQ((decimal)2.1f, "m");
            // Translates to 6.8897 ft
            h.Translation = new SET<PQR>(new PQR(6.8897f, "ft_i", "2.16.840.1.113883.6.8"), PQR.Comparator);
            ]]>
            </code>
            </example>
        </member>
        <member name="P:MARC.Everest.DataTypes.PQ.Translatus">
            <summary>
            Repraesentatione ad translatus
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.IsValidTimeFlavor(MARC.Everest.DataTypes.PQ)">
            <summary>
            Determine if this PQ validates to the PQ.TIME flavor
            </summary>
            <param name="a">The PQ to validate</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.op_Implicit(System.String)~MARC.Everest.DataTypes.PQ">
            <summary>
            Parse PQ from string
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.op_Implicit(System.TimeSpan)~MARC.Everest.DataTypes.PQ">
            <summary>
            Casts a timespan to a provisioned quantity
            </summary>
            <remarks>
            This operation will always return a PQ with the value consisting of the number of
            seconds in the timespan object. You can convert this value to other units of measure
            using the <see cref="F:Convert(System.String)"/> method.
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.op_Explicit(MARC.Everest.DataTypes.PQ)~System.TimeSpan">
            <summary>
            Casts the <paramref name="pq"/> to  <see cref="T:System.TimeSpan"/>
            </summary>
            <exception cref="T:System.InvalidCastException">When <paramref name="pq"/> is null, nullFlavored or has no value or when <paramref name="pq"/> does not have a time unit</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.op_Explicit(MARC.Everest.DataTypes.PQ)~System.Decimal">
            <summary>
            Convert PQ to a double
            </summary>
            <exception cref="T:System.InvalidCastException">When the value if this PQ is null</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.op_Implicit(MARC.Everest.DataTypes.PQ)~System.Nullable{System.Decimal}">
            <summary>
            Converts <paramref name="s"/> to a nullable <see cref="T:System.Decimal"/>
            </summary>
            <param name="s">The <see cref="T:MARC.Everest.DataTypes.PQ"/> to cast</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.op_Implicit(System.Decimal)~MARC.Everest.DataTypes.PQ">
            <summary>
            Converts <paramref name="i"/> to a <see cref="T:MARC.Everest.DataTypes.PQ"/>
            </summary>
            <param name="d">The double to cast</param>
            <returns>The cast PQ</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.op_Implicit(System.Int32)~MARC.Everest.DataTypes.PQ">
            <summary>
            Converts <paramref name="i"/> to a <paramref name="T:MARC.Everest.Datatypes.PQ:MARC.Everest.Datatypes.PQ"/>
            </summary>
            <param name="i">The integer to convert</param>
            <returns>The cast PQ</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.ToString">
            <summary>
            Represent PQ as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.Validate">
            <summary>
            Validate this class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.op_UnaryNegation(MARC.Everest.DataTypes.PQ)">
            <summary>
            Negates <paramref name="a"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.op_Subtraction(MARC.Everest.DataTypes.PQ,MARC.Everest.DataTypes.PQ)">
            <summary>
            Subtracts <paramref name="b"/> from <paramref name="a"/>
            </summary>
            <exception cref="T:System.InvalidOperationException">When the unit of <paramref name="a"/> and <paramref name="b"/> are not comparable (ie: can't be converted by PQ)</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.op_Addition(MARC.Everest.DataTypes.PQ,MARC.Everest.DataTypes.PQ)">
            <summary>
            Adds <paramref name="b"/> to <paramref name="a"/>
            </summary>
            <exception cref="T:System.InvalidOperationException">When the unit of <paramref name="a"/> and <paramref name="b"/> are not comparable (ie: can't be converted by PQ)</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.op_Multiply(MARC.Everest.DataTypes.PQ,MARC.Everest.DataTypes.PQ)">
            <summary>
            Multiplies <paramref name="b"/> with <paramref name="a"/>
            </summary>
            <exception cref="T:System.InvalidOperationException">When the unit of <paramref name="a"/> and <paramref name="b"/> are not comparable (ie: can't be converted by PQ)</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.op_Multiply(MARC.Everest.DataTypes.REAL,MARC.Everest.DataTypes.PQ)">
            <summary>
            Multiplies <paramref name="b"/> by <paramref name="a"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.op_Multiply(MARC.Everest.DataTypes.PQ,MARC.Everest.DataTypes.REAL)">
            <summary>
            Multiplies <paramref name="b"/> by <paramref name="a"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.op_Division(MARC.Everest.DataTypes.PQ,MARC.Everest.DataTypes.PQ)">
            <summary>
            Multiplies <paramref name="b"/> with <paramref name="a"/>
            </summary>
            <exception cref="T:System.InvalidOperationException">When the unit of <paramref name="a"/> and <paramref name="b"/> are not comparable (ie: can't be converted by PQ)</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.op_Division(MARC.Everest.DataTypes.REAL,MARC.Everest.DataTypes.PQ)">
            <summary>
            Divides <paramref name="a"/> by <paramref name="b"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.op_Division(MARC.Everest.DataTypes.PQ,MARC.Everest.DataTypes.REAL)">
            <summary>
            Divides <paramref name="a"/> by <paramref name="b"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.Equals(MARC.Everest.DataTypes.PQ)">
            <summary>
            Determine if this PQ equals another instance of PQ
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.CompareTo(MARC.Everest.DataTypes.PQ)">
            <summary>
            Compares this PQ to another PQ
            </summary>
            <exception cref="T:System.ArgumentException">When the units of both PQ instances do not match</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.Translate(MARC.Everest.DataTypes.PQ)">
            <summary>
            Translates this PQ by a factor of <paramref name="translation"/>
            by applying the addition operator
            </summary>
            <param name="translation">The quantity to translate (or shift) this PQ by</param>
            <remarks>Results in a new PQ containing the result of the translation</remarks>
            <exception cref="T:System.ArgumentException">If the units of the PQ do not match</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.Scale(MARC.Everest.DataTypes.PQ)">
            <summary>
            Scales this PQ by <paramref name="scale"/>
            </summary>
            <param name="scale">The scale by which this instance should be scaled</param>
            <remarks>Results in a new PQ with the result</remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.Distance(MARC.Everest.DataTypes.PQ)">
            <summary>
            Calculate the distance between this PQ and 
            another PQ with the same unit of measure
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown units of this and <paramref name="other"/> are not comparable</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.IsUnitComparable(System.String)">
            <summary>
            Determines if this instance of PQ unit is comparable
            to the specified <paramref name="unit"/>
            </summary>
            <exception cref="T:System.ArgumentNullException">When <paramref name="unit"/> is null</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.Convert(System.String)">
            <summary>
            Convert this PQ to another unit of measure
            and return the result in a new PQ
            </summary>
            <exception cref="T:System.ArgumentException">When there is no method to convert between this PQ and <paramref name="unit"/></exception>
            <exception cref="T:System.InvalidOperationException">When this instance of PQ has no value to convert</exception>
            <exception cref="T:System.ArgumentNullException">When the unit argument is null</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determine if this instance of PQ semantically equals another
            instance of a data type.
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQ.ToIVL">
            <summary>
            Represents the PQ as an interval range represented by the precision
            </summary>
            <remarks>
            This function requires the <see cref="P:Precision"/> property to be set 
            in order to be of any use. When calling with the precision it will 
            return the appropriate Interval
            <example>
            <code lang="cs" title="Range of 1/3">
            PQ oneThirdFoot = new PQ(1.0f/3.0f, "[ft_i]");
            oneThird.Precision = 3;
            IVL&lt;PQ> ivl = oneThird.ToIVL();
            Console.WriteLine("1/3 [ft_i] is between {0} and {1}", ivl.Low, ivl.High);
            // Output is: 
            // 1/3 [ft_i] is between 0.333 [ft_i] and 0.333999999999 [ft_i]
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:MARC.Everest.DataTypes.PQR">
            <summary>
            An extension of the coded value datatype representing a physical quantity using an unit from any code 
            system . Used to show alternative representation for a physical quantity. The coded value represents 
            the unit (usually in some other coding system other than UCCUM)
            </summary>
            <seealso cref="T:MARC.Everest.DataTypes.CD"/>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQR.#ctor">
            <summary>
            Create a new instance of PQR
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQR.#ctor(System.Decimal,System.String,System.String)">
            <summary>
            Create a new instance of PQR
            </summary>
            <param name="value">The value of the measurement</param>
            <param name="code">The code of the unit of measure</param>
            <param name="codeSystem">The code system the unit of measure was drawn from</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.PQR.Value">
            <summary>
            The value of the translation
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.PQR.Precision">
            <summary>
            The number of significant digits of the decimal representation.
            </summary>
            <remarks>
            <para>Setting the precision has an effect on the graphing of the instance and is populated in the R1 formatter by 
            the processing of parsing.</para>
            </remarks>
            <seealso cref="P:MARC.Everest.Datatypes.REAL.Precision"/>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQR.ToString">
            <summary>
            Represent this PQR as a string
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.PQR.Comparator">
            <summary>
            Comparator for sets
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQR.Equals(MARC.Everest.DataTypes.PQR)">
            <summary>
            Determine if this PQR equals another PQR
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQR.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQR.ToDouble">
            <summary>
            Returns the representation of this instance as a double
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.PQR.ToInt">
            <summary>
            Returns the representation of this instance as an integer
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.PQR.MARC#Everest#DataTypes#Interfaces#IPrimitiveDataValue#Value">
            <summary>
            Value of the primitive data value
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Primitives.CodeValue`1">
            <summary>
            A code value is used by all of the coded value types.
            </summary>
            <remarks>
            <para>The CodeValue class permits the usage of CWE constrained
            properties within instances. The CodeValue is bound to a strongly
            typed enumeration, however it permits the use of "alternate" codes.</para>
            <para>When an alternate code is specified, the IsAlternate method
            will return true so long as the supplied value does not fall
            within the range of <typeparam name="T"/></para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.Primitives.CodeValue`1.#ctor">
            <summary>
            Creates a new instance of the code value class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Primitives.CodeValue`1.#ctor(`0)">
            <summary>
            Creates a new instance of the code value class
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Primitives.CodeValue`1.valueSetValue">
            <summary>
            The value set value of this string
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.Primitives.CodeValue`1.alternateCode">
            <summary>
            The string value of the code (if the value set value is not present)
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Primitives.CodeValue`1.op_Implicit(MARC.Everest.DataTypes.Primitives.CodeValue{`0})~`0">
            <summary>
            Cast the specified code value of T to T
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Primitives.CodeValue`1.op_Implicit(`0)~MARC.Everest.DataTypes.Primitives.CodeValue{`0}">
            <summary>
            Cast from a concrete T value to a code value of R
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.Primitives.CodeValue`1.Equals(System.Object)">
            <summary>
            Equals operation
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.Primitives.CodeValue`1.IsAlternateCodeSpecified">
            <summary>
            Returns false if the codevalue is not strongly typed
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Primitives.CodeValue`1.Parse(MARC.Everest.DataTypes.Primitives.CodeValue{System.String})">
            <summary>
            Parse attempt to parse the specified string codeValue, into a CodeValue&lt;T>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Primitives.CodeValue`1.ToString">
            <summary>
            Represent this object as a string
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Primitives.CodeValue`1.Equals(MARC.Everest.DataTypes.Primitives.CodeValue{`0})">
            <summary>
            Determine if this code value equals another code value
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.Primitives.NamespaceDoc">
            <summary>
            The namespace in which primitive support classes are declared
            </summary>
            <remarks>
            Primitives are used to support the data types in a more primitive
            fashion than the complex data types themselves.
            </remarks>
        </member>
        <member name="T:MARC.Everest.DataTypes.Primitives.OID">
            <summary>
            Represents an Object Identifier that uniquely identifies an object
            </summary>
            <remarks>
            <para>OIDs represent unique but predictable identifier for objects. An
            OID is in the dotted form 1.3.6.x.x.x. This primitive class exists to
            assist developers in the assigning of an OID to an <see cref="T:MARC.Everest.DataTypes.II"/>
            </para>
            </remarks>
        </member>
        <member name="F:MARC.Everest.DataTypes.Primitives.OID.oid">
            <summary>
            The string value of the oid
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Primitives.OID.#ctor">
            <summary>
            Creates a new instance of the OID class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Primitives.OID.#ctor(System.String)">
            <summary>
            Creates a new instance of the OID class with the specified <paramref name="oid"/>
            </summary>
            <param name="oid">The OID to use</param>
            <exception cref="T:System.FormatException">When <paramref name="oid"/> is not in the proper format</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.Primitives.OID.op_Implicit(MARC.Everest.DataTypes.Primitives.OID)~System.String">
            <summary>
            Casts the specified OID instance to a string
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Primitives.OID.op_Implicit(System.String)~MARC.Everest.DataTypes.Primitives.OID">
            <summary>
            Casts the specified string to an OID instance
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Primitives.OID.Equals(System.Object)">
            <summary>
            Compare this OID to <paramref name="obj"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.Primitives.OID.ToString">
            <summary>
            Convert this OID to string representation
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.QSC`1">
            <summary>
            Represents a genericized QSET which contains a collection of terms
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSC`1.#ctor">
            <summary>
            Creates a new instance of the QSET intersection class
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QSC`1.Terms">
            <summary>
            Gets or sets the terms that make up the union of this QSET
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSC`1.Validate">
            <summary>
            Validate that the QSET is valid. A QSET is valid when it contains at least two sets 
            in the <see cref="P:Terms"/> property and contains no-null terms.
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSC`1.Equals(MARC.Everest.DataTypes.QSC{`0})">
            <summary>
            Determine equality between two QSS instances
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSC`1.Equals(System.Object)">
            <summary>
            Determine equality between two items
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSC`1.Add(MARC.Everest.DataTypes.Interfaces.ISetComponent{`0})">
            <summary>
            Add an expression to the term set
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSC`1.Clear">
            <summary>
            Clear the terms
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSC`1.Contains(MARC.Everest.DataTypes.Interfaces.ISetComponent{`0})">
            <summary>
            Determine if the terms contain the item
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSC`1.CopyTo(MARC.Everest.DataTypes.Interfaces.ISetComponent{`0}[],System.Int32)">
            <summary>
            Copy the terms to an array
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QSC`1.Count">
            <summary>
            Count the items in the terms
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QSC`1.IsReadOnly">
            <summary>
            True if the terms are readonly
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSC`1.Remove(MARC.Everest.DataTypes.Interfaces.ISetComponent{`0})">
            <summary>
            Remove a term from the collection
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSC`1.GetEnumerator">
            <summary>
            Get the enumerator for the terms
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSC`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get the enumerator for the terms
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QSC`1.MARC#Everest#DataTypes#Interfaces#IListContainer#ContainedList">
            <summary>
            Contained list implementation for the IListContainer class used by 
            formatters
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.QSD`1">
            <summary>
            Represents a <see cref="T:QSET{T}"/> that has been specialized as a difference between <see cref="P:First"/> and <see cref="P:Second"/>
            </summary>
            <seealso cref="T:QSET{T}"/>
            <seealso cref="T:QSD{T}"/>
            <seealso cref="T:QSI{T}"/>
            <seealso cref="T:QSP{T}"/>
            <seealso cref="T:QSS{T}"/>
            <seealso cref="T:QSU{T}"/>
            <seealso cref="T:SXPR{T}"/>
            <seealso cref="T:SXCM{T}"/>
            <seealso cref="T:GTS"/>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSD`1.#ctor">
            <summary>
            Creates a new instance of the QSET difference class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSD`1.#ctor(MARC.Everest.DataTypes.Interfaces.ISetComponent{`0},MARC.Everest.DataTypes.Interfaces.ISetComponent{`0})">
            <summary>
            Creates a new instance of the QSET difference class with the specified sets
            </summary>
            <param name="minuend">The first set from which <paramref name="subtrahend"/> should be subtracted</param>
            <param name="subtrahend">The set by which <paramref name="minuend"/> should be subtracted</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.QSD`1.Minuend">
            <summary>
            The set from which <see cref="P:Subtrahend"/> is subtracted
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QSD`1.Subtrahend">
            <summary>
            The set by which <see cref="P:Minuend"/> is to be subtracted
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSD`1.Validate">
            <summary>
            Validate that the QSET is valid. A QSET is valid when it contains <see cref="P:First"/> and
            <paramref name="P:Second:Second"/> and contains no-null terms.
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSD`1.ValidateEx">
            <summary>
            Validate that the QSET is valid. A QSET is valid when it contains <see cref="P:First"/> and
            <paramref name="P:Second:Second"/> and contains no-null terms.
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSD`1.GetEquivalentSetOperator">
            <summary>
            Get equivalent set operator
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSD`1.GetEnumerator">
            <summary>
            Get the enumerator
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSD`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get the enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSD`1.Equals(MARC.Everest.DataTypes.QSD{`0})">
            <summary>
            Determine equality between two QSS instances
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSD`1.Equals(System.Object)">
            <summary>
            Determine equality between two items
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSD`1.Normalize">
            <summary>
            Normalize
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.QSET`1">
             <summary>
             A set of consecutive values of an ordered base data type
             </summary>
             <remarks>
             <para>QSET and its derivatives are concepts defined in HL7v3 data types R2, and as such
             should only be used when targeting R2 systems. QSET instances can be used in R1 instances within
             <see cref="T:GTS"/> and <see cref="T:SXPR{T}"/> however when formatted using an R1 formatter, the concepts
             are mapped to the equivalent R1 <see cref="T:SXCM{T}"/> concepts.</para>
             <example>
             <code lang="cs" title="Formatting R2 QSET with R1 Formatter">
             <![CDATA[
             GTS gts = new GTS();
            gts.Hull = new QSP<TS>(
                new QSU<TS>(
                    new QSI<TS>(
                        ((TS)"2001").ToIVL(), 
                        ((TS)"20010403").ToIVL()
                    ),
                    new QSD<TS>(
                        new QSI<TS>(
                            ((TS)"2005").ToIVL(),
                            new PIVL<TS>(
                                ((TS)"20050101").ToIVL(), 
                                new PQ(1,"wk")
                            )
                        ),
                        ((TS)"20050304").ToIVL()
                    )
                ),
                ((TS)"200504").ToIVL()
            );
             ]]>
             </code>
             when passed through the R1 formatter will result in the following XML:
             <code lang="xml" title="R1 Formatter Result">
             <![CDATA[
            <sxpr xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="SXPR_TS" xmlns="urn:hl7-org:v3">
              <comp xsi:type="SXPR_TS">
                <comp xsi:type="SXPR_TS">
                  <comp xsi:type="IVL_TS">
                    <low inclusive="true" value="20010101000000.000-0500" />
                    <high inclusive="true" value="20011231235959.999-0500" />
                  </comp>
                  <comp xsi:type="IVL_TS" operator="A">
                    <low inclusive="true" value="20010403000000.000-0400" />
                    <high inclusive="true" value="20010403235959.999-0400" />
                  </comp>
                </comp>
                <comp operator="I" xsi:type="SXPR_TS">
                  <comp xsi:type="SXPR_TS">
                    <comp xsi:type="IVL_TS">
                      <low inclusive="true" value="20050101000000.000-0500" />
                      <high inclusive="true" value="20051231235959.999-0500" />
                    </comp>
                    <comp xsi:type="PIVL_TS" operator="A">
                      <phase>
                        <low inclusive="true" value="20050101000000.000-0500" />
                        <high inclusive="true" value="20050101235959.999-0500" />
                      </phase>
                      <period unit="wk" value="1" />
                    </comp>
                  </comp>
                  <comp xsi:type="IVL_TS" operator="E">
                    <low inclusive="true" value="20050304000000.000-0500" />
                    <high inclusive="true" value="20050304235959.999-0500" />
                  </comp>
                </comp>
              </comp>
              <comp xsi:type="IVL_TS" operator="P">
                <low inclusive="true" value="20090401000000.000-0400" />
                <high inclusive="true" value="20090430235959.999-0400" />
              </comp>
            </sxpr>
             ]]>
             </code>
             Which is equivalent but not identical to the original structure when parsed
             </example>
             <para>
             While it is possible to use this structure in R1 set expression constructs, it is not
             possible to do the opposite since the structure of an SXPR is more loosely defined than
             structures based on QSET.
             </para>
             </remarks>
             <seealso cref="T:QSET{T}"/>
             <seealso cref="T:QSD{T}"/>
             <seealso cref="T:QSI{T}"/>
             <seealso cref="T:QSP{T}"/>
             <seealso cref="T:QSS{T}"/>
             <seealso cref="T:QSU{T}"/>
             <seealso cref="T:SXPR{T}"/>
             <seealso cref="T:SXCM{T}"/>
             <seealso cref="T:GTS"/>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSET`1.#ctor">
            <summary>
            Default constructor for value
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QSET`1.OriginalText">
            <summary>
            Reasoning behind the selection of the SET value
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSET`1.Equals(System.Object)">
            <summary>
            Equals override
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSET`1.Equals(MARC.Everest.DataTypes.QSET{`0})">
            <summary>
            Determines if this QSET is equal to <paramref name="other"/>
            </summary>
            <param name="other">The QSET to compare to</param>
            <returns>True if the two QSETs contain identical content</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSET`1.GetEquivalentSetOperator">
            <summary>
            Get the equivalent set operator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSET`1.TranslateToSXPR">
            <summary>
            Translate this QSET to an SXPR
            </summary>
            <exception cref="T:System.InvalidOperationException">When a member of the set cannot be translated to an SXCM expression</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSET`1.Normalize">
            <summary>
            Normalize this structure
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.QSI`1">
            <summary>
            Represents a <see cref="T:QSET{T}"/> that has been specialized as an intersection of other sets.
            </summary>
            <seealso cref="T:QSET{T}"/>
            <seealso cref="T:QSD{T}"/>
            <seealso cref="T:QSI{T}"/>
            <seealso cref="T:QSP{T}"/>
            <seealso cref="T:QSS{T}"/>
            <seealso cref="T:QSU{T}"/>
            <seealso cref="T:SXPR{T}"/>
            <seealso cref="T:SXCM{T}"/>
            <seealso cref="T:GTS"/>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSI`1.#ctor">
            <summary>
            Creates a new instance of the QSET intersection class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSI`1.#ctor(System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.Interfaces.ISetComponent{`0}})">
            <summary>
            Creates a new instance of the QSET intersection class containing the specified sets
            </summary>
            <param name="terms">The terms contained within the union</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSI`1.CreateQSI(MARC.Everest.DataTypes.Interfaces.ISetComponent{`0}[])">
            <summary>
            Creates a new instance of the QSI class with the specified <paramref name="terms"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSI`1.ValidateEx">
            <summary>
            Extended validation routine which returns a list of detected issues
            </summary>
            <remarks>An instance of QSET is considered valid when it contains at least two items and no property contains
            a null component</remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSI`1.GetEquivalentSetOperator">
            <summary>
            Get equivalent set operator
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSI`1.Parse(MARC.Everest.DataTypes.QSI{MARC.Everest.DataTypes.Interfaces.ISetComponent{MARC.Everest.DataTypes.Interfaces.IAny}})">
            <summary>
            Parse from another instance of QSI. Used for formatters
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSI`1.Normalize">
            <summary>
            Normalizes the QSI to include only QS* content
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.QSP`1">
            <summary>
            Represents a <see cref="T:QSET{T}"/> that has been specialized as a periodic hull between <see cref="P:First"/> and <see cref="P:Second"/>
            </summary>
            <seealso cref="T:QSET{T}"/>
            <seealso cref="T:QSD{T}"/>
            <seealso cref="T:QSI{T}"/>
            <seealso cref="T:QSP{T}"/>
            <seealso cref="T:QSS{T}"/>
            <seealso cref="T:QSU{T}"/>
            <seealso cref="T:SXPR{T}"/>
            <seealso cref="T:SXCM{T}"/>
            <seealso cref="T:GTS"/>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSP`1.#ctor">
            <summary>
            Creates a new instance of the QSET periodic hull class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSP`1.#ctor(MARC.Everest.DataTypes.Interfaces.ISetComponent{`0},MARC.Everest.DataTypes.Interfaces.ISetComponent{`0})">
            <summary>
            Creates a new instance of the QSET periodic hull class with the specified sets
            </summary>
            <param name="low">The set used as the basis for the periodic hull operation</param>
            <param name="high">The set used for the parameter of the periodic hull function</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.QSP`1.Low">
            <summary>
            The set that forms the basis of the hull operation
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QSP`1.High">
            <summary>
            The set used as a parameter to the hull operation
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSP`1.Validate">
            <summary>
            Validate that the QSET is valid. A QSET is valid when it contains <see cref="P:First"/> and
            <paramref name="P:Second:Second"/> and contains no-null terms.
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSP`1.ValidateEx">
            <summary>
            Validate that the QSET is valid. A QSET is valid when it contains <see cref="P:First"/> and
            <paramref name="P:Second:Second"/> and contains no-null terms.
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSP`1.GetEquivalentSetOperator">
            <summary>
            Periodic hull
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSP`1.GetEnumerator">
            <summary>
            Get the enumerator
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSP`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get the enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSP`1.Equals(MARC.Everest.DataTypes.QSP{`0})">
            <summary>
            Determine equality between two QSS instances
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSP`1.Equals(System.Object)">
            <summary>
            Determine equality between two items
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSP`1.Normalize">
            <summary>
            Normalize
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.QSS`1">
            <summary>
            Represents a <see cref="T:QSET{T}"/> that has been specialized as containing a set.
            </summary>
            <seealso cref="T:QSET{T}"/>
            <seealso cref="T:QSD{T}"/>
            <seealso cref="T:QSI{T}"/>
            <seealso cref="T:QSP{T}"/>
            <seealso cref="T:QSS{T}"/>
            <seealso cref="T:QSU{T}"/>
            <seealso cref="T:SXPR{T}"/>
            <seealso cref="T:SXCM{T}"/>
            <seealso cref="T:GTS"/>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSS`1.#ctor">
            <summary>
            Creates a new instance of the QSET set class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSS`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new instance of the QSET set class containing the specified <paramref name="collection"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSS`1.CreateQSS(`0[])">
            <summary>
            Creates a new instance of the QSET set class containing the specified <paramref name="collection"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSS`1.GetEquivalentSetOperator">
            <summary>
            Equivalent set operator
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QSS`1.Terms">
            <summary>
            Gets or sets the terms that make up the union of this QSET
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSS`1.Validate">
            <summary>
            Validate that the QSET is valid. A QSET is valid when it contains at least two sets 
            in the <see cref="P:Terms"/> property and contains no-null terms.
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSS`1.ValidateEx">
            <summary>
            Extended validation routine which returns a list of detected issues
            </summary>
            <remarks>An instance of QSET is considered valid when it contains at least one items and no property contains
            a null component</remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSS`1.GetEnumerator">
            <summary>
            Get the enumerator for this QSET SET
            </summary>
            <exception cref="T:System.NullReferenceException">When the value of <see cref="P:Terms"/> has not been set</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSS`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get the non-generic enumerator
            </summary>
            <exception cref="T:System.NullReferenceException">When the value of <see cref="P:Terms"/> has not been set</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSS`1.Add(`0)">
            <summary>
            Add an expression to the term set
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSS`1.Clear">
            <summary>
            Clear the terms
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSS`1.Contains(`0)">
            <summary>
            Determine if the terms contain the item
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSS`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the terms to an array
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QSS`1.Count">
            <summary>
            Count the items in the terms
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QSS`1.IsReadOnly">
            <summary>
            True if the terms are readonly
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSS`1.Remove(`0)">
            <summary>
            Remove a term from the collection
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSS`1.Equals(MARC.Everest.DataTypes.QSS{`0})">
            <summary>
            Determine equality between two QSS instances
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSS`1.Equals(System.Object)">
            <summary>
            Determine equality between two items
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QSS`1.MARC#Everest#DataTypes#Interfaces#IListContainer#ContainedList">
            <summary>
            Gets or sets the contents of the list contained by the object
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSS`1.Normalize">
            <summary>
            No normalization needed
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.QSU`1">
            <summary>
            Represents a <see cref="T:QSET{T}"/> that has been specialized as a union of other sets.
            </summary>
            <seealso cref="T:QSET{T}"/>
            <seealso cref="T:QSD{T}"/>
            <seealso cref="T:QSI{T}"/>
            <seealso cref="T:QSP{T}"/>
            <seealso cref="T:QSS{T}"/>
            <seealso cref="T:QSU{T}"/>
            <seealso cref="T:SXPR{T}"/>
            <seealso cref="T:SXCM{T}"/>
            <seealso cref="T:GTS"/>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSU`1.#ctor">
            <summary>
            Creates a new instance of the QSET union class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSU`1.#ctor(System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.Interfaces.ISetComponent{`0}})">
            <summary>
            Creates a new instance of the QSET union class containing the specified sets
            </summary>
            <param name="terms">The terms contained within the union</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSU`1.CreateQSU(MARC.Everest.DataTypes.Interfaces.ISetComponent{`0}[])">
            <summary>
            Creates a new instance of QSU with the specified <paramref name="terms"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSU`1.ValidateEx">
            <summary>
            Extended validation routine which returns a list of detected issues
            </summary>
            <remarks>An instance of QSET is considered valid when it contains at least two items and no property contains
            a null component</remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSU`1.GetEquivalentSetOperator">
            <summary>
            Get set operator
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QSU`1.Normalize">
            <summary>
            Normalizes the QSI to include only QS* content
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.QTY`1">
            <summary>
            The quantity data type is an abstract generalization for all data types whose value set has an order 
            relation and where difference is defined in all of the data type's totally ordered value subsets. A
            quantity type abstraction is needed in defining certain other types such as the interval and 
            probability distribution
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QTY`1.#ctor">
            <summary>
            Create a new instance of QTY
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QTY`1.#ctor(`0)">
            <summary>
            Create a new instance of QTY using the value specified
            </summary>
            <param name="value">The value of the QTY</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.QTY`1.Expression">
            <summary>
            Identifies an expression that represents the quantity
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QTY`1.OriginalText">
            <summary>
            Represents the original text that was used to determine the quantity
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QTY`1.Uncertainty">
            <summary>
            Specifies the uncertainty of the quantity using a distribution function and its parameters
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QTY`1.UncertaintyType">
            <summary>
            A code specifying the type of probability distribution in uncertainty. Possible values are shown in
            the specified enumeration
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QTY`1.UncertainRange">
            <summary>
            Indicates that the value comes from a range of possible values
            </summary>
            <remarks>
            <para>The uncertain range is used where the actual value is not known,
            but a range of possible values are.</para>
            <para>
            The uncertain range indicates a range of uncertain values (not explicitly
            equal to) whereas a value with uncertainty indicates that there is a 
            single value along with a distribution of uncertainty for the value.
            </para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.QTY`1.ToInt">
            <summary>
            Convert QTY to Int32
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QTY`1.ToDouble">
            <summary>
            Convert QTY to double
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QTY`1.Precision">
            <summary>
            Precision
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QTY`1.Validate">
            <summary>
            Validate this structure
            </summary>
            <remarks>
            A QTY is considered valid when:
            <list type="list">
                <item><term>When <see cref="F:Expression"/> is specified, <see cref="F:ExpressionLanguage"/> is specified</term></item>
                <item><term>Either <see cref="F:Uncertainty"/> or <see cref="F:UncertainRange"/> are specified (but not both), or neither is set</term></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.QTY`1.ValidateEx">
            <summary>
            Advanced validation with details
            </summary>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.QTY`1.op_Implicit(MARC.Everest.DataTypes.QTY{`0})~`0">
            <summary>
            Casts a <see cref="T:QTY{T}"/> to a <typeparamref name="T"/>
            </summary>
            <param name="value">The <see cref="T:QTY{T}"/> that is to be cast</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.QTY`1.MARC#Everest#DataTypes#Interfaces#IQuantity#Expression">
            <summary>
            Expression of the quantity
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QTY`1.MARC#Everest#DataTypes#Interfaces#IQuantity#OriginalText">
            <summary>
            Original text of the quantity
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QTY`1.MARC#Everest#DataTypes#Interfaces#IQuantity#Uncertainty">
            <summary>
            Gets or sets the uncertainty of the quantity
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.QTY`1.MARC#Everest#DataTypes#Interfaces#IQuantity#UncertainRange">
            <summary>
            Gets or sets the uncertainty of the quantity
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QTY`1.Equals(MARC.Everest.DataTypes.QTY{`0})">
            <summary>
            Determine if this QTY of T is equal to another QTY of T
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.QTY`1.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.QTY`1.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determine if this instance of QTY semantically equals <paramref name="other"/>
            </summary>
            <param name="other">The other datatype to compare for semantic equality</param>
            <remarks>There are not specific restrictions on QTY and semantic equality however 
            because QTY is described as a generic type in Everest, the semantic equality check 
            must be performed to ensure the type of encapsulated data matches</remarks>
            <returns></returns>
        </member>
        <member name="T:MARC.Everest.DataTypes.REAL">
            <summary>
            Represents fractional numbers.
            </summary>
            <remarks>
             Typically used whenever quantities are measured, estimated or computed from other
            real numbers. The typical representation is decimal where the number of significant decimal digits is
            known as the precision
            </remarks>
            <seealso cref="T:MARC.Everest.DataTypes.QTY"/>
            <example> An example of a REAL
            <code lang="cs" title="Example of REAL Operations">
            <![CDATA[
            REAL radius = 3.0f,
                parimeter = 2 * Math.PI * radius;
            parimeter.Precision = 4;
            IVL<REAL> ivl = parimeter.ToIVL();
            Console.WriteLine("Parimeter is between {0} and {1}", ivl.Low, ivl.High);
            // Output: Parimeter is between 18.4895 and 18.4896
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.#ctor">
            <summary>
            Create a new instance of the REAL class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.#ctor(System.Double)">
            <summary>
            Create a new instance of REAL with an initial value of <paramref name="value"/>
            </summary>
            <param name="value">The initial value</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.REAL.Precision">
            <summary>
            The number of significant digits of the decimal representation. Null and a value of 0 means nothing 
            is known or stated about the precision
            </summary>
            <remarks>
            Modifying this property will affect the manner in which it is compared. Since floating point numbers will
            lose some precision after deserializing, this property has an effect on the tolerance of difference when determining
            equality. For example:
            <example>
            <code title="Precision Effects" lang="cs">
            REAL r1 = 0.333333333333333,
                r2 = 1/3.0f;
            Console.WriteLine(r1.Equals(r2)); // Displays false
            
            r2.Precision = 10;
            Console.WriteLine(r1.Equals(r2)); // Displays true
            </code>
            </example>
            <para>
            Setting the precision will also have an effect on the graphing of the value. By default a precision of 15 digits is used, so 
            "0.36" will be formatted by the R1 formatter as "0.360000000000000", if precision is changed to 1 (ie: 1 significant digit) then 
            the value is rounded to one decimal place and formatted as "0.4".
            </para>
            <para>
            After parsing a message from the wire, precision is set based on the value read from the wire. If a wire value had 4 digits then the 
            Precision property is set as 4.
            </para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.op_Explicit(MARC.Everest.DataTypes.REAL)~System.Double">
            <summary>
            Converts a <see cref="T:MARC.Everest.DataTypes.REAL"/> to a <see cref="T:System.Double"/>
            </summary>
            <param name="o">REAL to convert</param>
            <returns>Converted Double</returns>
            <exception cref="T:System.InvalidCastException">When the value of <paramref name="o"/> is null</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.op_Implicit(System.Double)~MARC.Everest.DataTypes.REAL">
            <summary>
            Converts a <see cref="T:System.Double"/> to a <see cref="T:MARC.Everest.DataTypes.REAL"/>
            </summary>
            <param name="o">Double</param>
            <returns>Converted REAL</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.op_Explicit(System.String)~MARC.Everest.DataTypes.REAL">
            <summary>
            Converts a <see cref="T:System.String"/> to a <see cref="T:MARC.Everest.DataTypes.REAL"/>
            </summary>
            <param name="o">string to convert</param>
            <returns>Converted REAL</returns>
            <remarks>The resulting REAL will have a nullflavor of NoInformation if the cast was not possible. 
            <para>The result will also have a precision set based on the location of the decimal point in the string representation</para></remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.op_Explicit(MARC.Everest.DataTypes.REAL)~MARC.Everest.DataTypes.INT">
            <summary>
            Converts a REAL to INT
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.op_Implicit(MARC.Everest.DataTypes.REAL)~System.Nullable{System.Double}">
            <summary>
            Converts a <see cref="T:MARC.Everest.DataTypes.REAL"/> to a <see cref="T:System.Double"/>
            </summary>
            <param name="o">REAL</param>
            <returns>Converted nullable Double</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.op_LessThan(MARC.Everest.DataTypes.REAL,MARC.Everest.DataTypes.REAL)">
            <summary>
            Compares <paramref name="a"/> with <paramref name="b"/> to ensure that
            <paramref name="a"/> is less than <paramref name="b"/>.
            </summary>
            <remarks>If either value is null then no comparison is made and the result is false</remarks>
            <param name="a">The value being compared</param>
            <param name="b">The value against which <paramref name="a"/> is being compared</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.op_GreaterThan(MARC.Everest.DataTypes.REAL,MARC.Everest.DataTypes.REAL)">
            <summary>
            Compares <paramref name="a"/> with <paramref name="b"/> to ensure that
            <paramref name="a"/> is greater than <paramref name="b"/>.
            </summary>
            <remarks>If either value is null then no comparison is made and the result is false</remarks>
            <param name="a">The value being compared</param>
            <param name="b">The value against which <paramref name="a"/> is being compared</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.op_LessThanOrEqual(MARC.Everest.DataTypes.REAL,MARC.Everest.DataTypes.REAL)">
            <summary>
            Compares <paramref name="a"/> with <paramref name="b"/> to ensure that
            <paramref name="a"/> is less than or equal to <paramref name="b"/>.
            </summary>
            <remarks>If either value is null then no comparison is made and the result is false</remarks>
            <param name="a">The value being compared</param>
            <param name="b">The value against which <paramref name="a"/> is being compared</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.op_GreaterThanOrEqual(MARC.Everest.DataTypes.REAL,MARC.Everest.DataTypes.REAL)">
            <summary>
            Compares <paramref name="a"/> with <paramref name="b"/> to ensure that
            <paramref name="a"/> is greater than or equal to <paramref name="b"/>.
            </summary>
            <remarks>If either value is null then no comparison is made and the result is false</remarks>
            <param name="a">The value being compared</param>
            <param name="b">The value against which <paramref name="a"/> is being compared</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.Equals(MARC.Everest.DataTypes.REAL)">
            <summary>
            Determine if this REAL equals another REAL
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.Max(MARC.Everest.DataTypes.REAL)">
            <summary>
            REturns the maximum of the two REAL numbers
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.Min(MARC.Everest.DataTypes.REAL)">
            <summary>
            REturns the minimum of the two REAL numbers
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.ToIVL">
            <summary>
            Represents the REAL as an interval range represented by the precision
            </summary>
            <remarks>
            This function requires the <see cref="P:Precision"/> property to be set 
            in order to be of any use. When calling with the precision it will 
            return the appropriate Interval
            
            <example>
            <code lang="cs" title="Range of 1/3">
            REAL oneThird = 1.0f/3.0f;
            oneThird.Precision = 3;
            IVL&lt;REAL> ivl = oneThird.ToIVL();
            Console.WriteLine("1/3 is between {0} and {1}", ivl.Low, ivl.High);
            // Output is: 
            // 1/3 is between 0.333 and 0.333999999999 
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.op_Addition(MARC.Everest.DataTypes.REAL,MARC.Everest.DataTypes.REAL)">
            <summary>
            Adds <paramref name="a"/> to <paramref name="b"/>
            </summary>
            <remarks>
            The following rules are applied to this arithmetic operation:
            <list type="bullet">
                <item><description>If either operand is null, the result is null</description></item>
                <item><description>If either operand is null flavored, the result is a new instance of <see cref="T:REAL"/> with the null flavor of NoInformation</description></item>
                <item><description>If either operand does not have a value associated with it (ie: not null and not null flavored with a null value) the result is a new instance of <see cref="T:REAL"/> with a null flavor of Other</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.op_UnaryNegation(MARC.Everest.DataTypes.REAL)">
            <summary>
            Negates <paramref name="a"/>
            </summary>
            <remarks>
            The following rules are applied to this arithmetic operation:
            <list type="bullet">
                <item><description>If the operand is null, the result is null</description></item>
                <item><description>If the operand is null flavored, the result is a new instance of <see cref="T:REAL"/> with the null flavor of the operand</description></item>
                <item><description>If the operand does not have a value associated with it (ie: not null and not null flavored with a null value) the result is a new instance of <see cref="T:REAL"/> with a null flavor of NoInformation</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.op_Subtraction(MARC.Everest.DataTypes.REAL,MARC.Everest.DataTypes.REAL)">
            <summary>
            Subtracts <paramref name="a"/> to <paramref name="b"/>
            </summary>
            <remarks>
            The following rules are applied to this arithmetic operation:
            <list type="bullet">
                <item><description>If either operand is null, the result is null</description></item>
                <item><description>If either operand is null flavored, the result is a new instance of <see cref="T:REAL"/> with the null flavor of NoInformation</description></item>
                <item><description>If either operand does not have a value associated with it (ie: not null and not null flavored with a null value) the result is a new instance of <see cref="T:REAL"/> with a null flavor of Other</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.op_Multiply(MARC.Everest.DataTypes.REAL,MARC.Everest.DataTypes.REAL)">
            <summary>
            Multiplies <paramref name="a"/> with <paramref name="b"/>
            </summary>
            <remarks>
            The following rules are applied to this arithmetic operation:
            <list type="bullet">
                <item><description>If either operand is null, the result is null</description></item>
                <item><description>If either operand is null flavored, the result is a new instance of <see cref="T:REAL"/> with the null flavor of NoInformation</description></item>
                <item><description>If either operand does not have a value associated with it (ie: not null and not null flavored with a null value) the result is a new instance of <see cref="T:REAL"/> with a null flavor of Other</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.op_Division(MARC.Everest.DataTypes.REAL,MARC.Everest.DataTypes.REAL)">
            <summary>
            Divides <paramref name="a"/> with <paramref name="b"/>
            </summary>
            <remarks>
            The following rules are applied to this arithmetic operation:
            <list type="bullet">
                <item><description>If either operand is null, the result is null</description></item>
                <item><description>If either operand is null flavored, the result is a new instance of <see cref="T:REAL"/> with the null flavor of NoInformation</description></item>
                <item><description>If either operand does not have a value associated with it (ie: not null and not null flavored with a null value) the result is a new instance of <see cref="T:REAL"/> with a null flavor of Other</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.CompareTo(MARC.Everest.DataTypes.REAL)">
            <summary>
            Compares this REAL instance to another
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.REAL.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determine semantic equality between this REAL and another REAL instance
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:MARC.Everest.DataTypes.SC">
            <summary>
            The SC class represents an <see cref="T:MARC.Everest.DataTypes.ST"/> that optionally has a code attached.
            </summary>
            <remarks>
            The text must always be present if a code is present.  
            Often the code specified is a local code.
            </remarks>
            <example>
            <code title="SC Code">
               <![CDATA[
                SC pregnancy = "Patient is 6 months pregnant";
                pregnancy.Code = new CD<String>("Z33.1", "2.16.840.1.113883.6.90")
                {
                    DisplayName = "Pregnancy State, Incidental"
                };
               ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.SC.#ctor">
            <summary>
            Creates a new instance of SC.
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SC.#ctor(System.String)">
            <summary>
            Creates a new instance of SC.
            </summary>
            <param name="data">The data to create SC with.</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.SC.#ctor(System.String,System.String)">
            <summary>
            Creates a new instance of SC.
            </summary>
            <param name="data">The data to create SC with.</param>
            <param name="language">The language of the data.</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.SC.#ctor(System.String,System.String,MARC.Everest.DataTypes.CD{System.String})">
            <summary>
            Creates a new instance of SC.
            </summary>
            <param name="data">The data to create SC with.</param>
            <param name="language">The language of the data.</param>
            <param name="code">The desired code for the SC</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.SC.Code">
            <summary>
            Gets or sets the code of attached to the string
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SC.op_Implicit(MARC.Everest.DataTypes.SC)~System.String">
            <summary>
            Implicit case to string.
            </summary>
            <param name="o">SC instance to cast.</param>
            <returns>string representation of SC.</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.SC.op_Implicit(System.String)~MARC.Everest.DataTypes.SC">
            <summary>
            Implicit cast from string.
            </summary>
            <param name="o">string to cast.</param>
            <returns>SC representation of string.</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.SC.Validate">
            <summary>
            Validate this class.
            </summary>
            <returns>True if valid, false otherwise.</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.SC.ValidateEx">
            <summary>
            Extended validation routine which returns the detected issues with the data type
            </summary>
            <remarks>
            An instance of SC is considered valid when:
            <list type="number">
                <item><description>All validation criteria from <see cref="T:MARC.Everest.DataTypes.ST"/> pass, and</description></item>
                <item><description>If the <see cref="P:Code"/> property is populated then the <see cref="P:Value"/> property must be populated</description></item>
                <item><description>If <see cref="P:NullFlavor"/> is populated, then the <see cref="P:Code"/> property must be null, and</description></item>
                <item><description>The value within the <see cref="P:Code"/> property is to have no <see cref="P:MARC.Everest.DataTypes.CD{T}.OriginalText"/>, and</description></item>
                <item><description>If the <see cref="P:Code"/> property is populated, it meets the validation criteria of CD</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.SC.Equals(MARC.Everest.DataTypes.SC)">
            <summary>
            Determine if this SC is equal to another SC
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SC.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SC.IsValidNtFlavor(MARC.Everest.DataTypes.SC)">
            <summary>
            SC.NT (no translations) flavor
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SC.CreateNt(System.String)">
            <summary>
            Creates an instance of the <see cref="T:MARC.Everest.DataTypes.SC"/> type such that it is conformant to the NoTranslations 
            flavor
            </summary>
            <param name="value">The value of the string</param>
            <returns>The constructed <see cref="T:MARC.Everest.DataTypes.SC"/> conformant to the NT flavor</returns>
        </member>
        <member name="T:MARC.Everest.DataTypes.SPQR">
            <summary>
            SPQR is an initialism from a Latin phrase, Senatus Populusque 
            Romanus ("The Senate and People of Rome")
            </summary>
            <remarks>
            <para>
            SPQR refers to the government of the ancient Roman Republic, and 
            used as an official emblem of the modern day comune (municipality) 
            of Rome. It appears on coins, at the end of documents made public 
            by inscription in stone or metal, in dedications of monuments and 
            public works, and was emblazoned on the standards of the Roman 
            legions. The phrase appears many hundreds of times in Roman 
            political, legal and historical literature, including the speeches 
            of Marcus Tullius Cicero and the history of Titus Livius. Since 
            the meaning and the words never vary, except for the spelling and 
            inflection of populus in literature, Latin dictionaries classify 
            it as a formula.
            <img src="http://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Roman_SPQR_banner.svg/150px-Roman_SPQR_banner.svg.png"/>
            </para>
            <para>From : http://en.wikipedia.org/wiki/SPQR</para>
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:MARC.Everest.DataTypes.SET`1" -->
        <member name="F:MARC.Everest.DataTypes.SET`1.DefaultComparator">
            <summary>
            Default comparator
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.#ctor">
            <summary>
            Create a new instance of the DSET class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.#ctor(System.Comparison{`0})">
            <summary>
            Createa a new instance of the DSET class using <paramref name="comparator"/> as the 
            comparison function
            </summary>
            <param name="comparator">The comparator to use for determining an items entry into the set</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.#ctor(System.Int32)">
            <summary>
            Create a new instance of the DSET class with the capacity specified
            </summary>
            <param name="capacity">The capacity</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.#ctor(System.Int32,System.Comparison{`0})">
            <summary>
            Create a new instance of the DSET class with the specified initial capacity and <paramref name="comparator"/>
            </summary>
            <param name="capacity">The initial capacity of the set</param>
            <param name="comparator">The comparator to use for determining an item's entry into the sset</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Comparison{`0})">
            <summary>
            Create a new instance of the DSET class using the specified collection and comparator
            </summary>
            <param name="collection">The initial collection</param>
            <param name="comparator">The comparator to use</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.#ctor(`0,System.Comparison{`0})">
            <summary>
            Create a new instance of the SET class using the specified first item
            </summary>
            <param name="firstItem">The first item in the collection</param>
            <param name="comparator">The comparator to use to determine if an item belongs to the set</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.#ctor(System.Collections.IEnumerable,System.Comparison{`0})">
            <summary>
            Create a new instance of the SET class using the specified items
            </summary>
            <param name="collection">A collection of items to add</param>
            <param name="comparator">The comparator to assign</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.#ctor(`0)">
            <summary>
            Create a set with one item
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.CreateSET(`0[])">
            <summary>
            Creates a new instance of the set collection with the default comparator
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.SET`1.Comparator">
            <summary>
            Get or set the predicate that will determine an object's involvement into the set
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.SET`1.IsEmpty">
            <summary>
            Determine if the set is empty
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.Union(MARC.Everest.DataTypes.SET{`0})">
            <summary>
            Union this set with another set
            </summary>
            <param name="otherset">The set to union with</param>
            <returns>The new unioned set</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.Union(`0)">
            <summary>
            Create a union of this set and another set
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.Except(MARC.Everest.DataTypes.SET{`0})">
            <summary>
            Return a new DSET with all contents of this DSET except the items in the other set
            </summary>
            <param name="otherset">The set of items to exclude</param>
            <example>
            Except function with two sets
            <code title="Except Function" lang="cs">
            <![CDATA[
            // Create sets 
            SET<II> set1 = new SET<II>(new II[] 
            { 
            new II("1.1.1.1","1"),  
            new II("1.1.1.1","2"), 
            new II("1.1.1.1","3") 
            }, II.Comparator);
            SET<II> set2 = new SET<II>(new II[]  
            { 
            new II("1.1.1.1", "3"), 
            new II("1.1.1.1", "4") 
            }, II.Comparator);
            SET<II> set3 = set1.Except(set2); // set3 has two items (1,2) 
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.Except(`0)">
            <summary>
            Return a new DSET with all the contents of this DSET except the element specified
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.Intersection(MARC.Everest.DataTypes.SET{`0})">
            <summary>
            Intersect this DSET and another DSET
            </summary>
            <param name="otherset">The other DSET to instersect with</param>
            <example>
            <code lang="cs" title="Intersecting two sets">
            <![CDATA[
            // Create sets 
            SET<II> set1 = new SET<II>(new II[] 
            { 
                    new II("1.1.1.1","1"),  
                    new II("1.1.1.1","2"), 
                    new II("1.1.1.1","3") 
            }, II.Comparator);
            SET<II> set2 = new SET<II>(new II[]  
            { 
                    new II("1.1.1.1", "3"), 
                    new II("1.1.1.1", "4") 
            }, II.Comparator);
            SET<II> set3 = (SET<II>)set1.Intersection(set2); // set3 has one item ("3") 
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.IndexOf(`0)">
            <summary>
            Get the index of an item
            </summary>
            <exception cref="T:System.NullReferenceException">When the comparator of this SET is null</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.Insert(System.Int32,`0)">
            <summary>
            Insert an item at a specified index
            </summary>
            <param name="index">The index to add <paramref name="item"/> at</param>
            <param name="item">The item to add</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.RemoveAt(System.Int32)">
            <summary>
            Remove a specific item
            </summary>
            <param name="index">The index to remove at</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.SET`1.Item(System.Int32)">
            <summary>
            Indexer property
            </summary>
            <param name="index">The index of the item to retrieve</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.Add(`0)">
            <summary>
            Add an item to the set
            </summary>
            <exception cref="T:MARC.Everest.Exceptions.DuplicateItemException">When <paramref name="item"/> is semantically equal to an item already contained within the set</exception>
            <exception cref="T:System.ArgumentNullException">When <paramref name="item"/> is null</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.Clear">
            <summary>
            Clear this set
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.Contains(`0)">
            <summary>
            Determine if this set contains another item
            </summary>
            <param name="item">The item to search for</param>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy this to an array
            </summary>
            <param name="array">The destination array</param>
            <param name="arrayIndex">The array index</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.SET`1.Count">
            <summary>
            Return the number of items in the set
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.SET`1.IsReadOnly">
            <summary>
            Return if the set is read only
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.Remove(`0)">
            <summary>
            Remove an item from the set
            </summary>
            <param name="item">The item to remove</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.GetEnumerator">
            <summary>
            Get this set's enumerator
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.SET`1.Items">
            <summary>
            Get or set the items that make up this set
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determine if the two items are semantically equal
            </summary>
            <param name="other"></param>
            <returns></returns>
            <remarks>Two instances of SET are semantically equal when they contain the same elements in the same sequence</remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.op_Explicit(MARC.Everest.DataTypes.LIST{`0})~MARC.Everest.DataTypes.SET{`0}">
            <summary>
            Create a set of T from Array o (shallow copy)
            </summary>
            <param name="o">The array of objects to add</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.Parse(MARC.Everest.DataTypes.LIST{MARC.Everest.Interfaces.IGraphable})">
            <summary>
            Create a set of T from Array of graphable (shallow copy)
            </summary>
            <remarks>Usually, this is called when formatting</remarks>
            <param name="o">The array of objects to add</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.FromString(System.String)">
            <summary>
            Parse a SET of T from the string <paramref name="s"/>
            </summary>
            <param name="s">The string to parse</param>
            <returns>The parsed set</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.ToString">
            <summary>
            Convert this set to a string
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.Equals(MARC.Everest.DataTypes.SET{`0})">
            <summary>
            Determine if this SET of T equals another SET of T
            </summary>
            <remarks>
            This equality method differs from the <see cref="T:MARC.Everest.DataTypes.BAG{T}"/> and <see cref="T:MARC.Everest.DataTypes.LIST{T}"/>
            in that it not only compares the contents of each set to ensure that all data is present in both sets, it uses the comparator of 
            this set to determine if the "item" is the same (rather than the equality method)
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.SET`1.First">
            <summary>
            Get the first item from the collection
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.SET`1.Last">
            <summary>
            Get the last item from the collection
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.SubSequence(System.Int32)">
            <summary>
            Return a portion of the set starting from the specified item
            </summary>
            <param name="start">The start index</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.SET`1.SubSequence(System.Int32,System.Int32)">
            <summary>
            Return a portion of the set
            </summary>
            <param name="Start">The first item to include</param>
            <param name="End">The last item to include</param>
            <example>
            <code title="Using sub-sequence" lang="cs">
            <![CDATA[
            // Create list of identifiers (Person, Place, or Thing)
            // The first Item in the list has a zero Index
            SET<II> set1 = new SET<II>(new II[] 
            { 
                new II("1.1.1.1","1"), // set1[0] 
                new II("1.1.1.1","2"), 
                new II("1.1.1.1","3"), 
                new II("1.1.1.1","3"), 
                new II("1.1.1.1","4") 
            }); 
            SET<II> set2 = (SET<II>)set1.SubSequence(1, 2); // contains 1 items 
            set2 = (SET<II>)set1.SubSequence(1); // set2 will hold the last four identifiers in the list       
            ]]>
            </code>
            </example>
            <exception cref="T:System.IndexOutOfRangeException">Thrown when either <paramref name="start"/> or <paramref name="end"/> are outside the bounds of the array</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="start"/> is greater than <paramref name="end"/></exception>
        </member>
        <member name="T:MARC.Everest.DataTypes.RTO`2">
            <summary>
            A quantity constructed as the quotient of a numerator quantity divided by the denominator
            </summary>
            <remarks>
            <para>
            The ratio class is not defined to represent rational numbers (although certainly possible). Common factors in the numerator and denominator never 
            cancel each other and RTO's are not automatically converted to a REAL number. 
            </para>
            <para>
            Everest .NET varies from the HL7v3 data types specification in that it uses generics to determine the types of 
            quantities used for the numerator and denominator. Since .NET supports reified generics, the constraint on the type
            used for numerator and denominator is expressed via generic parameters.
            </para>
            </remarks>
            <example>Create a new RTO
            <code lang="cs" title="Expressing pay using RTO $1,304 per week">
            <![CDATA[
            RTO<MO,PQ> pay = new RTO<MO,PQ>(
                new MO(1304,"CAD"),
                new PQ(1, "wk")
            );
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.RTO`2.#ctor">
            <summary>
            Creates a new instance of an RTO
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.RTO`2.#ctor(`0,`1)">
            <summary>
            Creates a new instance of an RTO with the specified <paramref name="numerator"/> and <paramref name="denominator"/>
            </summary>
            <param name="numerator">The numerator</param>
            <param name="denominator">The denominator</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.RTO`2.Numerator">
            <summary>
            The numerator. The quantity being divided in this ratio
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.RTO`2.Denominator">
            <summary>
            The denominator. The quantity that divides the <see cref="P:MARC.Everest.DataTypes.RTO`2.Numerator"/>
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.RTO`2.Precision">
            <summary>
            Precision is not supported on the RTO instance but may be applied to the 
            <see cref="P:Numerator"/> and <see cref="P:Denominator"/> seperately.
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.RTO`2.Uncertainty">
            <summary>
            Uncertainty is not directly supported on the RTO instance but may be applied seperately
            for the <see cref="P:Numerator"/> and <see cref="P:Denominator"/>
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.RTO`2.UncertaintyType">
            <summary>
            Uncertainty type is not directly supported on the RTO instance but may be applied seperately
            for the <see cref="P:Numerator"/> and <see cref="P:Denominator"/>
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.RTO`2.Value">
            <summary>
            Gets the value of this ratio
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.RTO`2.op_Explicit(MARC.Everest.DataTypes.RTO{`0,`1})~System.Double">
            <summary>
            Convert ratio to a double
            </summary>
            <exception cref="T:System.InvalidOperationException">If either <see cref="P:Numerator"/> or <see cref="P:Denominator"/> are null or null flavored</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.RTO`2.op_Explicit(MARC.Everest.DataTypes.RTO{`0,`1})~MARC.Everest.DataTypes.REAL">
            <summary>
            Convert this ratio to a <see cref="T:REAL"/> instance.
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.RTO`2.ToDouble">
            <summary>
            To double
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.RTO`2.ToInt">
            <summary>
            Convert this RTO into an integer if possible
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.RTO`2.ToString">
            <summary>
            Represent this RTO as a string
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.RTO`2.Validate">
            <summary>
            Validate that this RTO meets minimum conformance criteria
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.RTO`2.ValidateEx">
            <summary>
            Validate the RTO returning detected issues
            </summary>
            <remarks>An instance of RTO is considered valid when :
            <list type="number">
                <item><description>When the <see cref="P:NullFlavor"/> property is set, neither <see cref="P:Numerator"/> or <see cref="P:Denominator"/> may have a value</description></item>
                <item><description>When the <see cref="P:Numerator"/> and <see cref="P:Denominator"/> properties are set, the <see cref="P:NullFlavor"/> property is not set</description></item>
                <item><description>Whenever a <see cref="P:Numerator"/> is set, the <see cref="P:Denominator"/> must also be set</description></item>
                <item><description><see cref="P:UncertainRange"/> must never be set</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.RTO`2.Equals(MARC.Everest.DataTypes.RTO{`0,`1})">
            <summary>
            Determine if RTO of S/T is the same as another RTO of S/T
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.RTO`2.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.RTO`2.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determine if this RTO equals another
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.SLIST`1">
            <summary>
            A sequence of sampled values scaled and translated from a 
            list of integer values. Used to specify sampled biosignals
            </summary>
            <remarks>
            <para>
            The type of <see cref="P:Scale"/> is dictated by <typeparamref name="T"/>. For example, when
            a SLIST&lt;PQ> is specified, the <see cref="P:Scale"/> should be an instance of PQ.
            </para>
            <para>
            SLIST was introduced in DataTypes R2 and should not be used when formatting instances using 
            DataTypes R1 formatters.
            </para>
            </remarks>
        </member>
        <member name="F:MARC.Everest.DataTypes.SLIST`1.m_digits">
            <summary>
            Digits
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.#ctor">
            <summary>
            Creates a new instance of SLIST
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.#ctor(`0,MARC.Everest.DataTypes.Interfaces.IQuantity)">
            <summary>
            Creates a new instance of SLIST with the specified <paramref name="origin"/> and
            <paramref name="scale"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.#ctor(`0,MARC.Everest.DataTypes.Interfaces.IQuantity,System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.INT})">
            <summary>
            Creates a new instance of SLIST with the <paramref name="origin"/>, <paramref name="scale"/>
            and <paramref name="digits"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.CreateSLIST(`0,MARC.Everest.DataTypes.Interfaces.IQuantity,MARC.Everest.DataTypes.INT[])">
            <summary>
            Creates an instance of the SLIST with the specified <paramref name="items"/>
            </summary>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="P:MARC.Everest.DataTypes.SLIST`1.Origin">
            <summary>
            The origin of the first reading in the list. The physical
            quantity that a zero-digit in the sequence would represent
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.SLIST`1.Scale">
            <summary>
            Gets or sets the a ratio-scale quantity that is factored out of the digit
            sequence
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.GetEnumerator">
            <summary>
            Get the enumerator from the digits
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get the enumerator from the digits
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.SLIST`1.First">
            <summary>
            Gets the first item in the list
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.SLIST`1.Last">
            <summary>
            Gets the last item in the list
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.SubSequence(System.Int32,System.Int32)">
            <summary>
            Returns a sub-sequence from the <see cref="P:Digits"/>
            property
            </summary>
            <param name="start">The first item to retrieve</param>
            <param name="end">The last item in the list to retrieve</param>
            <returns>A new instance of <see cref="T:LIST"/> containing the results</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.SubSequence(System.Int32)">
            <summary>
            Returns a sub-sequence from the <see cref="P:Digits"/>
            property starting at <paramref name="start"/> and 
            ending with the length of the list
            </summary>
            <param name="start"></param>
            <returns>A new instance of <see cref="T:LIST"/> containing the results</returns>
        </member>
        <member name="P:MARC.Everest.DataTypes.SLIST`1.Items">
            <summary>
            Gets a list of all items in the SLIST
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.IncludesAll(MARC.Everest.DataTypes.Interfaces.IColl{MARC.Everest.DataTypes.INT})">
            <summary>
            Returns a new instance of <see cref="T:BL"/> indicating if
            this SLIST contains all the items from <paramref name="other"/>
            </summary>
            <param name="other">The other collection to detect inclusion</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.ExcludesAll(MARC.Everest.DataTypes.Interfaces.IColl{MARC.Everest.DataTypes.INT})">
            <summary>
            Returns  a new instance of <see cref="T:BL"/> indicating whether
            the SLIST excludes all the items from <paramref name="other"/>
            </summary>
            <param name="other">The other collection to detect exclusion</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.IndexOf(MARC.Everest.DataTypes.INT)">
            <summary>
            Return the index of <paramref name="item"/> within this SLIST
            </summary>
            <param name="item">The item for which a search should be conducted</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.Insert(System.Int32,MARC.Everest.DataTypes.INT)">
            <summary>
            Inserts <paramref name="item"/> at the specified <paramref name="index"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.RemoveAt(System.Int32)">
            <summary>
            Remove the object at <paramref name="index"/>
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.SLIST`1.Item(System.Int32)">
            <summary>
            Indexer property for the SLIST
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.Add(MARC.Everest.DataTypes.INT)">
            <summary>
            Adds <paramref name="item"/> to the SLIST
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.Clear">
            <summary>
            Clears the current instance of SLIST of all readings
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.Contains(MARC.Everest.DataTypes.INT)">
            <summary>
            Indicates whether this instance of SLIST contains <paramref name="item"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.CopyTo(MARC.Everest.DataTypes.INT[],System.Int32)">
            <summary>
            Copy the contents of this SLIST into an array of <see cref="T:INT"/>
            </summary>
            <param name="array">The target array of the copy operation</param>
            <param name="arrayIndex">The index to start the copy operation</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.SLIST`1.Count">
            <summary>
            Gets the number of readings in the SLIST
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.SLIST`1.IsReadOnly">
            <summary>
            Indicates whether this SLIST is read only
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.Remove(MARC.Everest.DataTypes.INT)">
            <summary>
            Removes <paramref name="item"/> from the SLIST instance
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.SLIST`1.IsEmpty">
            <summary>
            Returns true if the SLIST is empty
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.Equals(MARC.Everest.DataTypes.SLIST{`0})">
            <summary>
            Determine equality
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SLIST`1.Equals(System.Object)">
            <summary>
            Determine equality
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.SLIST`1.MARC#Everest#DataTypes#Interfaces#ISampledList#Origin">
            <summary>
            Gets or sets the origin of the slist
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.ST">
            <summary>
            The character string datatype stands for text data primarily intended for machine processing
            </summary>
            <example>Using the <see cref="T:MARC.Everest.DataTypes.ST"/> class
            <code lang="cs" title="ST datatype">
            <![CDATA[
            // String Hello with current language code 
            ST test = new ST();
            test.Value = "Hello!";
            // String hello! with current language code
            test = "Hello!";
            // String hello! in a different language
            test = new ST("Bonjour!", "fr-ca");
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.#ctor">
            <summary>
            Create a new instance of the <see cref="T:MARC.Everest.DataTypes.ST"/> type
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.#ctor(System.String)">
            <summary>
            Create a new instance of the <see cref="T:MARC.Everest.DataTypes.ST"/> type using <paramref name="data"/> as the initial contents
            </summary>
            <param name="data">The initial data</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.#ctor(System.String,System.String)">
            <summary>
            Create a new instance of the <see cref="T:MARC.Everest.DataTypes.ST"/> type using <paramref name="data"/> as the initial contents with 
            <paramref name="language"/>
            </summary>
            <param name="data">The intial data</param>
            <param name="language">The language the data is represented in</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.ST.Language">
            <summary>
            The human language of the content
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.ST.Translation">
            <summary>
            Alternative renditions of the same content translated into a different language
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.ST.Length">
            <summary>
            Gets the length of the string
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.Concat(MARC.Everest.DataTypes.ST)">
            <summary>
            Concatenate this string value with <paramref name="other"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.Substring(MARC.Everest.DataTypes.INT,MARC.Everest.DataTypes.INT)">
            <summary>
            Performs a substring on the <see cref="T:MARC.Everest.DataTypes.ST"/> as per HL7v3 datatypes rules
            </summary>
            <exception cref="T:ArgumentNullException">When either <paramref name="start"/> or <paramref name="end"/> are null or nullFlavored</exception>
            <exception cref="T:ArgumentOutOfRangeException">When <paramref name="start"/> is greater than <paramref name="end"/> or either <paramref name="end"/> or <paramref name="start"/> are
            beyond the length of the string</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.op_Addition(MARC.Everest.DataTypes.ST,MARC.Everest.DataTypes.ST)">
            <summary>
            Concatenation operator +
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.op_Implicit(MARC.Everest.DataTypes.ST)~System.String">
            <summary>
            Converts a <see cref="T:ST"/> to a <see cref="T:System.String"/> in a safe way
            </summary>
            <param name="o">The <see cref="T:MARC.Everest.DataTypes.ST"/> to convert</param>
            <returns>The converted string</returns>
            <remarks>The implicit cast operator will convert only if <see cref="T:MARC.Everest.DataTypes.ST"/> is not null. This differs from the explicit cast where 
            no exception is thrown</remarks>
            <exception cref="T:System.InvalidCastException">When the <see cref="T:MARC.Everest.DataTypes.ST"/> instance has a nullflavor</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.op_Implicit(MARC.Everest.DataTypes.ED)~MARC.Everest.DataTypes.ST">
            <summary>
            Casts a <see cref="T:MARC.Everest.DataTypes.Ed"/> into an <see cref="T:ST"/>
            </summary>
            <param name="o">The object to cast</param>
            <returns>The cast <see cref="T:MARC.Everest.DataTypes.ST"/></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.ToEDUtil(MARC.Everest.DataTypes.ST)">
            <summary>
            Convert a ST into an ED
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.op_Implicit(System.String)~MARC.Everest.DataTypes.ST">
            <summary>
            Converts a <see cref="T:System.String"/> to a <see cref="T:MARC.Everest.DataTypes.ST"/>
            </summary>
            <param name="o">String to convert</param>
            <returns>Converted <see cref="T:MARC.Everest.DataTypes.ST"/></returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.op_Explicit(MARC.Everest.DataTypes.ST)~MARC.Everest.DataTypes.REAL">
            <summary>
            Converts a <see cref="T:MARC.Everest.DataTypes.ST"/> to a <see cref="T:MARC.Everest.DataTypes.REAL"/>
            </summary>
            <param name="o">ST to convert</param>
            <returns>Converted REAL</returns>
            <remarks>The resulting REAL will have a nullflavor of NoInformation if the cast was not possible. 
            <para>The result will also have a precision set based on the location of the decimal point in the string representation</para></remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.op_Explicit(MARC.Everest.DataTypes.ST)~MARC.Everest.DataTypes.INT">
            <summary>
            Converts a <see cref="T:MARC.Everest.DataTypes.ST"/> to a <see cref="T:MARC.Everest.DataTypes.INT"/>
            </summary>
            <param name="o">ST to convert</param>
            <returns>Converted INT</returns>
            <remarks>The resulting INT will have a nullflavor of NoInformation if the cast was not possible. </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.Equals(MARC.Everest.DataTypes.ST)">
            <summary>
            Determines if this ST equals another ST
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.Validate">
            <summary>
            Validate the <see cref="T:MARC.Everest.DataTypes.ST"/> instance
            </summary>
            <remarks>
            An <see cref="T:MARC.Everest.DataTypes.ST"/> is considered valid if:
            <list type="bullet">
                <item><see cref="P:Value"/>Value is populated XOR <see cref="P:NullFlavor"/> is populated, and</item>
                <item>No value in the <see cref="P:Translation"/> contains a translation</item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.ValidateEx">
            <summary>
            Extended validation function that returns detected issues
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.IsValidNtFlavor(MARC.Everest.DataTypes.ST)">
            <summary>
            ST.NT (no translations) flavor
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.CreateNt(System.String)">
            <summary>
            Creates an instance of the <see cref="T:MARC.Everest.DataTypes.ST"/> type such that it is conformant to the NoTranslations 
            flavor
            </summary>
            <param name="value">The value of the string</param>
            <returns>The constructed <see cref="T:MARC.Everest.DataTypes.ST"/> conformant to the NT flavor</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.IsValidSimpleFlavor(MARC.Everest.DataTypes.ST)">
            <summary>
            ST.SIMPLE contains no language
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.CreateSimple(System.String)">
            <summary>
            Creates an instance of <see cref="T:MARC.Everest.DataTypes.ST"/> type that is conformant to the SIMPLE flavor
            </summary>
            <param name="value">The value of the <see cref="T:MARC.Everest.DataTypes.ST"/></param>
            <returns>An instance of <see cref="T:MARC.Everest.DataTypes.ST"/> conformant to the SIMPLE flavor</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.ST.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Semantic equals
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.SetOperator">
            <summary>
            A code specifying whether the set component is included (union) or excluded (difference) from the set, or other set operations with the current set component and the set as constructed from the representation stream up to the current point.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.SetOperator.H">
            <summary>
            Obsolete, Replaced with Hull
            </summary>
            <remarks><see cref="E:Hull"/></remarks>
        </member>
        <member name="F:MARC.Everest.DataTypes.SetOperator.Hull">
            <summary>
            Form the convex hull with the value.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.SetOperator.Inclusive">
            <summary>
            Include the value in the value set (union).
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.SetOperator.Exclusive">
            <summary>
            Exclude the value from the set (difference).
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.SetOperator.A">
            <summary>
            Obsolete, replaced with Intersect
            </summary>
            <remarks><see cref="E:Intersect"/></remarks>
        </member>
        <member name="F:MARC.Everest.DataTypes.SetOperator.Intersect">
            <summary>
            Intersect: Form the intersection with the value.
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.SetOperator.P">
            <summary>
            Obsolete, replaced with PeriodicHull
            </summary>
            <remarks><see cref="E:PeriodicHull"/></remarks>
        </member>
        <member name="F:MARC.Everest.DataTypes.SetOperator.PeriodicHull">
            <summary>
            Form the periodic hull with the value.
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.SXCM`1">
            <summary>
            Set component: An individual component belonging to a set. See <see cref="T:MARC.Everest.DataTypes.IVL"/> for an example of a specific type of set.
            </summary>
            <remarks>
            <para>
            In R1 SXCM is the base from which all set components are derived, in R2 data types this is QSET.  To keep backwards compatibility, Everest maps
            the R2 concept of QSET to an SXCM.
            </para>
            </remarks>
            <seealso cref="T:MARC.Everest.DataTypes.SET"/>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXCM`1.#ctor">
            <summary>
            Create a new instance of SXCM
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXCM`1.#ctor(`0)">
            <summary>
            Create a new instance of SXCM with the specified value
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.SXCM`1.Operator">
            <summary>
            Gets or sets the identifier that dictates how the set component is included as part of the set
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXCM`1.ToString">
            <summary>
            Represent this object as a string
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXCM`1.Equals(MARC.Everest.DataTypes.SXCM{`0})">
            <summary>
            Determines if this SXCM of T equals another SXCM of T
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXCM`1.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXCM`1.TranslateToQSETComponent">
            <summary>
            Translate to QSET equivalent
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXCM`1.ValidateEx">
            <summary>
            Performs validation on the SXCM set
            </summary>
            <remarks>This function really checks that value isn't set and provides a warning if it does</remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXCM`1.ToValueType(MARC.Everest.DataTypes.SXCM{`0})">
            <summary>
            Gets just the value type from the SXCM
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.SXPR`1">
            <summary>
            A set component that is itself made up of set components that are evaluated as one value
            </summary>
            <remarks>
            <para>The set expression data type is a concept defined in Data Types R1. In order to maintain compatibility
            between data types versions, R2 concepts based on <see cref="T:QSET{T}"/> are permitted for use in an SXPR and
            will be represented appropriately when formatting using an R1 formatter</para>
            <para>
            However, because of the nature of SXPR and <see cref="T:SXCM{T}"/> R2 formatters will not render SXPR or SXCM 
            components appropriately and will ignore their content (throwing warnings). This is important because although
            it is possible to represent R2's QSET constructs using SXPR, it is very difficult to represent R1 SXPR concepts
            as R2 QSETs.
            </para>
            <para>
            The rules for mapping concepts based on <see cref="T:QSET{T}"/> are as follows:
            </para>
            <list type="table">
                <listheader><term>R2 Type</term>
                <description>R1 Representation</description></listheader>
                <item>
                    <term>QSI</term>    
                    <description>Mapped to SXPR with all components operators set to Intersect</description>
                </item>
                <item>
                    <term>QSU</term>    
                    <description>Mapped to SXPR with all components operators set to Inclusive</description>
                </item>
                <item>
                    <term>QSD</term>
                    <description>Mapped to SXPR with all components operators set to Exclusive. May only contain two components</description>
                </item>
                <item>
                    <term>QSS</term>    
                    <description>Mapped to SXPR with all components operators set to Convex Hull</description>
                </item>
                <item>
                    <term>QSP</term>
                    <description>Mapped to SXPR with all components operators set to Periodic Hull. May only contain two components</description>
                </item>
            </list>
            <para>
            Of course, these rules mean that if the developer creates an SXPR using <see cref="T:QSET{T}"/> classes and parses the
            instance back in, the resulting structure will be an equivalent to the original structure (substituting SXCM and SXPR for QSET, QSI, QSD, etc...)
            </para>
            </remarks>
            <seealso cref="T:MARC.Everest.DataTypes.QSET{T}"/>
            <seealso cref="T:MARC.Everest.DataTypes.SET{T}"/>
        </member>
        <member name="P:MARC.Everest.DataTypes.SXPR`1.Value">
            <summary>
            Overriden value property
            </summary>
            <remarks>We never want the developer to see the SXCM value as it is not permitted in the SXPR context</remarks>
        </member>
        <member name="P:MARC.Everest.DataTypes.SXPR`1.Terms">
            <summary>
            Represents the components of this parenthetic set expression
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.#ctor">
            <summary>
            Creates a new instance of the set Expression
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.#ctor(System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.SXCM{`0}})">
            <summary>
            Creates a set expression with an initial list of terms specified by <paramref name="terms"/>
            </summary>
            <param name="terms">An initial set of terms that this SXPR contains</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.CreateSXPR(MARC.Everest.DataTypes.SXCM{`0}[])">
            <summary>
            Constructs a new instance of the SXPR data type with the specified <paramref name="terms"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.Validate">
            <summary>
            Validate this data structure
            </summary>
            <remarks>
            An instance of SXPR is considered valid when it carries no null flavor and contains
            more than one term, or carries and null flavor and has no terms
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.ValidateEx">
            <summary>
            Extended validation function that returns detected issues
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.SXPR`1.MARC#Everest#DataTypes#Interfaces#IListContainer#ContainedList">
            <summary>
            Get the contained list as a generic list of IGraphable
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.IndexOf(MARC.Everest.DataTypes.SXCM{`0})">
            <summary>
            Index of an item in the component collection
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.Insert(System.Int32,MARC.Everest.DataTypes.SXCM{`0})">
            <summary>
            Insert an item
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.RemoveAt(System.Int32)">
            <summary>
            Remove at a particular index
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.SXPR`1.Item(System.Int32)">
            <summary>
            Property indexer
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.Add(MARC.Everest.DataTypes.SXCM{`0})">
            <summary>
            Add an item to the component collection
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.Clear">
            <summary>
            Clear this set expression
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.Contains(MARC.Everest.DataTypes.SXCM{`0})">
            <summary>
            Returns if the component collection contains the specified item
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.CopyTo(MARC.Everest.DataTypes.SXCM{`0}[],System.Int32)">
            <summary>
            Copy to an array
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.SXPR`1.Count">
            <summary>
            Get the count of items in the set expression
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.SXPR`1.IsReadOnly">
            <summary>
            Returns true if the collection is read only
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.Remove(MARC.Everest.DataTypes.SXCM{`0})">
            <summary>
            Remove an item from the collection
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.GetEnumerator">
            <summary>
            Get an enumerator for the item
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get an enumerator for the set
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.Equals(MARC.Everest.DataTypes.SXPR{`0})">
            <summary>
            Determines if this SXPR of T is equal to another SXPR of T
            </summary>
            <remarks>
            This equality method checks to ensure that not only are the core data elements of the 
            two instanes the same, but each of the <see cref="P:Component"/> elements are equal.
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.TranslateToQSET">
            <summary>
            Translate to a QSET
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.SXPR`1.TranslateToQSETInternal(MARC.Everest.DataTypes.SetOperator,System.Collections.Generic.List{MARC.Everest.DataTypes.SXCM{`0}},MARC.Everest.DataTypes.QSET{`0})">
            <summary>
            Translate to a QSET data internally
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.TEL">
             <summary>
             A telephone number, voice, fax, email address, or other locator used for a resouce mediated by 
             telecommunications equipment. 
             </summary>
             <example>
             <code lang="cs" title="TEL flavors">
             <![CDATA[
                    string url = "mailto:b_vanarragon@hotmail.com"; // valid e-mail
                    string url2 = "http://www.tsn.ca"; // valid web address
                    string url3 = "tel:+1905-389-6509"; // valid phone number
            
                    TEL urlTEL = url; //implicit conversion from string to TEL
                    TEL urlTEL2 = url2;
                    TEL urlTEL3 = url3;
            
                    Console.WriteLine(TEL.EMail(urlTEL)); //should return false, urlTEL is not an email
                    Console.WriteLine(TEL.Phone(urlTEL3)); //should return false, urlTEL is not a phone number
                    Console.WriteLine(TEL.Url(urlTEL2)); //should return true, is a valid URL
                    Console.ReadKey();
            ]]>
            </code>
            </example>
            <remarks>
            The address is specified as a universal resource locator qualified
             by time specification and use codes that help in deciding which address to use for a given time 
             and purpose
             </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.#ctor">
            <summary>
            Creates a new instance of the the telecommunications address class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.#ctor(System.String)">
            <summary>
            Creates a new telecommunications address with the specified <paramref name="value"/>
            </summary>
            <param name="value">The initial value of the telecommunications addressadhere to RFC2396 <a href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a></param>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.#ctor(System.String,MARC.Everest.DataTypes.Interfaces.TelecommunicationAddressUse)">
            <summary>
            Creates a new telecommunications address with the specified <paramref name="value"/> and
            <paramref name="use"/>
            </summary>
            <param name="value">The initial value of the telecommunications addressadhere to RFC2396 <a href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a></param>
            <param name="use">A value describing the conditions under which the address can be used</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.#ctor(System.String,System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.CS{MARC.Everest.DataTypes.Interfaces.TelecommunicationAddressUse}})">
            <summary>
            Creates a new telecommunications address with the specified <paramref name="value"/> and
            <paramref name="use"/> set.
            </summary>
            <param name="value">The initial value of the telecommunications address, adhere to RFC2396 <a href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a></param>
            <param name="use">A set of unique values describing the use of the telecommunications address</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.#ctor(System.Uri)">
            <summary>
            Creates a new telecommunications address with the specified <paramref name="value"/> 
            </summary>
            <param name="value">The initial value of the telecommunications address</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.#ctor(System.Uri,MARC.Everest.DataTypes.Interfaces.TelecommunicationAddressUse)">
            <summary>
            Creates a new telecommunications address with the specified <paramref name="value"/> and
            <paramref name="use"/> set.
            </summary>
            <param name="value">The initial value of the telecommunications address</param>
            <param name="use">A set of unique values describing the use of the telecommunications address</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.#ctor(System.Uri,System.Collections.Generic.IEnumerable{MARC.Everest.DataTypes.CS{MARC.Everest.DataTypes.Interfaces.TelecommunicationAddressUse}})">
            <summary>
            Creates a new telecommunications address with the specified <paramref name="value"/> and
            <paramref name="use"/> set.
            </summary>
            <param name="value">The initial value of the telecommunications address</param>
            <param name="use">A set of unique values describing the use of the telecommunications address</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.TEL.Value">
            <summary>
            Identifies the value of the telecommunications address. Note that valid telecommunications
            address values must adhere to RFC2396 <a href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a>
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.TEL.Use">
            <summary>
            One or more codes advising system or use which telecommunication address in a set of like addresses
            should be used and for what purpose
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.TEL.Capabilities">
            <summary>
            Advises processing systems of the capabilities of a particular 
            telecommunications address.
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.TEL.UseablePeriod">
            <summary>
            Specifies the periods of time during which the telecommunication address can be used
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.IsValidUrlFlavor(MARC.Everest.DataTypes.TEL)">
            <summary>
            TEL.URL Validator
            </summary>
            <param name="tel">The TEL structure to validate</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.IsValidUriFlavor(MARC.Everest.DataTypes.TEL)">
            <summary>
            Link to URL
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.IsValidPersonFlavor(MARC.Everest.DataTypes.TEL)">
            <summary>
            TEL.Person Validator
            </summary>
            <param name="tel">The TEL structure to validate</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.IsValidPhoneFlavor(MARC.Everest.DataTypes.TEL)">
            <summary>
            TEL.Phone validator
            </summary>
            <param name="tel">The tel structure to validate</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.IsValidEMailFlavor(MARC.Everest.DataTypes.TEL)">
            <summary>
            TEL.Email validator
            </summary>
            <param name="tel">The tel structure to validate</param>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.op_Implicit(MARC.Everest.DataTypes.TEL)~System.String">
            <summary>
            Converts a <see cref="T:MARC.Everest.DataTypes.TEL"/> to a <see cref="T:System.String"/>
            </summary>
            <param name="o">TEL to convert</param>
            <returns>Converted String</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.op_Explicit(MARC.Everest.DataTypes.TEL)~System.Uri">
            <summary>
            Converts a <see cref="T:TEL"/> to a <see cref="T:System.String"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.op_Implicit(System.Uri)~MARC.Everest.DataTypes.TEL">
            <summary>
            Converts a <see cref="T:System.Uri"/> to a <see cref="T:TEL"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.op_Implicit(System.String)~MARC.Everest.DataTypes.TEL">
            <summary>
            Converets a <see cref="T:System.String"/> to a <see cref="T:MARC.Everest.DataTypes.TEL"/>
            </summary>
            <param name="o">String to convert</param>
            <returns>Converted TEL</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.Equals(MARC.Everest.DataTypes.TEL)">
            <summary>
            Determeins if this TEL is equal to another TEL
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TEL.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Semantically equal?
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.TEL.MARC#Everest#DataTypes#Interfaces#ITelecommunicationAddress#UseablePeriod">
            <summary>
            Gets the usable period as an ISetComponent
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.TN">
            <summary>
            Trivial Name: A restriction of <see cref="T:MARC.Everest.DataTypes.EN"/>(Entity Name) that is a string used for simple names.
            </summary>
            <example>
            <code>
            <![CDATA[
            // Name(Brother Justin Crowe) used for religious reasons
            TN myTN = new TN(EntityNameUse.Religious, "Brother Justin Crowe");
            ]]>
            </code>
            </example>
        </member>
        <member name="M:MARC.Everest.DataTypes.TN.#ctor">
            <summary>
            Create a new instance of the TN class
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TN.#ctor(System.String)">
            <summary>
            Create a new instance of the trivial name class using the value specified
            </summary>
            <param name="s">The value of the name</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.TN.Use">
            <summary>
            Use is not permitted for TN
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TN.op_Implicit(System.String)~MARC.Everest.DataTypes.TN">
            <summary>
            Convert a string to a TN
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TN.Parse(MARC.Everest.DataTypes.EN)">
            <summary>
            Parse the data from an EN into a TN
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TN.Validate">
            <summary>
            Validate this TN
            </summary>
            <remarks>
            A Trivial name is valid if
            <list type="bullet">
                <item>Null Flavor is specified XOR,</item>
                <item>There are exactly one name parts, AND</item>
                <item>The only name part has no part type</item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.TN.ValidateEx">
            <summary>
            Validate this TN
            </summary>
            <remarks>
            A Trivial name is valid if
            <list type="bullet">
                <item>Null Flavor is specified XOR,</item>
                <item>There are exactly one name parts, AND</item>
                <item>The only name part has no part type</item>
            </list>
            </remarks>
            <returns>A collection of result details explaining validation issues</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.TN.Equals(MARC.Everest.DataTypes.TN)">
            <summary>
            Determines if the current TN matches another TN
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TN.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.TS">
            <summary>
            A quantity specifying a point on the axis of natural time. 
            </summary>  
            <remarks>A point in time is most often represented 
            as a calendar expression.
            <para>The TS class also supports arithmetic date operations with other
            TS as well as <see cref="T:MARC.Everest.DataTypes.PQ"/>.</para>
            </remarks>
            <example>
            <code lang="cs" title="TS flavors">
            <![CDATA[ 
                   // TS Sample, Time Zone is EDT
                  TS test = DateTime.Parse("March 1, 2009 12:00:00 AM");
                   Console.WriteLine(test.ToString()); // output : 20090301000000.000-0500  
                   test.Flavor = "DATETIME";
                   Console.WriteLine(test.ToString()); // output : 20090301000000-0500
                   test.Flavor = "DATE";
                   Console.WriteLine(test.ToString()); // output : 20090301
                   test.DateValuePrecision = DatePrecision.Year;
                   Console.WriteLine(test.ToString()); // output : 2009
            ]]>
            </code>
            <code lang="cs" title="Date Arithmetic">
               <![CDATA[
                
            // Two dates
            TS now = DateTime.Now, 
                endOfWorld = DateTime.Parse("12-21-2012");
            
            // Difference between dates
            Console.WriteLine("{0} until {1}",  endOfWorld - now, endOfWorld);
            // Sample Output: 44.30293848594 Ms until 20121221000000.000-0500
            // Adding time to a date
            Console.WriteLine("1 week from now: {0}", now + new PQ(1, "wk"));
            // Sample Output: 1 week from now: 20110801153525.358-0500
               ]]>
            </code>
            </example>
        </member>
        <member name="F:MARC.Everest.DataTypes.TS.m_precisionFormats">
            <summary>
            Precision formats
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.#ctor">
            <summary>
            Create a new instance of the timestamp
            </summary>
            DateTime.Now.ToString("yyyyMMddHHmmss.ffffzzzz").Replace(":", "")
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.#ctor(System.DateTime)">
            <summary>
            Create a new instance of TS with the specified value
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.#ctor(System.DateTime,MARC.Everest.DataTypes.DatePrecision)">
            <summary>
            Create a new instance of TS with the specified datetime value and the precision specified
            </summary>
            <param name="value">The value of the timestamp</param>
            <param name="precision">The precision of the timestamp</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.TS.Value">
            <summary>
            Gets or sets the string value of this date/time value
            </summary>
            <remarks>
            <para>The output of this property is dependent on the setting of the 
            DateValuePrecision property. If the DateValuePrecision property has 
            not value when this method is called, then the date is output in
            DatePrecision.Full and DateValuePrecision is assigned the value
            of Full</para>
            </remarks>
            <exception cref="T:System.FormatException">When the format of the date string is not in a recognizable form</exception>
        </member>
        <member name="P:MARC.Everest.DataTypes.TS.DateValuePrecision">
            <summary>
            Gets the precision of the DateValue. This is the precision that a date-time can be trusted to. 
            <para>
            For example, a date time of January 1, 2009 with a precision of Month means that the dateTime is
            only precise to the month (January 2009). 
            </para>
            </summary>
            <example>
            Date value precision modifies the precision of the <see cref="P:MARC.Everest.DataTypes.TS.DateValue"/> property
            <code lang="cs" title="Date Value Precision Example">
            <![CDATA[
            TS sample = DateTime.Now; // Date value is at full precision
            sample.DateValuePrecision = DatePrecision.Year; 
            sample.ToString(); // Output is "2009"
            ]]>
            </code>
            </example>
        </member>
        <member name="P:MARC.Everest.DataTypes.TS.IsInvalidDate">
            <summary>
            Returns true if the date contained in "Value" is invalid and was not translated to DateValue
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.TS.Flavor">
            <summary>
            JF: Fixes issue with setting flavor then precision
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.TS.DateValue">
            <summary>
            Get or set the string as a function of the date value
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.ToString">
            <summary>
            Represent this TS as a string
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.op_Explicit(System.String)~MARC.Everest.DataTypes.TS">
            <summary>
            Convert a string to a datetime
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.op_Explicit(MARC.Everest.DataTypes.ST)~MARC.Everest.DataTypes.TS">
            <summary>
            Convert an <see cref="T:MARC.Everest.DataTypes.ST"/> to a datetime
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.op_Explicit(MARC.Everest.DataTypes.TS)~System.DateTime">
            <summary>
            Cast this TS to a datetime
            </summary>
            <exception cref="T:System.InvalidCastException">When the instance of TS is null or nullFlavored</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.op_Implicit(MARC.Everest.DataTypes.TS)~System.Nullable{System.DateTime}">
            <summary>
            Cast this TS to a datetime
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.op_Implicit(System.DateTime)~MARC.Everest.DataTypes.TS">
            <summary>
            Cast a DateTime to a TS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.IsValidDateFlavor(MARC.Everest.DataTypes.TS)">
            <summary>
            Flavor handler for TS.Date
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.IsValidDateTimeFlavor(MARC.Everest.DataTypes.TS)">
            <summary>
            Flavor handler for TS.DATETIME
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.IsValidFullDateTimeFlavor(MARC.Everest.DataTypes.TS)">
            <summary>
            Flavor handler for FullDateTime
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.IsValidDateTimeMinuteFlavor(MARC.Everest.DataTypes.TS)">
            <summary>
            Flavor handler for TS.FULLDATETIME.MIN
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.IsValidInstantFlavor(MARC.Everest.DataTypes.TS)">
            <summary>
            A flavor handler for Instant
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.IsValidFullDateFlavor(MARC.Everest.DataTypes.TS)">
            <summary>
            Flavor handler for FullDate
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.op_Addition(MARC.Everest.DataTypes.TS,MARC.Everest.DataTypes.PQ)">
            <summary>
            Adds <paramref name="b"/> to <paramref name="a"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.op_Subtraction(MARC.Everest.DataTypes.TS,MARC.Everest.DataTypes.PQ)">
            <summary>
            Subtracts <paramref name="b"/> from <paramref name="a"/>
            </summary>
            <exception cref="T:System.InvalidOperationException">If the <param name="a"/> value is an invalidly parsed date</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.op_Subtraction(MARC.Everest.DataTypes.TS,MARC.Everest.DataTypes.TS)">
            <summary>
            Subtracts <paramref name="b"/> from <paramref name="a"/>
            </summary>
            <remarks>The result of this operation is always returned in seconds</remarks>
            <exception cref="T:System.InvalidOperationException">If the <paramref name="a"/> or <paramref name="b"/> value is an invalidly parsed date</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.ToIVL">
            <summary>
            Convert this timestamp (with precision) to an interval
            </summary>
            <returns>The converted interval</returns>
            <exception cref="T:System.InvalidOperationException">If the date instance is an invalidly parsed date</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.Equals(MARC.Everest.DataTypes.TS)">
            <summary>
            Determines if this TS is equal to another TS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.CompareTo(MARC.Everest.DataTypes.TS)">
            <summary>
            Compares this TS instance to another
            </summary>
            <exception cref="T:System.InvalidOperationException">If this date instance or <paramref name="other"/> is an invalidly parsed date</exception>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.Translate(MARC.Everest.DataTypes.PQ)">
            <summary>
            Translates this date by the amount specified in
            <paramref name="translation"/>
            </summary>
            <param name="translation">The amount to translate the date by</param>
            <remarks>Results in a new TS instance that contains the translation</remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.Distance(MARC.Everest.DataTypes.TS)">
            <summary>
            Calculate the distance between this instance and another instance of
            TS
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.Validate">
            <summary>
            Validates that this TS meets the basic validation criteria
            </summary>
            <remarks>
            <para>Basic validation criteria is considered:</para>
            <list type="bullet">
                <item><description>If <see cref="P:NullFlavor"/> is not null, then <see cref="P:DateValue"/> and <see cref="P:UncertainRange"/> cannot be set</description></item>
                <item><description>If <see cref="P:DateValue"/> or <see cref="P:UncertainRange"/> are populated, then <see cref="P:NullFlavor"/> cannot be set</description></item>
                <item><description>Both <see cref="P:DateValue"/> and <see cref="P:UncertainRange"/> cannot be set at the same time</description></item>
                <item><description>Any uncertainty (<see cref="P:Uncertainty"/>, or <see cref="P:UncertainRange"/>) must contain valid <see cref="T:PQ"/>.TIME or <see cref="T:IVL`1"/>of PQ.TIME</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.ValidateEx">
            <summary>
            Validation with result details
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determines if this instance of TS is semantically equal to <paramref name="other"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.ToDouble">
            <summary>
            Represent the timestamp ticks as a double
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.NextValue">
            <summary>
            Gets the next value of TS given this TS' precision
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.PreviousValue">
            <summary>
            Gets the previous value of TS given this TS' precision
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.TranslateDateInternal(System.Int32)">
            <summary>
            Translate a date based on the value of <see cref="P:DateValuePrecision"/>
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.TS.GetLeapDays(MARC.Everest.DataTypes.TS,MARC.Everest.DataTypes.TS)">
            <summary>
            Gets the number of days (total) between <paramref name="a"/>
            and <paramref name="b"/>
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.UpdateMode">
            <summary>
            An enumeration of the allowed update modes. See Members for modes.
            </summary>
            <example>
            <code title="Using update mode to dictate how a name should be updated" lang="cs">
            <![CDATA[
                EN newName = new EN(
                    EntityNameUse.Legal, new ENXP[] { 
                    new ENXP("James", EntityNamePartType.Given), 
                        new ENXP("Tiberius", EntityNamePartType.Given), 
                        new ENXP("Kirk", EntityNamePartType.Family) });
                
                // When the name is encountered, the receiving name will add the name
                // if not already on file, or will replace an existing name
                newName.UpdateMode = UpdateMode.AddOrReplace;
                
            ]]>
            </code>
            </example>
        </member>
        <member name="F:MARC.Everest.DataTypes.UpdateMode.Add">
            <summary>
            The item was (or is to be) added, having not been present before
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.UpdateMode.Remove">
            <summary>
            The item was(or is to be) removed
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.UpdateMode.Replace">
            <summary>
            The item existed previously and has been (or is to be) revised
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.UpdateMode.AddOrReplace">
            <summary>
            The item was (or is to be) either added or replaced
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.UpdateMode.NoChange">
            <summary>
            There was (or is to be) no change to the item
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.UpdateMode.Unknown">
            <summary>
            It is not specified whether or what kind of change has occurred to the item
            </summary>
        </member>
        <member name="F:MARC.Everest.DataTypes.UpdateMode.Key">
            <summary>
            The item is part of the identifying information for the object that contains it
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.URG`1">
             <summary>
             A union of <see cref="T:MARC.Everest.DataTypes.UVP{T}"/>(Probability) and <see cref="T:MARC.Everest.DataTypes.IVL{T}"/>(Interval). 
             </summary>
             <example>
             <code title="Blood Sugar Reading" lang="cs">
             <![CDATA[
                    // blood reading
                    URG<PQ> test = new URG<PQ>();
            
                    // blood sugar level (2 readings)
                    test.Low = new PQ(5, "mmol/L");
                    test.High = new PQ(5.2, "mmol/L");
                    test.Probability = 0.95; // The glucose meter has a 95% confidence interval  
             ]]>
             </code>
             </example>
             <remarks>It is being included for compatibility with R1 datatypes.</remarks>
             <seealso cref="T:MARC.Everest.DataTypes.UVP{T}"/>
             <seealso cref="T:MARC.Everest.DataTypes.IVL{T}"/>
        </member>
        <member name="P:MARC.Everest.DataTypes.URG`1.OriginalText">
            <summary>
            Text indicating where this interval was derived
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.URG`1.Low">
            <summary>
            This is the low limit. If the low limit is not known a null flavor should be specified
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.URG`1.LowClosed">
            <summary>
            Specifies wheter low is included in the IVL or excluded from the IVL
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.URG`1.High">
            <summary>
            The high limit. If the high limit is not known, a null flavor should be specified
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.URG`1.HighClosed">
            <summary>
            Specifies whether high is inlcluded in the IVL or excluded in the IVL
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.URG`1.Width">
            <summary>
            The difference between the high and low bondary. Width is used when the size of the interval is known
            but the actual start and end points are not known. 
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.URG`1.Validate">
            <summary>
            Validates this instance of URG
            </summary>
            <returns>True if the instance is valid</returns>
        </member>
        <member name="M:MARC.Everest.DataTypes.URG`1.ValidateEx">
            <summary>
            Validates the instance of URG and returns the detected issues
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.URG`1.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Determine semantic equality
            </summary>
            <remarks>Since this data-type is an adaptation of an R1 data type with no semantic equality statements, 
            the value of this method will be that of the IVL type combined with the UVP type meaning that two 
            URG instances are semantically equal when their <see cref="P:Low"/> and <see cref="P:High"/> bounds
            are specified and equal and their <see cref="P:Probability"/> properties are equal</remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.URG`1.Equals(MARC.Everest.DataTypes.URG{`0})">
            <summary>
            Determines if this URG of T is equal to another URG of T
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.URG`1.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.UVP`1">
            <summary>
            A generic datatype extension used to specify a proabability(percentage, from 0 to 1) expressing the information
            </summary>
            <example>
            <code title="Blood Alcohol test" lang="cs">
            <![CDATA[
            
                  UVP<Decimal> DUItest = new UVP<Decimal>();
                  // The item was(or is to be) removed
                  DUItest.UpdateMode = UpdateMode.Remove;
                  DUItest.Value = 0.08M; // This is what the police are testing for (legal limit)
                   
                  // Probability that roadside breathalizer is accurate
                  DUItest.Probability = 0.75;
                   
                  // Probability that breathalizer is accurate in the police station
                  // DUItest.Probability = 0.90;
            ]]>
            </code>`
            </example>
            <seealso cref="T:MARC.Everest.DataTypes.PDV{T}"/>
        </member>
        <member name="M:MARC.Everest.DataTypes.UVP`1.#ctor">
            <summary>
            Create a new instance of UVP
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.UVP`1.#ctor(`0,System.Decimal)">
            <summary>
            Create a new instance of UVP
            </summary>
            <param name="value">The value of the UVP</param>
            <param name="probability">The probability assigned to the value. Between 0 and 1</param>
        </member>
        <member name="P:MARC.Everest.DataTypes.UVP`1.Value">
            <summary>
            Gets or sets the value of the probability
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.UVP`1.Probability">
            <summary>
            The probability assigned to the value a decimal between 0 and 1
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.UVP`1.Validate">
            <summary>
            Validate the type
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.UVP`1.ValidateEx">
            <summary>
            Validate the UVP instance returning any detected issues
            </summary>
            <remarks>
            An instance of UVP is considered valid when:
            <list type="number">
                <item><description>When the <see cref="P:NullFlavor"/> property has a value then neither <see cref="P:Value"/> nor <see cref="P:Probability"/> carry a a value, and</description></item>
                <item><description>When the <see cref="P:NullFlavor"/> property has no value, then the <see cref="P:Value"/> and <see cref="P:Probability"/> properties must carry a value, and </description></item>
                <item><description>If populated, <see cref="P:Probability"/> must be carry a value between 0 and 1</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.UVP`1.Equals(MARC.Everest.DataTypes.UVP{`0})">
            <summary>
            Determines if this UVP of T equals another UVP of T
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.UVP`1.Equals(System.Object)">
            <summary>
            Override of base equals
            </summary>
        </member>
        <member name="M:MARC.Everest.DataTypes.UVP`1.SemanticEquals(MARC.Everest.DataTypes.Interfaces.IAny)">
            <summary>
            Override of semantic equality between this and <paramref name="other"/>
            </summary>
            <remarks>
            Two non-null, not null-flavored instances of UVP are considered semantically equal with their <see cref="P:Probability"/>
            and <see cref="P:Value"/> properties are equal.
            </remarks>
        </member>
        <member name="M:MARC.Everest.DataTypes.UVP`1.ToString">
            <summary>
            Represent this UVP as a string
            </summary>
        </member>
        <member name="P:MARC.Everest.DataTypes.UVP`1.MARC#Everest#DataTypes#Interfaces#IPrimitiveDataValue#Value">
            <summary>
            Generic Value implementation
            </summary>
        </member>
        <member name="T:MARC.Everest.DataTypes.ValidationMessages">
            <summary>
            Validation messages for common errors that occur in the framework
            </summary>
        </member>
        <member name="T:MARC.Everest.Design.ChoiceTypeConverter">
            <summary>
            Extends the expandable object converter so that choices can be entered
            </summary>
        </member>
        <member name="M:MARC.Everest.Design.ChoiceTypeConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            
            </summary>
            <param name="context"></param>
            <param name="sourceType"></param>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.Design.ChoiceTypeConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            
            </summary>
            <param name="context"></param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="T:MARC.Everest.Design.DataTypeConverter">
            <summary>
            Summary of DataTypeConverter
            </summary>
        </member>
        <member name="M:MARC.Everest.Design.DataTypeConverter.GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext)">
            <summary>
            
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.Design.DataTypeConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            
            </summary>
            <param name="context"></param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.Design.DataTypeConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            
            </summary>
            <param name="context"></param>
            <param name="sourceType"></param>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.Design.DataTypeConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            
            </summary>
            <param name="context"></param>
            <param name="culture"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.Design.DataTypeConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            
            </summary>
            <param name="context"></param>
            <param name="culture"></param>
            <param name="value"></param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.Design.DataTypeConverter.GetStandardValuesExclusive(System.ComponentModel.ITypeDescriptorContext)">
            <summary>
            
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.Design.DataTypeConverter.GetStandardValues(System.ComponentModel.ITypeDescriptorContext)">
            <summary>
            
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:MARC.Everest.Design.NamespaceDoc">
            <summary>
            This namespace contains designer classes 
            </summary>
            <remarks>
            <para>The classes within this namespace are used by RMIM classes
            and data types classes within a PropertyGrid</para>
            </remarks>
        </member>
        <member name="T:MARC.Everest.Design.NewInstanceTypeEditor">
            <summary>
            Allows developers to use a designer to create new instances of this type
            </summary>
        </member>
        <member name="M:MARC.Everest.Design.NewInstanceTypeEditor.GetEditStyle(System.ComponentModel.ITypeDescriptorContext)">
            <summary>
            
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:MARC.Everest.Design.NewInstanceTypeEditor.CreateTypeReference">
            <summary>
            Allows us to keep a reference to types in the drop down that is displayed for this editor
            </summary>
        </member>
        <member name="P:MARC.Everest.Design.NewInstanceTypeEditor.CreateTypeReference.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:MARC.Everest.Design.NewInstanceTypeEditor.CreateTypeReference.Type">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Design.NewInstanceTypeEditor.CreateTypeReference.#ctor(System.String,System.Type)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="t"></param>
        </member>
        <member name="M:MARC.Everest.Design.NewInstanceTypeEditor.CreateTypeReference.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.Design.NewInstanceTypeEditor.CreateControl(System.Type,System.Object[],System.Object)">
            <summary>
            Create a listbox. Since we don't know under what conditions the API source will be loading, 
            we can't include a direct reference to System.Windows.Forms.
            </summary>
        </member>
        <member name="M:MARC.Everest.Design.NewInstanceTypeEditor.EditValue(System.ComponentModel.ITypeDescriptorContext,System.IServiceProvider,System.Object)">
            <summary>
            
            </summary>
            <param name="context"></param>
            <param name="provider"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:MARC.Everest.EverestFrameworkContext">
            <summary>
            Everest Framework context
            </summary>
        </member>
        <member name="P:MARC.Everest.EverestFrameworkContext.CurrentCulture">
            <summary>
            Gets or sets the culture that Everest uses for formatting
            </summary>
            <remarks>
            This method controls the current culture used for the display of data-types in the ToString method
            </remarks>
        </member>
        <member name="P:MARC.Everest.EverestFrameworkContext.FrameworkVersion">
            <summary>
            Gets the framework version (rather than the assembly version)
            </summary>
        </member>
        <member name="M:MARC.Everest.EverestFrameworkContext.#cctor">
            <summary>
            Framework context ctor
            </summary>
        </member>
        <member name="T:MARC.Everest.Exceptions.ConnectorException">
            <summary>
            Excaeptions raised by a connector
            </summary>
            <remarks>
            <para>
            The ConnectorException is thrown whenever an exception related to the sending of an instance to an
            endpoint fails due to an exceptional circumstance.
            </para>
            </remarks>
        </member>
        <member name="T:MARC.Everest.Exceptions.ConnectorException.ReasonType">
            <summary>
            Reason why the exception is being thrown
            </summary>
        </member>
        <member name="F:MARC.Everest.Exceptions.ConnectorException.ReasonType.NotOpen">
            <summary>
            Occurs when the connector's "Open" method has not been called prior to executing
            the action
            </summary>
        </member>
        <member name="F:MARC.Everest.Exceptions.ConnectorException.ReasonType.InvalidUri">
            <summary>
            The connector could not send or receive data as the URI of the endpoint to receive on 
            is invalid
            </summary>
        </member>
        <member name="F:MARC.Everest.Exceptions.ConnectorException.ReasonType.MessageError">
            <summary>
            The connector could not send or receive data as there was an error with the message. This usually
            occurs when a soap fault is thrown
            </summary>
        </member>
        <member name="F:MARC.Everest.Exceptions.ConnectorException.ReasonType.NullFormatter">
            <summary>
            The connector cannot format the message because no formatter has been assigned
            </summary>
        </member>
        <member name="F:MARC.Everest.Exceptions.ConnectorException.ReasonType.NullConnectionString">
            <summary>
            The connector cannot be opened because the connection string is null
            </summary>
        </member>
        <member name="F:MARC.Everest.Exceptions.ConnectorException.MSG_INVALID_STATE">
            <summary>
            Invalid state message
            </summary>
        </member>
        <member name="F:MARC.Everest.Exceptions.ConnectorException.MSG_NULL_FORMATTER">
            <summary>
            Formatter is null
            </summary>
        </member>
        <member name="F:MARC.Everest.Exceptions.ConnectorException.MSG_NULL_CONNECTION_STRING">
            <summary>
            Connection string is null
            </summary>
        </member>
        <member name="P:MARC.Everest.Exceptions.ConnectorException.Details">
            <summary>
            Details of the operation
            </summary>
        </member>
        <member name="P:MARC.Everest.Exceptions.ConnectorException.Reason">
            <summary>
            Reason for the exception
            </summary>
        </member>
        <member name="M:MARC.Everest.Exceptions.ConnectorException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Exceptions.ConnectorException.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:MARC.Everest.Exceptions.ConnectorException.#ctor(System.String,System.Exception)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:MARC.Everest.Exceptions.ConnectorException.#ctor(System.String,MARC.Everest.Exceptions.ConnectorException.ReasonType)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <param name="reason"></param>
        </member>
        <member name="M:MARC.Everest.Exceptions.ConnectorException.#ctor(System.String,MARC.Everest.Exceptions.ConnectorException.ReasonType,System.Exception)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <param name="reason"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:MARC.Everest.Exceptions.DuplicateItemException">
            <summary>
            Identifies that a duplicate item has been added to a set that doesn't allow duplicate items
            </summary>
            <remarks>
            This exception is thrown whenever an attempt is made to add a duplicate item. This exception exists
            to enforce a conformance rule on <see cref="T:MARC.Everest.DataTypes.SET{T}"/> and is only fired if:
            <list type="bullet">
                <item>The result of the comparator is 0 (ie: the data within the items are identical), or</item>
                <item>The default comparator is 0 (ie: the object reference is the same)</item>
            </list>
            <para>The type of condition under which this exception is thrown depends solely on the type
            of comparator used in the SET</para>
            </remarks>
        </member>
        <member name="M:MARC.Everest.Exceptions.DuplicateItemException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:MARC.Everest.Exceptions.DuplicateItemException.#ctor(System.String)">
            <summary>
            Ctor taking a message.
            </summary>
            <param name="Message">An ExceptionMessage.</param>
        </member>
        <member name="M:MARC.Everest.Exceptions.DuplicateItemException.#ctor(System.String,System.Exception)">
            <summary>
            Ctor taking a exception message and inner exception.
            </summary>
            <param name="Message">An ExceptionMessage.</param>
            <param name="InnerException">An InnerException.</param>
        </member>
        <member name="T:MARC.Everest.Exceptions.FormatterCompileException">
            <summary>
            Extends FormatterException to add more detail.
            </summary>
            <remarks>
            <para>
            This exception is thrown whenever a <see cref="T:MARC.Everest.Connectors.ICodeDomFormatter"/> fails to generate
            the necessary code to properly validate or graph/parse an instance. This exception rarely occurs, and is usually
            seen when developing custom Code Dom based formatters.
            </para>
            </remarks>
        </member>
        <member name="P:MARC.Everest.Exceptions.FormatterCompileException.Results">
            <summary>
            The compilers results.
            </summary>
        </member>
        <member name="P:MARC.Everest.Exceptions.FormatterCompileException.Errors">
            <summary>
            A collection of errors.
            </summary>
        </member>
        <member name="P:MARC.Everest.Exceptions.FormatterCompileException.TempFile">
            <summary>
            Gets the contents of the file that threw the exception.
            </summary>
        </member>
        <member name="M:MARC.Everest.Exceptions.FormatterCompileException.#ctor(System.CodeDom.Compiler.CompilerResults)">
            <summary>
            Gets the result from the original exception.
            </summary>
            <param name="results">The result from the initial exception.</param>
        </member>
        <member name="M:MARC.Everest.Exceptions.FormatterCompileException.ToString">
            <summary>
            Converts the FormatterCompileException to a string.
            </summary>
            <returns>Returns the error message, all error details, and the error code.</returns>
        </member>
        <member name="T:MARC.Everest.Exceptions.FormatterException">
            <summary>
            An Exception that occurs in the formatter.
            </summary>
            <remarks>
            This exception occurs as the result of an exceptional condition during the formatting of an instance.
            </remarks>
        </member>
        <member name="M:MARC.Everest.Exceptions.FormatterException.#ctor">
            <summary>
            Initializes a new instance of the System.Exception class.
            </summary>
        </member>
        <member name="M:MARC.Everest.Exceptions.FormatterException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the System.Exception class with a specified
            error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:MARC.Everest.Exceptions.FormatterException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the System.Exception class with serialized
            data.
            </summary>
            <param name="info">The System.Runtime.Serialization.SerializationInfo that holds the serialized
            object data about the exception being thrown.</param>
            <param name="context">The System.Runtime.Serialization.StreamingContext that contains contextual
            information about the source or destination.</param>
        </member>
        <member name="M:MARC.Everest.Exceptions.FormatterException.#ctor(System.String,System.Exception)">
             <summary>
             Initializes a new instance of the System.Exception class with a specified
             error message and a reference to the inner exception that is the cause of
             this exception.
             </summary>
             <param name="message">The error message that explains the reason for the exception.</param>
             <param name="innerException">The exception that is the cause of the current exception, or a null reference
            (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="T:MARC.Everest.Exceptions.MessageValidationException">
            <summary>
            Marks a message level validation exception
            </summary>
            <remarks>
            This exception usually occurs due to a formal constraint violation in which the formatter can no longer 
            reliably interpret data.
            </remarks>
        </member>
        <member name="P:MARC.Everest.Exceptions.MessageValidationException.Offender">
            <summary>
            Get the offending message part
            </summary>
        </member>
        <member name="M:MARC.Everest.Exceptions.MessageValidationException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Exceptions.MessageValidationException.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:MARC.Everest.Exceptions.MessageValidationException.#ctor(System.String,System.Exception)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:MARC.Everest.Exceptions.MessageValidationException.#ctor(System.String,System.Exception,MARC.Everest.Interfaces.IGraphable)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
            <param name="offender"></param>
        </member>
        <member name="M:MARC.Everest.Exceptions.MessageValidationException.#ctor(System.String,MARC.Everest.Interfaces.IGraphable)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <param name="offender"></param>
        </member>
        <member name="T:MARC.Everest.Exceptions.NamespaceDoc">
            <summary>
            The classes within this namespace contain exceptions used by the Everest Framework
            </summary>
            <remarks>
            <para>These exceptions contain detailed, custom exception classes which 
            are used by formatters and utility classes to convey exceptional information
            to callers.</para>
            </remarks>
        </member>
        <member name="T:MARC.Everest.Exceptions.VocabularyException">
            <summary>
            Signifies a vocabulary exception
            </summary>
            <remarks>
            This exception occurs when Everest attempts to parse a vocabulary structure such as <see cref="T:MARC.Everest.DataTypes.CD"/> and 
            fails to interpret the meaning of the Code. The main cause of this exception is a code that does not fall within a bound code system
            where no alternative code system is provided.
            </remarks>
        </member>
        <member name="P:MARC.Everest.Exceptions.VocabularyException.Mnemonic">
            <summary>
            The Mnemonic that caused the error
            </summary>
        </member>
        <member name="P:MARC.Everest.Exceptions.VocabularyException.CodeSet">
            <summary>
            The code set 
            </summary>
        </member>
        <member name="M:MARC.Everest.Exceptions.VocabularyException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Exceptions.VocabularyException.#ctor(System.String)">
            <summary>
            Creates a new instance of the VocabularyException
            </summary>
            <param name="message">The textual message describing the exception</param>
        </member>
        <member name="M:MARC.Everest.Exceptions.VocabularyException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new instance of the VocabularyException
            </summary>
            <param name="message">The textual message describing the exception</param>
            <param name="innerException">The exception that caused this exception to be raised</param>
        </member>
        <member name="M:MARC.Everest.Exceptions.VocabularyException.#ctor(System.String,MARC.Everest.Interfaces.IGraphable)">
            <summary>
            Creates a new instance of the VocabularyException
            </summary>
            <param name="message">The textual message of the exception</param>
            <param name="offender">The <see cref="T:MARC.Everest.Interfaces.IGraphable"/> interface which caused the exception to be thrown</param>
        </member>
        <member name="M:MARC.Everest.Exceptions.VocabularyException.#ctor(System.String,System.Exception,MARC.Everest.Interfaces.IGraphable)">
            <summary>
            Creates a new instance of the VocabularyException
            </summary>
            <param name="message">The textual message of the exception</param>
            <param name="offender">The <see cref="T:MARC.Everest.Interfaces.IGrapable"/> instance which caused the exception to be thrown</param>
            <param name="innerException">The exception that caused this exception to be thrown</param>
        </member>
        <member name="M:MARC.Everest.Exceptions.VocabularyException.#ctor(System.String,System.String,System.String,MARC.Everest.Interfaces.IGraphable)">
            <summary>
            Creates a new instance of the VocabularyException
            </summary>
            <param name="message">The textual message describing the exception</param>
            <param name="mnemonic">The code mnemonic that caused the vocabulary exception to be thrown</param>
            <param name="codeSet">The code set from which the <paramref name="mnemonic"/> was drawn</param>
            <param name="offender">The <see cref="T:MARC.Everest.Interfaces.IGraphable"/> instance which caused the exception to be thrown</param>
        </member>
        <member name="T:MARC.Everest.Interfaces.IGraphable">
            <summary>
            This interface is an empty interface used to identify that an object can be "graphed" into a particular
            ITS version.
            </summary>
            <remarks>
            <para>
            The object itself does not add any functionality, rather it merely acts as a marker for graphable classes. Formatters
            assume that graphable classes are:
                <list type="bullet">
                    <item>Fully annotated with <see cref="T:MARC.Everest.Attributes.StructureAttribute"/> attributes</item>    
                    <item>Are serializable and correct</item>
                    <item>Most are generated from GPMR</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="T:MARC.Everest.Interfaces.IIdentifiable">
            <summary>
            Signifies a class that can be identified
            </summary>
            <remarks>
            <para>GPMR will attach this interface to any RMIM class which is identifiable
            by only one identifier. It will not attach this interface to 
            classes which permit the use of multiple identifiers
            </para>
            </remarks>
            <example>
            The following example will iterate through any instance and will
            print out all identifiers contained within the message
            <code lang="cs" title="Get all Identified Objects">
                public static void PrintIds(IGraphable g)
                {
                    // Can't scan a null object
                    if(g == null) return;
                    
                    Type gType = g.GetType();
                    foreach(PropertyInfo pi in gType.GetProperties(BindingFlags.Instance | BindingFlags.Public))
                    {
                        object value = pi.GetValue(g, null);
                        
                        // Don't report null objects
                        if(value == null)
                            continue;
                            
                        IIdentifiable identifiableObject = value as IIdentifiable;
                        ISetIdentifiable setIdentifiableObject = value as ISetIdentifiable;
                        if(identifiableObject != null)
                            Console.WriteLine("{0} : {1}@{2}", pi.Name, identifiableObject.Id.Root, identifiableObject.Id.Extension);
                        else if(setIdentifiableObject != null)
                        {
                            foreach(var ii in setIdentifiableObject.Id)
                                Console.WriteLine("{0} : {1}@{2}", pi.Name, ii.Root, ii.Extension);
                        }
                        // Scan type
                        PrintIds(value as IGraphable);
                    }
                }
            </code>
            </example>
            <seealso cref="T:MARC.Everest.Interfaces.ISetIdentifiable"/>
        </member>
        <member name="P:MARC.Everest.Interfaces.IIdentifiable.Id">
            <summary>
            A globally unique identifier
            </summary>
        </member>
        <member name="T:MARC.Everest.Interfaces.ISetIdentifiable">
            <summary>
            Signifies a class that can be identified with a set of identifiers
            </summary>
            <remarks>
            <para>GPMR will attach this interface to any RMIM class which is identifiable
            by multiple identifiers. It will not attach this interface to 
            classes which use only one identifier.
            </para>    
            </remarks>
            <example>
            For an example of using this interface see <see cref="T:MARC.Everest.Interfaces.IIdentifier"/>
            </example>
            <seealso cref="T:MARC.Everest.Interfaces.IIdentifiable"/>
        </member>
        <member name="P:MARC.Everest.Interfaces.ISetIdentifiable.Id">
            <summary>
            Gets a set of identifiers for the object
            </summary>
        </member>
        <member name="T:MARC.Everest.Interfaces.IImplementsProfileId">
            <summary>
            Represents a class that implements a get of a profile identifier
            </summary>
        </member>
        <member name="P:MARC.Everest.Interfaces.IImplementsProfileId.ProfileId">
            <summary>
            Gets the profile identifier for the interaction
            </summary>
        </member>
        <member name="T:MARC.Everest.Interfaces.IImplementsAcceptAckCode`1">
            <summary>
            Identifies a class as implementing accept ack code
            </summary>
            <remarks>
            This interface is appended to any RMIM class that implements the AcceptAckCode. It is 
            usually used in conjunction with the <see cref="T:MARC.Everest.Interfaces.IInteraction"/> interface, 
            however its functionality is separated due to the fact that the codification system for 
            an AcceptAckCode is determined by the class itself, rather than the interface.
            </remarks>
            <typeparam name="T">The code system from which accept ack codes are taken</typeparam>
            <seealso cref="T:MARC.Everest.Interfaces.IInteraction"/>
        </member>
        <member name="P:MARC.Everest.Interfaces.IImplementsAcceptAckCode`1.AcceptAckCode">
            <summary>
            A code that states when a acknowledgment message should be received.
            </summary>
        </member>
        <member name="T:MARC.Everest.Interfaces.IImplementsMoodCode">
            <summary>
            Identifies that a class or structure has a mood code
            </summary>
            <remarks>
            GPMR will attach this interface to any RMIM classes that implement 
            the concept of a mood code. A mood code can be used to determine the 
            mood of an act within an instance. Common mood codes are:
            <list type="bullet">
                <item><strong>EVN</strong> - An event occurred triggering the act</item>
                <item><strong>RQO</strong> - The act represents a request</item>
            </list>
            <para>
            This interface is the non-genericised version of IImplementsMoodCode, another 
            interface exists for classes which implement a mood code with a strongly bound
            code system.
            </para>
            </remarks>
        </member>
        <member name="P:MARC.Everest.Interfaces.IImplementsMoodCode.MoodCode">
            <summary>
            A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.
            </summary>
        </member>
        <member name="T:MARC.Everest.Interfaces.IImplementsMoodCode`1">
            <summary>
            Identifies the the class or structure has a mood code
            </summary>
            <seealso cref="T:MARC.Everest.Interfaces.IImplementsMoodCode"/>
            <typeparam name="T">The code system from which mood codes are taken</typeparam>
        </member>
        <member name="P:MARC.Everest.Interfaces.IImplementsMoodCode`1.MoodCode">
            <summary>
            A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.
            </summary>
        </member>
        <member name="T:MARC.Everest.Interfaces.IImplementsNullFlavor">
            <summary>
            Identifies that a class has a nullflavor
            </summary>
            <remarks>
            This interface is used primarily by data types that implement the 
            concept of a null flavor
            </remarks>
        </member>
        <member name="P:MARC.Everest.Interfaces.IImplementsNullFlavor.NullFlavor">
            <summary>
            The nullflavor of the object
            </summary>
        </member>
        <member name="T:MARC.Everest.Interfaces.IImplementsProcessingCode`1">
            <summary>
            Implements IProcessingCode
            </summary>
            <typeparam name="T">The code system from which processing codes are drawn</typeparam>
            <remarks>
            <para>This interface is attached to RMIM classes by GPMR which implement
            the concept of a ProcessingCode. This interface is almost always used in 
            conjunction with <see cref="T:MARC.Everest.Interfaces.IInteraction"/>, but
            is separated as the code system (defined by <typeparamref name="T"/>) is 
            identified by the processing code property rather than the class itself.</para>
            </remarks>
            <seealso cref="T:MARC.Everest.Interfaces.IInteraction"/>
        </member>
        <member name="P:MARC.Everest.Interfaces.IImplementsProcessingCode`1.ProcessingCode">
            <summary>
            Processing Code
            </summary>
        </member>
        <member name="T:MARC.Everest.Interfaces.IImplementsReasonCode">
            <summary>
            A class implements a reason code
            </summary>
            <remarks>
            <para>
            This interface is attached to RMIM classes by GPMR when the class implements the 
            concept of a reason code. This is the non-genericised version of the IImplementsReasonCode
            interface where the code set from which reason codes are drawn is not strongy bound.
            </para>
            </remarks>
        </member>
        <member name="P:MARC.Everest.Interfaces.IImplementsReasonCode.ReasonCode">
            <summary>
            The reason why an event occured
            </summary>
        </member>
        <member name="T:MARC.Everest.Interfaces.IImplementsReasonCode`1">
            <summary>
            Implements a reason code
            </summary>
            <typeparam name="T">The code system from which the ReasonCode is drawn</typeparam>
            <seealso cref="T:MARC.Everest.Interfaces.IImplementsReasonCode"/>
        </member>
        <member name="P:MARC.Everest.Interfaces.IImplementsReasonCode`1.ReasonCode">
            <summary>
            The reason why an event occured
            </summary>
        </member>
        <member name="T:MARC.Everest.Interfaces.IImplementsResponseModeCode`1">
            <summary>
            Summary of IImplementsResponseModeCode
            </summary>
            <typeparam name="T">The code system enumeration from which response mode codes are drawn</typeparam>
            <remarks>
            <para>This interface is used by GPMR to annotate classes (usually which also implement
            the <see cref="T:MARC.Everest.Interfaces.IInteraction"/> interface) that contain 
            a response mode code.</para>
            </remarks>
            <seealso cref="T:MARC.Everest.Interfaces.IInteraction"/>
        </member>
        <member name="P:MARC.Everest.Interfaces.IImplementsResponseModeCode`1.ResponseModeCode">
            <summary>
            Way in which the receiver should respond
            </summary>
        </member>
        <member name="T:MARC.Everest.Interfaces.IImplementsStatusCode">
            <summary>
            Does this implement status code with no generics?
            </summary>
            <remarks>
            <para>This interface denotes that a particular RMIM class supports
            the concept of a status code. This is the non genericised version
            of IImplementsStatusCode where the code that identifies the status
            of the object is not strongly bound to a particular code system.</para>
            </remarks>
        </member>
        <member name="P:MARC.Everest.Interfaces.IImplementsStatusCode.StatusCode">
            <summary>
            Identifies the current state of the item
            </summary>
        </member>
        <member name="T:MARC.Everest.Interfaces.IImplementsStatusCode`1">
            <summary>
            Signifies a class that implements a state machine
            </summary>
            <typeparam name="T">The code set from which status codes are drawn</typeparam>
            <seealso cref="T:MARC.Everest.Interfaces.IImplementsStatusCode"/>
        </member>
        <member name="P:MARC.Everest.Interfaces.IImplementsStatusCode`1.StatusCode">
            <summary>
            This identifies the current state of the item
            </summary>
        </member>
        <member name="T:MARC.Everest.Interfaces.IImplementsText">
            <summary>
            Identifies that a class implements a property named "Text"
            </summary>
            <remarks>GPMR will attach this interface to any class that has a property named
            "Text" with a data type of ED</remarks>
        </member>
        <member name="P:MARC.Everest.Interfaces.IImplementsText.Text">
            <summary>
            Gets or sets the text of the object
            </summary>
        </member>
        <member name="T:MARC.Everest.Interfaces.IImplementsTitle">
            <summary>
            Identifies a class that has a "Title" property
            </summary>
            <remarks>GPMR will append this interface to any RMIM structure that has
            identified a property named Title with the data type ST</remarks>
        </member>
        <member name="P:MARC.Everest.Interfaces.IImplementsTitle.Title">
            <summary>
            Gets or sets the title of the structure
            </summary>
        </member>
        <member name="T:MARC.Everest.Interfaces.IImplementsTypeId">
            <summary>
            Implements the TypeId property to determine the type of the message
            </summary>
        </member>
        <member name="P:MARC.Everest.Interfaces.IImplementsTypeId.TypeId">
            <summary>
            Gets or sets the ID of the type
            </summary>
        </member>
        <member name="T:MARC.Everest.Interfaces.IInteraction">
            <summary>
            Identifies a type as being an interaction
            </summary>
            <remarks>
            <para>This interface is used by GPMR to denote RMIM classes which contain
            all of the "core" information that an interaction would carry. Note that the
            presence of this interface does not mean the class is an interaction, rather
            it may be the base class for an interaction. For a definitive signal that 
            a class is an interaction, the <see cref="T:MARC.Everest.Attributes.StructureAttribute"/>
            or <see cref="T:MARC.Everest.Attributes.InteractionAttribute"/> attribute should be used.
            </para>
            <para>
            This interface is usually attached to the Message class that represents a transport wrapper
            which is used by an interaction to "bind" together a transport, control act and payload.
            </para>
            </remarks>
            <example>
            <code lang="cs" title="Parsing an Interaction">
               <![CDATA[
            IGraphable instance = formatter.ParseObject(File.OpenRead(@"C:\temp.xml"));
            
            // We can get the identifier
            if(instance is IIdentifiable)
                Console.WriteLine((instance as IIdentifiable).Id);
            
            // Or we can use the IInteraction interface to get interaction details
            IInteraction interaction = instance as IInteraction;
            if(interaction != null)
                Console.WriteLine(interaction.InteractionId.Extension);
               ]]>
            </code>
            </example>
        </member>
        <member name="P:MARC.Everest.Interfaces.IInteraction.CreationTime">
            <summary>
            Indicates the time this particular message instance was constructed.
            </summary>
        </member>
        <member name="P:MARC.Everest.Interfaces.IInteraction.VersionCode">
            <summary>
            Indicates the version of the messaging standard being referenced.
            </summary>
        </member>
        <member name="P:MARC.Everest.Interfaces.IInteraction.InteractionId">
            <summary>
            Indicates the id of the interaction being executed
            </summary>
        </member>
        <member name="P:MARC.Everest.Interfaces.IInteraction.ProcessingModeCode">
            <summary>
            Processing Mode
            </summary>
        </member>
        <member name="P:MARC.Everest.Interfaces.IInteraction.ControlAct">
            <summary>
            Gets or sets the control act event
            </summary>
        </member>
        <member name="T:MARC.Everest.Interfaces.NamespaceDoc">
            <summary>
            This namespace contains interfaces that are implemented by RMIM classes
            </summary>
            <remarks>
            <para>These interfaces are implemented by RMIM classes and assigned by GPMR. The 
            purpose of the interfaces are to facilitate general formatting and parsing of 
            instances.</para>
            <para>Perhaps the most useful application of these interfaces are on the processing
            of message results</para>
            </remarks>
            <example>
            <code lang="cs" title="Parsing an Interaction">
               <![CDATA[
            IGraphable instance = formatter.ParseObject(File.OpenRead(@"C:\temp.xml"));
            
            // We can get the identifier
            if(instance is IIdentifiable)
                Console.WriteLine((instance as IIdentifiable).Id);
            
            // Or we can use the IInteraction interface to get interaction details
            IInteraction interaction = instance as IInteraction;
            if(interaction != null)
                Console.WriteLine(interaction.InteractionId.Extension);
               ]]>
            </code>
            </example>
        </member>
        <member name="T:MARC.Everest.NamespaceDoc">
            <summary>
            The root namespace for all Everest components
            </summary>
            <remarks>
            <para>The MARC-HI Everest Framework is an open source, flexible and 
            robust framework for creating and interpreting HL7v3 instances.</para>
            <para>All classes within the MARC-HI Everest Framework exist within the
            MARC.Everest namespace. This makes it easier to determine which portions
            of your application belong to the Everest Framework and which do not.</para>
            </remarks>
        </member>
        <member name="T:MARC.Everest.Threading.WaitThreadPool">
            <summary>
            Represents an implementation of a thread pool that is separate from the default
            .NET thread pool
            </summary>
            <remarks>
            <para>Many of the processes within formatters, connectors and the core
            Everest Framework are multi-threaded, and represent long running tasks.
            This implementation of a thread pool allows for long running tasks
            to be executed within a constrained pool of threads without interrupting
            the core <see cref="T:System.Threading.ThreadPool"/>.</para>
            <para>This thread pool also has the ability to wait until all the
            threads within the thread pool have been completed and allows for
            a timeout to be specified (ie: wait 10 seconds for all tasks to finish).</para>
            <example>
            <code lang="cs" title="Using the WaitThreadPool">
            <![CDATA[
                WaitThreadPool poolie = new WaitThreadPool();
                for(int i = 0; i < 10; i++)
                    poolie.QueueUserWorkItem((WaitCallback)delegate(object state) {
                        for(int w = 0; w < 1000000; w++)
                            Console.WriteLine("{0}", w);
                    });
                poolie.WaitOne(new Timespan(0, 0, 1)); // Wait for one second for pool to finish
            ]]>
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:MARC.Everest.Threading.WaitThreadPool.#ctor">
            <summary>
            Creates a new instance of the wait thread pool
            </summary>
        </member>
        <member name="M:MARC.Everest.Threading.WaitThreadPool.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the wait thread pool
            </summary>
        </member>
        <member name="T:MARC.Everest.Threading.WaitThreadPool.WorkItem">
            <summary>
            Worker data structure
            </summary>
        </member>
        <member name="P:MARC.Everest.Threading.WaitThreadPool.WorkItem.Callback">
            <summary>
            The callback to execute on the worker
            </summary>
        </member>
        <member name="P:MARC.Everest.Threading.WaitThreadPool.WorkItem.State">
            <summary>
            The state or parameter to the worker
            </summary>
        </member>
        <member name="P:MARC.Everest.Threading.WaitThreadPool.WorkItem.ExecutionContext">
            <summary>
            The execution context
            </summary>
        </member>
        <member name="M:MARC.Everest.Threading.WaitThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
            <summary>
            Queue a work item to be completed
            </summary>
        </member>
        <member name="M:MARC.Everest.Threading.WaitThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)">
            <summary>
            Queue a user work item with the specified parameters
            </summary>
        </member>
        <member name="M:MARC.Everest.Threading.WaitThreadPool.EnsureStarted">
            <summary>
            Ensure the thread pool threads are started
            </summary>
        </member>
        <member name="M:MARC.Everest.Threading.WaitThreadPool.DispatchLoop">
            <summary>
            Dispatch loop
            </summary>
        </member>
        <member name="M:MARC.Everest.Threading.WaitThreadPool.WaitOne">
            <summary>
            Wait until the thread is complete
            </summary>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.Threading.WaitThreadPool.WaitOne(System.TimeSpan,System.Boolean)">
            <summary>
            Wait until the thread is complete or the specified timeout elapses
            </summary>
        </member>
        <member name="M:MARC.Everest.Threading.WaitThreadPool.WaitOne(System.Int32,System.Boolean)">
            <summary>
            Wait until the thread is completed
            </summary>
        </member>
        <member name="M:MARC.Everest.Threading.WaitThreadPool.DoWorkItem(MARC.Everest.Threading.WaitThreadPool.WorkItem)">
            <summary>
            Perform the work if the specified work data
            </summary>
        </member>
        <member name="M:MARC.Everest.Threading.WaitThreadPool.DoneWorkItem">
            <summary>
            Complete a workf item
            </summary>
        </member>
        <member name="M:MARC.Everest.Threading.WaitThreadPool.ThrowIfDisposed">
            <summary>
            Throw an exception if the object is disposed
            </summary>
        </member>
        <member name="M:MARC.Everest.Threading.WaitThreadPool.Dispose">
            <summary>
            Dispose the object
            </summary>
        </member>
        <member name="T:MARC.Everest.Xml.NamespaceDoc">
            <summary>
            Classes within this namespace are used to facilitate the formatting of 
            data to/from XML
            </summary>
            <remarks>
            <para>The <see cref="T:MARC.Everest.Xml.XmlStateWriter"/> and <see cref="T:MARC.Everest.Xml.XmlStateReader"/>
            classes are wrapper for the <see cref="T:System.Xml.XmlWriter"/> and <see cref="T:System.Xml.XmlReader"/>
            classes respectively. These classes add the functionality of determining the path to the current 
            element and thus, are used by formatters to report errors.</para>
            </remarks>
            <example>
            The following example illustrates the use of the XmlStateWriter
            <code lang="cs" title="Getting the current path">
            Stream s = Console.OpenStandardOutput();
            XmlStateWriter writer = new XmlStateWriter(XmlWriter.Create(s));
            
            // Write the start of an HTML document
            writer.WriteStartElement("html");
            writer.WriteStartElement("body");
            
            // currentPath will be "/html/body"
            string currentPath = writer.CurrentPath; 
            
            writer.WriteStartElement("p"); 
            // currentPath will be "/html/body/p"
            currentPath = writer.CurrentPath; 
            
            writer.WriteEndElement();
            writer.WriteEndElement();
            // currentPath will be "/html"
            currentPath = writer.CurrentPath;
            
            writer.WriteEndElement();
            </code>
            </example>
        </member>
        <member name="T:MARC.Everest.Xml.XmlStateReader">
            <summary>
            An <see cref="T:System.Xml.XmlReader"/> that keeps track of its current state
            </summary>
            <example>
            See <see cref="T:MARC.Everest.Xml.XmlStateWriter"/> for an example of using these classes
            </example>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.ToString">
            <summary>
            Represent this state reader as a string (path)
            </summary>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.#ctor(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="xr"></param>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateReader.Settings">
            <summary>
            Get the inner reading settings
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.AddFakeAttribute(System.String,System.String)">
            <summary>
            Add a fake attribute. Fake attributes don't appear in the stream, but can be used by 
            formatters to pass attributes to graph aides. Fake attributes appear to be "real"
            as they are returned by the <see cref="F:GetAttribute()"/> function.
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateReader.CurrentPath">
            <summary>
            Get the current XML path 
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateReader.CurrentXPath">
            <summary>
            Get the current XML path 
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateReader.ElementStack">
            <summary>
            Element stack
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateReader.CurrentElement">
            <summary>
            Gets the current name stack
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateReader.AttributeCount">
            <summary>
            
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateReader.BaseURI">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.Close">
            <summary>
            Closes this stream and the underlying stream
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateReader.Depth">
            <summary>
            
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateReader.EOF">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.GetAttribute(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.GetAttribute(System.String,System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.GetAttribute(System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.RemoveAttribute(System.String)">
            <summary>
            Remove attribute
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateReader.HasValue">
            <summary>
            
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateReader.IsEmptyElement">
            <summary>
            
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateReader.LocalName">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.LookupNamespace(System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.MoveToAttribute(System.String,System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.MoveToAttribute(System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.MoveToElement">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.MoveToFirstAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.MoveToNextAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateReader.NameTable">
            <summary>
            
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateReader.NamespaceURI">
            <summary>
            
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateReader.NodeType">
            <summary>
            
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateReader.Prefix">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.Read">
            <summary>
            
            </summary>
            <exception cref="T:MARC.Everest.Exceptions.MessageValidationException">When an attempt is made to read a closing element that
            does not match the starting element</exception>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.ReadAttributeValue">
            <summary>
            
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateReader.ReadState">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.ResolveEntity">
            <summary>
            
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateReader.Value">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.GetNamespacesInScope(System.Xml.XmlNamespaceScope)">
            <summary>
            Get namespaces in the specified scope
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateReader.LookupPrefix(System.String)">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="T:MARC.Everest.Xml.XmlStateWriter">
            <summary>
            A <see cref="T:System.Xml.XmlWriter"/> that tracks its state
            </summary>
            <example>
            The following example illustrates the use of the XmlStateWriter
            <code lang="cs" title="Getting the current path">
            Stream s = Console.OpenStandardOutput();
            XmlStateWriter writer = new XmlStateWriter(XmlWriter.Create(s));
            
            // Write the start of an HTML document
            writer.WriteStartElement("html");
            writer.WriteStartElement("body");
            
            // currentPath will be "/html/body"
            string currentPath = writer.CurrentPath; 
            
            writer.WriteStartElement("p"); 
            // currentPath will be "/html/body/p"
            currentPath = writer.CurrentPath; 
            
            writer.WriteEndElement();
            writer.WriteEndElement();
            // currentPath will be "/html"
            currentPath = writer.CurrentPath;
            
            writer.WriteEndElement();
            </code>
            </example>    
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.ToString">
            <summary>
            Represents the state writer as a string (current path)
            </summary>
            <returns></returns>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateWriter.DefaultElementNamespaceUri">
            <summary>
            Identifies the default namespace to emit when no namespace is specified for Element
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.#ctor(System.Xml.XmlWriter)">
            <summary>
            
            </summary>
            <param name="xw"></param>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateWriter.CurrentPath">
            <summary>
            Get the current XML path 
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateWriter.Settings">
            <summary>
            Get the inner reading settings
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateWriter.ElementStack">
            <summary>
            Element stack
            </summary>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateWriter.CurrentElement">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.Close">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.Flush">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.LookupPrefix(System.String)">
            <summary>
            
            </summary>
            <param name="ns"></param>
            <returns></returns>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteBase64(System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteCData(System.String)">
            <summary>
            
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteCharEntity(System.Char)">
            <summary>
            
            </summary>
            <param name="ch"></param>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteChars(System.Char[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteComment(System.String)">
            <summary>
            
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteDocType(System.String,System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="pubid"></param>
            <param name="sysid"></param>
            <param name="subset"></param>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteEndAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteEndDocument">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteEndElement">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteEntityRef(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteFullEndElement">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteProcessingInstruction(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="text"></param>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteRaw(System.String)">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteRaw(System.Char[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteStartAttribute(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="prefix"></param>
            <param name="localName"></param>
            <param name="ns"></param>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteStartDocument(System.Boolean)">
            <summary>
            
            </summary>
            <param name="standalone"></param>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteStartDocument">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteStartElement(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="prefix"></param>
            <param name="localName"></param>
            <param name="ns"></param>
        </member>
        <member name="P:MARC.Everest.Xml.XmlStateWriter.WriteState">
            <summary>
            
            </summary>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteString(System.String)">
            <summary>
            
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteSurrogateCharEntity(System.Char,System.Char)">
            <summary>
            
            </summary>
            <param name="lowChar"></param>
            <param name="highChar"></param>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.WriteWhitespace(System.String)">
            <summary>
            
            </summary>
            <param name="ws"></param>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.GetNamespacesInScope(System.Xml.XmlNamespaceScope)">
            <summary>
            Get namespaces in scope
            </summary>
            <exception cref="T:System.NotImplementedException">This method is not implemented in this version of the Everest Framework</exception>
        </member>
        <member name="M:MARC.Everest.Xml.XmlStateWriter.LookupNamespace(System.String)">
            <summary>
            Lookup a namespace prefix
            </summary>
            <exception cref="T:System.NotImplementedException">This method is not implemented in this version of the Everest Framework</exception>
        </member>
    </members>
</doc>
